<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>A Python Book: Beginning Python, Advanced Python, and Python Exercises</title>
<meta name="author" content="Dave Kuhlman" />
<style type="text/css">

/* css */

body {
  font: 90% 'Lucida Grande', Verdana, Geneva, Lucida, Arial, Helvetica, sans-serif;
  background: #ffffff;
  color: black;
  margin: 2em;
  padding: 2em;
}

a[href] {
  color: #436976;
  background-color: transparent;
}

a.toc-backref {
  text-decoration: none;
}

h1 a[href] {
  text-decoration: none;
  color: #fcb100;
  background-color: transparent;
}

a.strong {
  font-weight: bold;
}

img {
  margin: 0;
  border: 0;
}

p {
  margin: 0.5em 0 1em 0;
  line-height: 1.5em;
}
p a {
  text-decoration: underline;
}
p a:visited {
  color: purple;
  background-color: transparent;
}
p a:active {
  color: red;
  background-color: transparent;
}
a:hover {
  text-decoration: none;
}
p img {
  border: 0;
  margin: 0;
}

h1, h2, h3, h4, h5, h6 {
  color: #003a6b;
  background-color: transparent;
  font: 100% 'Lucida Grande', Verdana, Geneva, Lucida, Arial, Helvetica, sans-serif;
  margin: 0;
  padding-top: 0.5em;
}

h1 {
  font-size: 160%;
  margin-bottom: 0.5em;
  border-bottom: 1px solid #fcb100;
}
h2 {
  font-size: 140%;
  margin-bottom: 0.5em;
  border-bottom: 1px solid #aaa;
}
h3 {
  font-size: 130%;
  margin-bottom: 0.5em;
  text-decoration: underline;
}
h4 {
  font-size: 110%;
  font-weight: bold;
}
h5 {
  font-size: 100%;
  font-weight: bold;
}
h6 {
  font-size: 80%;
  font-weight: bold;
}

ul a, ol a {
  text-decoration: underline;
}

dt {
  font-weight: bold;
}
dt a {
  text-decoration: none;
}

dd {
  line-height: 1.5em;
  margin-bottom: 1em;
}

legend {
  background: #ffffff;
  padding: 0.5em;
}

form {
  margin: 0;
}


dl.form {
  margin: 0;
  padding: 1em;
}

dl.form dt {
  width: 30%;
  float: left;
  margin: 0;
  padding: 0 0.5em 0.5em 0;
  text-align: right;
}

input {
  font: 100% 'Lucida Grande', Verdana, Geneva, Lucida, Arial, Helvetica, sans-serif;
  color: black;
  background-color: white;
  vertical-align: middle;
}

abbr, acronym, .explain {
  color: black;
  background-color: transparent;
}

q, blockquote {
}

code, pre {
  font-family: monospace;
  font-size: 1.2em;
  display: block;
  padding: 10px;
  border: 1px solid #838183;
  background-color: #eee;
  color: #000;
  overflow: auto;
  margin: 0.5em 1em;
}

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

tt.docutils {
  background-color: #dddddd;
}

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="a-python-book-beginning-python-advanced-python-and-python-exercises">
<h1 class="title">A Python Book: Beginning Python, Advanced Python, and Python Exercises</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Dave Kuhlman</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td>dkuhlman (at) davekuhlman (dot) org</td></tr>
<tr><th class="docinfo-name">Address:</th>
<td><pre class="address">
<a class="first last reference external" href="http://www.davekuhlman.org">http://www.davekuhlman.org</a>
</pre>
</td></tr>
</tbody>
</table>
<!-- vim: set ft=rst: -->
<hr class="docutils" />
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Revision:</th><td class="field-body">1.3a</td>
</tr>
<tr class="field"><th class="field-name">Date:</th><td class="field-body">October 05, 2014</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">Copyright (c) 2009 Dave Kuhlman.  All Rights Reserved.
This document is subject to the provisions of the Open Source
MIT License <a class="reference external" href="http://www.opensource.org/licenses/mit-license.php">http://www.opensource.org/licenses/mit-license.php</a>.</td>
</tr>
<tr class="field"><th class="field-name">Abstract:</th><td class="field-body">This document is a self-learning document for a course in
Python programming. This course contains (1) a part for
beginners, (2) a discussion of several advanced topics that are
of interest to Python programmers, and (3) a Python workbook
with lots of exercises.</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#part-1-beginning-python" id="id27">1&nbsp;&nbsp;&nbsp;Part 1 -- Beginning Python</a><ul class="auto-toc">
<li><a class="reference internal" href="#introductions-etc" id="id28">1.1&nbsp;&nbsp;&nbsp;Introductions Etc</a><ul class="auto-toc">
<li><a class="reference internal" href="#resources" id="id29">1.1.1&nbsp;&nbsp;&nbsp;Resources</a></li>
<li><a class="reference internal" href="#a-general-description-of-python" id="id30">1.1.2&nbsp;&nbsp;&nbsp;A general description of Python</a></li>
<li><a class="reference internal" href="#interactive-python" id="id31">1.1.3&nbsp;&nbsp;&nbsp;Interactive Python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lexical-matters" id="id32">1.2&nbsp;&nbsp;&nbsp;Lexical matters</a><ul class="auto-toc">
<li><a class="reference internal" href="#lines" id="id33">1.2.1&nbsp;&nbsp;&nbsp;Lines</a></li>
<li><a class="reference internal" href="#comments" id="id34">1.2.2&nbsp;&nbsp;&nbsp;Comments</a></li>
<li><a class="reference internal" href="#names-and-tokens" id="id35">1.2.3&nbsp;&nbsp;&nbsp;Names and tokens</a></li>
<li><a class="reference internal" href="#blocks-and-indentation" id="id36">1.2.4&nbsp;&nbsp;&nbsp;Blocks and indentation</a></li>
<li><a class="reference internal" href="#doc-strings" id="id37">1.2.5&nbsp;&nbsp;&nbsp;Doc strings</a></li>
<li><a class="reference internal" href="#program-structure" id="id38">1.2.6&nbsp;&nbsp;&nbsp;Program structure</a></li>
<li><a class="reference internal" href="#operators" id="id39">1.2.7&nbsp;&nbsp;&nbsp;Operators</a></li>
<li><a class="reference internal" href="#also-see" id="id40">1.2.8&nbsp;&nbsp;&nbsp;Also see</a></li>
<li><a class="reference internal" href="#code-evaluation" id="id41">1.2.9&nbsp;&nbsp;&nbsp;Code evaluation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#statements-and-inspection-preliminaries" id="id42">1.3&nbsp;&nbsp;&nbsp;Statements and inspection -- preliminaries</a></li>
<li><a class="reference internal" href="#built-in-data-types" id="id43">1.4&nbsp;&nbsp;&nbsp;Built-in data-types</a><ul class="auto-toc">
<li><a class="reference internal" href="#numeric-types" id="id44">1.4.1&nbsp;&nbsp;&nbsp;Numeric types</a></li>
<li><a class="reference internal" href="#tuples-and-lists" id="id45">1.4.2&nbsp;&nbsp;&nbsp;Tuples and lists</a></li>
<li><a class="reference internal" href="#strings" id="id46">1.4.3&nbsp;&nbsp;&nbsp;Strings</a><ul class="auto-toc">
<li><a class="reference internal" href="#the-new-string-format-method" id="id47">1.4.3.1&nbsp;&nbsp;&nbsp;The new string.format method</a></li>
<li><a class="reference internal" href="#unicode-strings" id="id48">1.4.3.2&nbsp;&nbsp;&nbsp;Unicode strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dictionaries" id="id49">1.4.4&nbsp;&nbsp;&nbsp;Dictionaries</a></li>
<li><a class="reference internal" href="#files" id="id50">1.4.5&nbsp;&nbsp;&nbsp;Files</a></li>
<li><a class="reference internal" href="#other-built-in-types" id="id51">1.4.6&nbsp;&nbsp;&nbsp;Other built-in types</a><ul class="auto-toc">
<li><a class="reference internal" href="#the-none-value-type" id="id52">1.4.6.1&nbsp;&nbsp;&nbsp;The None value/type</a></li>
<li><a class="reference internal" href="#boolean-values" id="id53">1.4.6.2&nbsp;&nbsp;&nbsp;Boolean values</a></li>
<li><a class="reference internal" href="#sets-and-frozensets" id="id54">1.4.6.3&nbsp;&nbsp;&nbsp;Sets and frozensets</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#functions-and-classes-a-preview" id="id55">1.5&nbsp;&nbsp;&nbsp;Functions and Classes -- A Preview</a></li>
<li><a class="reference internal" href="#statements" id="id56">1.6&nbsp;&nbsp;&nbsp;Statements</a><ul class="auto-toc">
<li><a class="reference internal" href="#assignment-statement" id="id57">1.6.1&nbsp;&nbsp;&nbsp;Assignment statement</a></li>
<li><a class="reference internal" href="#import-statement" id="id58">1.6.2&nbsp;&nbsp;&nbsp;import statement</a></li>
<li><a class="reference internal" href="#print-statement" id="id59">1.6.3&nbsp;&nbsp;&nbsp;print statement</a></li>
<li><a class="reference internal" href="#if-elif-else-statement" id="id60">1.6.4&nbsp;&nbsp;&nbsp;if: elif: else: statement</a></li>
<li><a class="reference internal" href="#for-statement" id="id61">1.6.5&nbsp;&nbsp;&nbsp;for: statement</a></li>
<li><a class="reference internal" href="#while-statement" id="id62">1.6.6&nbsp;&nbsp;&nbsp;while: statement</a></li>
<li><a class="reference internal" href="#continue-and-break-statements" id="id63">1.6.7&nbsp;&nbsp;&nbsp;continue and break statements</a></li>
<li><a class="reference internal" href="#try-except-statement" id="id64">1.6.8&nbsp;&nbsp;&nbsp;try: except: statement</a></li>
<li><a class="reference internal" href="#raise-statement" id="id65">1.6.9&nbsp;&nbsp;&nbsp;raise statement</a></li>
<li><a class="reference internal" href="#with-statement" id="id66">1.6.10&nbsp;&nbsp;&nbsp;with: statement</a><ul class="auto-toc">
<li><a class="reference internal" href="#writing-a-context-manager" id="id67">1.6.10.1&nbsp;&nbsp;&nbsp;Writing a context manager</a></li>
<li><a class="reference internal" href="#using-the-with-statement" id="id68">1.6.10.2&nbsp;&nbsp;&nbsp;Using the with: statement</a></li>
</ul>
</li>
<li><a class="reference internal" href="#del" id="id69">1.6.11&nbsp;&nbsp;&nbsp;del</a></li>
<li><a class="reference internal" href="#case-statement" id="id70">1.6.12&nbsp;&nbsp;&nbsp;case statement</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions-modules-packages-and-debugging" id="id71">1.7&nbsp;&nbsp;&nbsp;Functions, Modules, Packages, and Debugging</a><ul class="auto-toc">
<li><a class="reference internal" href="#functions" id="id72">1.7.1&nbsp;&nbsp;&nbsp;Functions</a><ul class="auto-toc">
<li><a class="reference internal" href="#the-def-statement" id="id73">1.7.1.1&nbsp;&nbsp;&nbsp;The def statement</a></li>
<li><a class="reference internal" href="#returning-values" id="id74">1.7.1.2&nbsp;&nbsp;&nbsp;Returning values</a></li>
<li><a class="reference internal" href="#parameters" id="id75">1.7.1.3&nbsp;&nbsp;&nbsp;Parameters</a></li>
<li><a class="reference internal" href="#arguments" id="id76">1.7.1.4&nbsp;&nbsp;&nbsp;Arguments</a></li>
<li><a class="reference internal" href="#local-variables" id="id77">1.7.1.5&nbsp;&nbsp;&nbsp;Local variables</a></li>
<li><a class="reference internal" href="#other-things-to-know-about-functions" id="id78">1.7.1.6&nbsp;&nbsp;&nbsp;Other things to know about functions</a></li>
<li><a class="reference internal" href="#global-variables-and-the-global-statement" id="id79">1.7.1.7&nbsp;&nbsp;&nbsp;Global variables and the global statement</a></li>
<li><a class="reference internal" href="#doc-strings-for-functions" id="id80">1.7.1.8&nbsp;&nbsp;&nbsp;Doc strings for functions</a></li>
<li><a class="reference internal" href="#decorators-for-functions" id="id81">1.7.1.9&nbsp;&nbsp;&nbsp;Decorators for functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lambda" id="id82">1.7.2&nbsp;&nbsp;&nbsp;lambda</a></li>
<li><a class="reference internal" href="#iterators-and-generators" id="id83">1.7.3&nbsp;&nbsp;&nbsp;Iterators and generators</a></li>
<li><a class="reference internal" href="#modules" id="id84">1.7.4&nbsp;&nbsp;&nbsp;Modules</a><ul class="auto-toc">
<li><a class="reference internal" href="#doc-strings-for-modules" id="id85">1.7.4.1&nbsp;&nbsp;&nbsp;Doc strings for modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#packages" id="id86">1.7.5&nbsp;&nbsp;&nbsp;Packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#classes" id="id87">1.8&nbsp;&nbsp;&nbsp;Classes</a><ul class="auto-toc">
<li><a class="reference internal" href="#a-simple-class" id="id88">1.8.1&nbsp;&nbsp;&nbsp;A simple class</a></li>
<li><a class="reference internal" href="#defining-methods" id="id89">1.8.2&nbsp;&nbsp;&nbsp;Defining methods</a></li>
<li><a class="reference internal" href="#the-constructor" id="id90">1.8.3&nbsp;&nbsp;&nbsp;The constructor</a></li>
<li><a class="reference internal" href="#member-variables" id="id91">1.8.4&nbsp;&nbsp;&nbsp;Member variables</a></li>
<li><a class="reference internal" href="#calling-methods" id="id92">1.8.5&nbsp;&nbsp;&nbsp;Calling methods</a></li>
<li><a class="reference internal" href="#adding-inheritance" id="id93">1.8.6&nbsp;&nbsp;&nbsp;Adding inheritance</a></li>
<li><a class="reference internal" href="#class-variables" id="id94">1.8.7&nbsp;&nbsp;&nbsp;Class variables</a></li>
<li><a class="reference internal" href="#class-methods-and-static-methods" id="id95">1.8.8&nbsp;&nbsp;&nbsp;Class methods and static methods</a></li>
<li><a class="reference internal" href="#properties" id="id96">1.8.9&nbsp;&nbsp;&nbsp;Properties</a></li>
<li><a class="reference internal" href="#interfaces" id="id97">1.8.10&nbsp;&nbsp;&nbsp;Interfaces</a></li>
<li><a class="reference internal" href="#new-style-classes" id="id98">1.8.11&nbsp;&nbsp;&nbsp;New-style classes</a></li>
<li><a class="reference internal" href="#doc-strings-for-classes" id="id99">1.8.12&nbsp;&nbsp;&nbsp;Doc strings for classes</a></li>
<li><a class="reference internal" href="#private-members" id="id100">1.8.13&nbsp;&nbsp;&nbsp;Private members</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-tasks" id="id101">1.9&nbsp;&nbsp;&nbsp;Special Tasks</a><ul class="auto-toc">
<li><a class="reference internal" href="#debugging-tools" id="id102">1.9.1&nbsp;&nbsp;&nbsp;Debugging tools</a></li>
<li><a class="reference internal" href="#file-input-and-output" id="id103">1.9.2&nbsp;&nbsp;&nbsp;File input and output</a></li>
<li><a class="reference internal" href="#unit-tests" id="id104">1.9.3&nbsp;&nbsp;&nbsp;Unit tests</a><ul class="auto-toc">
<li><a class="reference internal" href="#a-simple-example" id="id105">1.9.3.1&nbsp;&nbsp;&nbsp;A simple example</a></li>
<li><a class="reference internal" href="#unit-test-suites" id="id106">1.9.3.2&nbsp;&nbsp;&nbsp;Unit test suites</a></li>
<li><a class="reference internal" href="#additional-unittest-features" id="id107">1.9.3.3&nbsp;&nbsp;&nbsp;Additional unittest features</a></li>
<li><a class="reference internal" href="#guidance-on-unit-testing" id="id108">1.9.3.4&nbsp;&nbsp;&nbsp;Guidance on Unit Testing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#doctest" id="id109">1.9.4&nbsp;&nbsp;&nbsp;doctest</a></li>
<li><a class="reference internal" href="#the-python-database-api" id="id110">1.9.5&nbsp;&nbsp;&nbsp;The Python database API</a></li>
<li><a class="reference internal" href="#installing-python-packages" id="id111">1.9.6&nbsp;&nbsp;&nbsp;Installing Python packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-python-features-and-exercises" id="id112">1.10&nbsp;&nbsp;&nbsp;More Python Features and Exercises</a></li>
</ul>
</li>
<li><a class="reference internal" href="#part-2-advanced-python" id="id113">2&nbsp;&nbsp;&nbsp;Part 2 -- Advanced Python</a><ul class="auto-toc">
<li><a class="reference internal" href="#introduction-python-201-slightly-advanced-python-topics" id="id114">2.1&nbsp;&nbsp;&nbsp;Introduction -- Python 201 -- (Slightly) Advanced Python Topics</a></li>
<li><a class="reference internal" href="#regular-expressions" id="id115">2.2&nbsp;&nbsp;&nbsp;Regular Expressions</a><ul class="auto-toc">
<li><a class="reference internal" href="#defining-regular-expressions" id="id116">2.2.1&nbsp;&nbsp;&nbsp;Defining regular expressions</a></li>
<li><a class="reference internal" href="#compiling-regular-expressions" id="id117">2.2.2&nbsp;&nbsp;&nbsp;Compiling regular expressions</a></li>
<li><a class="reference internal" href="#using-regular-expressions" id="id118">2.2.3&nbsp;&nbsp;&nbsp;Using regular expressions</a></li>
<li><a class="reference internal" href="#using-match-objects-to-extract-a-value" id="id119">2.2.4&nbsp;&nbsp;&nbsp;Using match objects to extract a value</a></li>
<li><a class="reference internal" href="#extracting-multiple-items" id="id120">2.2.5&nbsp;&nbsp;&nbsp;Extracting multiple items</a></li>
<li><a class="reference internal" href="#replacing-multiple-items" id="id121">2.2.6&nbsp;&nbsp;&nbsp;Replacing multiple items</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterator-objects" id="id122">2.3&nbsp;&nbsp;&nbsp;Iterator Objects</a><ul class="auto-toc">
<li><a class="reference internal" href="#example-a-generator-function" id="id123">2.3.1&nbsp;&nbsp;&nbsp;Example - A generator function</a></li>
<li><a class="reference internal" href="#example-a-class-containing-a-generator-method" id="id124">2.3.2&nbsp;&nbsp;&nbsp;Example - A class containing a generator method</a></li>
<li><a class="reference internal" href="#example-an-iterator-class" id="id125">2.3.3&nbsp;&nbsp;&nbsp;Example - An iterator class</a></li>
<li><a class="reference internal" href="#example-an-iterator-class-that-uses-yield" id="id126">2.3.4&nbsp;&nbsp;&nbsp;Example - An iterator class that uses yield</a></li>
<li><a class="reference internal" href="#example-a-list-comprehension" id="id127">2.3.5&nbsp;&nbsp;&nbsp;Example - A list comprehension</a></li>
<li><a class="reference internal" href="#example-a-generator-expression" id="id128">2.3.6&nbsp;&nbsp;&nbsp;Example - A generator expression</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5" id="id129">2.4&nbsp;&nbsp;&nbsp;Unit Tests</a><ul class="auto-toc">
<li><a class="reference internal" href="#defining-unit-tests" id="id130">2.4.1&nbsp;&nbsp;&nbsp;Defining unit tests</a><ul class="auto-toc">
<li><a class="reference internal" href="#create-a-test-class" id="id131">2.4.1.1&nbsp;&nbsp;&nbsp;Create a test class.</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#extending-and-embedding-python" id="id132">2.5&nbsp;&nbsp;&nbsp;Extending and embedding Python</a><ul class="auto-toc">
<li><a class="reference internal" href="#introduction-and-concepts" id="id133">2.5.1&nbsp;&nbsp;&nbsp;Introduction and concepts</a></li>
<li><a class="reference internal" href="#extension-modules" id="id134">2.5.2&nbsp;&nbsp;&nbsp;Extension modules</a></li>
<li><a class="reference internal" href="#swig" id="id135">2.5.3&nbsp;&nbsp;&nbsp;SWIG</a></li>
<li><a class="reference internal" href="#pyrex" id="id136">2.5.4&nbsp;&nbsp;&nbsp;Pyrex</a></li>
<li><a class="reference internal" href="#swig-vs-pyrex" id="id137">2.5.5&nbsp;&nbsp;&nbsp;SWIG vs. Pyrex</a></li>
<li><a class="reference internal" href="#cython" id="id138">2.5.6&nbsp;&nbsp;&nbsp;Cython</a></li>
<li><a class="reference internal" href="#extension-types" id="id139">2.5.7&nbsp;&nbsp;&nbsp;Extension types</a></li>
<li><a class="reference internal" href="#extension-classes" id="id140">2.5.8&nbsp;&nbsp;&nbsp;Extension classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parsing" id="id141">2.6&nbsp;&nbsp;&nbsp;Parsing</a><ul class="auto-toc">
<li><a class="reference internal" href="#special-purpose-parsers" id="id142">2.6.1&nbsp;&nbsp;&nbsp;Special purpose parsers</a></li>
<li><a class="reference internal" href="#writing-a-recursive-descent-parser-by-hand" id="id143">2.6.2&nbsp;&nbsp;&nbsp;Writing a recursive descent parser by hand</a></li>
<li><a class="reference internal" href="#creating-a-lexer-tokenizer-with-plex" id="id144">2.6.3&nbsp;&nbsp;&nbsp;Creating a lexer/tokenizer with Plex</a></li>
<li><a class="reference internal" href="#a-survey-of-existing-tools" id="id145">2.6.4&nbsp;&nbsp;&nbsp;A survey of existing tools</a></li>
<li><a class="reference internal" href="#creating-a-parser-with-ply" id="id146">2.6.5&nbsp;&nbsp;&nbsp;Creating a parser with PLY</a></li>
<li><a class="reference internal" href="#creating-a-parser-with-pyparsing" id="id147">2.6.6&nbsp;&nbsp;&nbsp;Creating a parser with pyparsing</a><ul class="auto-toc">
<li><a class="reference internal" href="#parsing-comma-delimited-lines" id="id148">2.6.6.1&nbsp;&nbsp;&nbsp;Parsing comma-delimited lines</a></li>
<li><a class="reference internal" href="#parsing-functors" id="id149">2.6.6.2&nbsp;&nbsp;&nbsp;Parsing functors</a></li>
<li><a class="reference internal" href="#parsing-names-phone-numbers-etc" id="id150">2.6.6.3&nbsp;&nbsp;&nbsp;Parsing names, phone numbers, etc.</a></li>
<li><a class="reference internal" href="#a-more-complex-example" id="id151">2.6.6.4&nbsp;&nbsp;&nbsp;A more complex example</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#gui-applications" id="id152">2.7&nbsp;&nbsp;&nbsp;GUI Applications</a><ul class="auto-toc">
<li><a class="reference internal" href="#introduction" id="id153">2.7.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#pygtk" id="id154">2.7.2&nbsp;&nbsp;&nbsp;PyGtk</a><ul class="auto-toc">
<li><a class="reference internal" href="#a-simple-message-dialog-box" id="id155">2.7.2.1&nbsp;&nbsp;&nbsp;A simple message dialog box</a></li>
<li><a class="reference internal" href="#a-simple-text-input-dialog-box" id="id156">2.7.2.2&nbsp;&nbsp;&nbsp;A simple text input dialog box</a></li>
<li><a class="reference internal" href="#a-file-selection-dialog-box" id="id157">2.7.2.3&nbsp;&nbsp;&nbsp;A file selection dialog box</a></li>
</ul>
</li>
<li><a class="reference internal" href="#easygui" id="id158">2.7.3&nbsp;&nbsp;&nbsp;EasyGUI</a><ul class="auto-toc">
<li><a class="reference internal" href="#a-simple-easygui-example" id="id159">2.7.3.1&nbsp;&nbsp;&nbsp;A simple EasyGUI example</a></li>
<li><a class="reference internal" href="#an-easygui-file-open-dialog-example" id="id160">2.7.3.2&nbsp;&nbsp;&nbsp;An EasyGUI file open dialog example</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#guidance-on-packages-and-modules" id="id161">2.8&nbsp;&nbsp;&nbsp;Guidance on Packages and Modules</a><ul class="auto-toc">
<li><a class="reference internal" href="#id7" id="id162">2.8.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#implementing-packages" id="id163">2.8.2&nbsp;&nbsp;&nbsp;Implementing Packages</a></li>
<li><a class="reference internal" href="#using-packages" id="id164">2.8.3&nbsp;&nbsp;&nbsp;Using Packages</a></li>
<li><a class="reference internal" href="#distributing-and-installing-packages" id="id165">2.8.4&nbsp;&nbsp;&nbsp;Distributing and Installing Packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#end-matter" id="id166">2.9&nbsp;&nbsp;&nbsp;End Matter</a><ul class="auto-toc">
<li><a class="reference internal" href="#acknowledgements-and-thanks" id="id167">2.9.1&nbsp;&nbsp;&nbsp;Acknowledgements and Thanks</a></li>
<li><a class="reference internal" href="#see-also" id="id168">2.9.2&nbsp;&nbsp;&nbsp;See Also</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#part-3-python-workbook" id="id169">3&nbsp;&nbsp;&nbsp;Part 3 -- Python Workbook</a><ul class="auto-toc">
<li><a class="reference internal" href="#id9" id="id170">3.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#lexical-structures" id="id171">3.2&nbsp;&nbsp;&nbsp;Lexical Structures</a><ul class="auto-toc">
<li><a class="reference internal" href="#variables-and-names" id="id172">3.2.1&nbsp;&nbsp;&nbsp;Variables and names</a></li>
<li><a class="reference internal" href="#line-structure" id="id173">3.2.2&nbsp;&nbsp;&nbsp;Line structure</a></li>
<li><a class="reference internal" href="#indentation-and-program-structure" id="id174">3.2.3&nbsp;&nbsp;&nbsp;Indentation and program structure</a></li>
</ul>
</li>
<li><a class="reference internal" href="#execution-model" id="id175">3.3&nbsp;&nbsp;&nbsp;Execution Model</a></li>
<li><a class="reference internal" href="#id11" id="id176">3.4&nbsp;&nbsp;&nbsp;Built-in Data Types</a><ul class="auto-toc">
<li><a class="reference internal" href="#numbers" id="id177">3.4.1&nbsp;&nbsp;&nbsp;Numbers</a><ul class="auto-toc">
<li><a class="reference internal" href="#literal-representations-of-numbers" id="id178">3.4.1.1&nbsp;&nbsp;&nbsp;Literal representations of numbers</a></li>
<li><a class="reference internal" href="#operators-for-numbers" id="id179">3.4.1.2&nbsp;&nbsp;&nbsp;Operators for numbers</a></li>
<li><a class="reference internal" href="#methods-on-numbers" id="id180">3.4.1.3&nbsp;&nbsp;&nbsp;Methods on numbers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lists" id="id181">3.4.2&nbsp;&nbsp;&nbsp;Lists</a><ul class="auto-toc">
<li><a class="reference internal" href="#literal-representation-of-lists" id="id182">3.4.2.1&nbsp;&nbsp;&nbsp;Literal representation of lists</a></li>
<li><a class="reference internal" href="#operators-on-lists" id="id183">3.4.2.2&nbsp;&nbsp;&nbsp;Operators on lists</a></li>
<li><a class="reference internal" href="#methods-on-lists" id="id184">3.4.2.3&nbsp;&nbsp;&nbsp;Methods on lists</a></li>
<li><a class="reference internal" href="#list-comprehensions" id="id185">3.4.2.4&nbsp;&nbsp;&nbsp;List comprehensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12" id="id186">3.4.3&nbsp;&nbsp;&nbsp;Strings</a><ul class="auto-toc">
<li><a class="reference internal" href="#characters" id="id187">3.4.3.1&nbsp;&nbsp;&nbsp;Characters</a></li>
<li><a class="reference internal" href="#operators-on-strings" id="id188">3.4.3.2&nbsp;&nbsp;&nbsp;Operators on strings</a></li>
<li><a class="reference internal" href="#methods-on-strings" id="id189">3.4.3.3&nbsp;&nbsp;&nbsp;Methods on strings</a></li>
<li><a class="reference internal" href="#raw-strings" id="id190">3.4.3.4&nbsp;&nbsp;&nbsp;Raw strings</a></li>
<li><a class="reference internal" href="#id13" id="id191">3.4.3.5&nbsp;&nbsp;&nbsp;Unicode strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id16" id="id192">3.4.4&nbsp;&nbsp;&nbsp;Dictionaries</a><ul class="auto-toc">
<li><a class="reference internal" href="#literal-representation-of-dictionaries" id="id193">3.4.4.1&nbsp;&nbsp;&nbsp;Literal representation of dictionaries</a></li>
<li><a class="reference internal" href="#operators-on-dictionaries" id="id194">3.4.4.2&nbsp;&nbsp;&nbsp;Operators on dictionaries</a></li>
<li><a class="reference internal" href="#methods-on-dictionaries" id="id195">3.4.4.3&nbsp;&nbsp;&nbsp;Methods on dictionaries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17" id="id196">3.4.5&nbsp;&nbsp;&nbsp;Files</a></li>
<li><a class="reference internal" href="#a-few-miscellaneous-data-types" id="id197">3.4.6&nbsp;&nbsp;&nbsp;A few miscellaneous data types</a><ul class="auto-toc">
<li><a class="reference internal" href="#none" id="id198">3.4.6.1&nbsp;&nbsp;&nbsp;None</a></li>
<li><a class="reference internal" href="#the-booleans-true-and-false" id="id199">3.4.6.2&nbsp;&nbsp;&nbsp;The booleans True and False</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id18" id="id200">3.5&nbsp;&nbsp;&nbsp;Statements</a><ul class="auto-toc">
<li><a class="reference internal" href="#id19" id="id201">3.5.1&nbsp;&nbsp;&nbsp;Assignment statement</a></li>
<li><a class="reference internal" href="#id20" id="id202">3.5.2&nbsp;&nbsp;&nbsp;print statement</a></li>
<li><a class="reference internal" href="#if-statement-exercises" id="id203">3.5.3&nbsp;&nbsp;&nbsp;if: statement exercises</a></li>
<li><a class="reference internal" href="#for-statement-exercises" id="id204">3.5.4&nbsp;&nbsp;&nbsp;for: statement exercises</a></li>
<li><a class="reference internal" href="#while-statement-exercises" id="id205">3.5.5&nbsp;&nbsp;&nbsp;while: statement exercises</a></li>
<li><a class="reference internal" href="#break-and-continue-statements" id="id206">3.5.6&nbsp;&nbsp;&nbsp;break and continue statements</a></li>
<li><a class="reference internal" href="#exceptions-and-the-try-except-and-raise-statements" id="id207">3.5.7&nbsp;&nbsp;&nbsp;Exceptions and the try:except: and raise statements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id21" id="id208">3.6&nbsp;&nbsp;&nbsp;Functions</a><ul class="auto-toc">
<li><a class="reference internal" href="#optional-arguments-and-default-values" id="id209">3.6.1&nbsp;&nbsp;&nbsp;Optional arguments and default values</a></li>
<li><a class="reference internal" href="#passing-functions-as-arguments" id="id210">3.6.2&nbsp;&nbsp;&nbsp;Passing functions as arguments</a></li>
<li><a class="reference internal" href="#extra-args-and-keyword-args" id="id211">3.6.3&nbsp;&nbsp;&nbsp;Extra args and keyword args</a><ul class="auto-toc">
<li><a class="reference internal" href="#order-of-arguments-positional-extra-and-keyword-args" id="id212">3.6.3.1&nbsp;&nbsp;&nbsp;Order of arguments (positional, extra, and keyword args)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions-and-duck-typing-and-polymorphism" id="id213">3.6.4&nbsp;&nbsp;&nbsp;Functions and duck-typing and polymorphism</a></li>
<li><a class="reference internal" href="#recursive-functions" id="id214">3.6.5&nbsp;&nbsp;&nbsp;Recursive functions</a></li>
<li><a class="reference internal" href="#generators-and-iterators" id="id215">3.6.6&nbsp;&nbsp;&nbsp;Generators and iterators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#object-oriented-programming-and-classes" id="id216">3.7&nbsp;&nbsp;&nbsp;Object-oriented programming and classes</a><ul class="auto-toc">
<li><a class="reference internal" href="#id23" id="id217">3.7.1&nbsp;&nbsp;&nbsp;The constructor</a></li>
<li><a class="reference internal" href="#inheritance-implementing-a-subclass" id="id218">3.7.2&nbsp;&nbsp;&nbsp;Inheritance -- Implementing a subclass</a></li>
<li><a class="reference internal" href="#classes-and-polymorphism" id="id219">3.7.3&nbsp;&nbsp;&nbsp;Classes and polymorphism</a></li>
<li><a class="reference internal" href="#recursive-calls-to-methods" id="id220">3.7.4&nbsp;&nbsp;&nbsp;Recursive calls to methods</a></li>
<li><a class="reference internal" href="#class-variables-class-methods-and-static-methods" id="id221">3.7.5&nbsp;&nbsp;&nbsp;Class variables, class methods, and static methods</a><ul class="auto-toc">
<li><a class="reference internal" href="#decorators-for-classmethod-and-staticmethod" id="id222">3.7.5.1&nbsp;&nbsp;&nbsp;Decorators for classmethod and staticmethod</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#additional-and-advanced-topics" id="id223">3.8&nbsp;&nbsp;&nbsp;Additional and Advanced Topics</a><ul class="auto-toc">
<li><a class="reference internal" href="#decorators-and-how-to-implement-them" id="id224">3.8.1&nbsp;&nbsp;&nbsp;Decorators and how to implement them</a><ul class="auto-toc">
<li><a class="reference internal" href="#decorators-with-arguments" id="id225">3.8.1.1&nbsp;&nbsp;&nbsp;Decorators with arguments</a></li>
<li><a class="reference internal" href="#stacked-decorators" id="id226">3.8.1.2&nbsp;&nbsp;&nbsp;Stacked decorators</a></li>
<li><a class="reference internal" href="#more-help-with-decorators" id="id227">3.8.1.3&nbsp;&nbsp;&nbsp;More help with decorators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterables" id="id228">3.8.2&nbsp;&nbsp;&nbsp;Iterables</a><ul class="auto-toc">
<li><a class="reference internal" href="#a-few-preliminaries-on-iterables" id="id229">3.8.2.1&nbsp;&nbsp;&nbsp;A few preliminaries on Iterables</a></li>
<li><a class="reference internal" href="#more-help-with-iterables" id="id230">3.8.2.2&nbsp;&nbsp;&nbsp;More help with iterables</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#applications-and-recipes" id="id231">3.9&nbsp;&nbsp;&nbsp;Applications and Recipes</a><ul class="auto-toc">
<li><a class="reference internal" href="#xml-sax-minidom-elementtree-lxml" id="id232">3.9.1&nbsp;&nbsp;&nbsp;XML -- SAX, minidom, ElementTree, Lxml</a></li>
<li><a class="reference internal" href="#relational-database-access" id="id233">3.9.2&nbsp;&nbsp;&nbsp;Relational database access</a></li>
<li><a class="reference internal" href="#csv-comma-separated-value-files" id="id234">3.9.3&nbsp;&nbsp;&nbsp;CSV -- comma separated value files</a></li>
<li><a class="reference internal" href="#yaml-and-pyyaml" id="id235">3.9.4&nbsp;&nbsp;&nbsp;YAML and PyYAML</a></li>
<li><a class="reference internal" href="#json" id="id236">3.9.5&nbsp;&nbsp;&nbsp;Json</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#part-4-generating-python-bindings-for-xml" id="id237">4&nbsp;&nbsp;&nbsp;Part 4 -- Generating Python Bindings for XML</a><ul class="auto-toc">
<li><a class="reference internal" href="#id26" id="id238">4.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#generating-the-code" id="id239">4.2&nbsp;&nbsp;&nbsp;Generating the code</a></li>
<li><a class="reference internal" href="#using-the-generated-code-to-parse-and-export-an-xml-document" id="id240">4.3&nbsp;&nbsp;&nbsp;Using the generated code to parse and export an XML document</a></li>
<li><a class="reference internal" href="#some-command-line-options-you-might-want-to-know" id="id241">4.4&nbsp;&nbsp;&nbsp;Some command line options you might want to know</a></li>
<li><a class="reference internal" href="#the-graphical-front-end" id="id242">4.5&nbsp;&nbsp;&nbsp;The graphical front-end</a></li>
<li><a class="reference internal" href="#adding-application-specific-behavior" id="id243">4.6&nbsp;&nbsp;&nbsp;Adding application-specific behavior</a><ul class="auto-toc">
<li><a class="reference internal" href="#implementing-custom-subclasses" id="id244">4.6.1&nbsp;&nbsp;&nbsp;Implementing custom subclasses</a></li>
<li><a class="reference internal" href="#using-the-generated-api-from-your-application" id="id245">4.6.2&nbsp;&nbsp;&nbsp;Using the generated &quot;API&quot; from your application</a></li>
<li><a class="reference internal" href="#a-combined-approach" id="id246">4.6.3&nbsp;&nbsp;&nbsp;A combined approach</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-situations-and-uses" id="id247">4.7&nbsp;&nbsp;&nbsp;Special situations and uses</a><ul class="auto-toc">
<li><a class="reference internal" href="#generic-type-independent-processing" id="id248">4.7.1&nbsp;&nbsp;&nbsp;Generic, type-independent processing</a><ul class="auto-toc">
<li><a class="reference internal" href="#step-1-generate-the-bindings" id="id249">4.7.1.1&nbsp;&nbsp;&nbsp;Step 1 -- generate the bindings</a></li>
<li><a class="reference internal" href="#step-2-add-application-specific-code" id="id250">4.7.1.2&nbsp;&nbsp;&nbsp;Step 2 -- add application-specific code</a></li>
<li><a class="reference internal" href="#step-3-write-a-test-driver-harness" id="id251">4.7.1.3&nbsp;&nbsp;&nbsp;Step 3 -- write a test/driver harness</a></li>
<li><a class="reference internal" href="#step-4-run-the-test-application" id="id252">4.7.1.4&nbsp;&nbsp;&nbsp;Step 4 -- run the test application</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#some-hints" id="id253">4.8&nbsp;&nbsp;&nbsp;Some hints</a><ul class="auto-toc">
<li><a class="reference internal" href="#children-defined-with-maxoccurs-greater-than-1" id="id254">4.8.1&nbsp;&nbsp;&nbsp;Children defined with maxOccurs greater than 1</a></li>
<li><a class="reference internal" href="#children-defined-with-simple-numeric-types" id="id255">4.8.2&nbsp;&nbsp;&nbsp;Children defined with simple numeric types</a></li>
<li><a class="reference internal" href="#the-type-of-an-element-s-character-content" id="id256">4.8.3&nbsp;&nbsp;&nbsp;The type of an element's character content</a></li>
<li><a class="reference internal" href="#constructors-and-their-default-values" id="id257">4.8.4&nbsp;&nbsp;&nbsp;Constructors and their default values</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>[table of contents]</p>
<hr class="docutils" />
<p><strong>Preface</strong></p>
<p>This book is a collection of materials that I've used when
conducting Python training and also materials from my Web site that
are intended for self-instruction.</p>
<p>You may prefer a machine readable copy of this book.  You can find
it in various formats here:</p>
<ul class="simple">
<li>HTML -- <a class="reference external" href="http://www.davekuhlman.org/python_book_01.html">http://www.davekuhlman.org/python_book_01.html</a></li>
<li>PDF -- <a class="reference external" href="http://www.davekuhlman.org/python_book_01.pdf">http://www.davekuhlman.org/python_book_01.pdf</a></li>
<li>ODF/OpenOffice -- <a class="reference external" href="http://www.davekuhlman.org/python_book_01.odt">http://www.davekuhlman.org/python_book_01.odt</a></li>
</ul>
<p>And, let me thank the students in my Python classes.  Their
questions and suggestions were a great help in the preparation of
these materials.</p>
<hr class="docutils" />
<div class="section" id="part-1-beginning-python">
<h1><a class="toc-backref" href="#id27">1&nbsp;&nbsp;&nbsp;Part 1 -- Beginning Python</a></h1>
<!-- vim: set ft=rst: -->
<div class="section" id="introductions-etc">
<h2><a class="toc-backref" href="#id28">1.1&nbsp;&nbsp;&nbsp;Introductions Etc</a></h2>
<p>Introductions</p>
<p>Practical matters: restrooms, breakroom, lunch and break times, etc.</p>
<p>Starting the Python interactive interpreter.  Also, IPython and Idle.</p>
<p>Running scripts</p>
<p>Editors -- Choose an editor which you can configure so that it indents
with 4 spaces, not tab characters.  For a list of editors for Python,
see: <a class="reference external" href="http://wiki.python.org/moin/PythonEditors">http://wiki.python.org/moin/PythonEditors</a>.  A few possible
editors:</p>
<ul class="simple">
<li>SciTE -- <a class="reference external" href="http://www.scintilla.org/SciTE.html">http://www.scintilla.org/SciTE.html</a>.</li>
<li>MS Windows only -- (1) TextPad -- <a class="reference external" href="http://www.textpad.com">http://www.textpad.com</a>; (2)
UltraEdit -- <a class="reference external" href="http://www.ultraedit.com/">http://www.ultraedit.com/</a>.</li>
<li>Jed -- See <a class="reference external" href="http://www.jedsoft.org/jed/">http://www.jedsoft.org/jed/</a>.</li>
<li>Emacs -- See
<a class="reference external" href="http://www.gnu.org/software/emacs/">http://www.gnu.org/software/emacs/</a>
and
<a class="reference external" href="http://www.xemacs.org/faq/xemacs-faq.html">http://www.xemacs.org/faq/xemacs-faq.html</a>.</li>
<li>jEdit -- Requires a bit of customization for Python -- See
<a class="reference external" href="http://jedit.org">http://jedit.org</a>.</li>
<li>Vim -- <a class="reference external" href="http://www.vim.org/">http://www.vim.org/</a></li>
<li>Geany -- <a class="reference external" href="http://www.geany.org/">http://www.geany.org/</a></li>
<li>And many more.</li>
</ul>
<p>Interactive interpreters:</p>
<ul class="simple">
<li><tt class="docutils literal">python</tt></li>
<li><tt class="docutils literal">ipython</tt></li>
<li>Idle</li>
</ul>
<p>IDEs -- Also see
<a class="reference external" href="http://en.wikipedia.org/wiki/List_of_integrated_development_environments_for_Python">http://en.wikipedia.org/wiki/List_of_integrated_development_environments_for_Python</a>:</p>
<ul class="simple">
<li>PyWin -- MS Windows only.  Available at:
<a class="reference external" href="http://sourceforge.net/projects/pywin32/">http://sourceforge.net/projects/pywin32/</a>.</li>
<li>WingIDE -- See <a class="reference external" href="http://wingware.com/wingide/">http://wingware.com/wingide/</a>.</li>
<li>Eclipse -- <a class="reference external" href="http://eclipse.org/">http://eclipse.org/</a>.  There is a plug-in that supports
Python.</li>
<li>Kdevelop -- Linux/KDE -- See <a class="reference external" href="http://www.kdevelop.org/">http://www.kdevelop.org/</a>.</li>
<li>Eric -- Linux KDE? -- See
<a class="reference external" href="http://eric-ide.python-projects.org/index.html">http://eric-ide.python-projects.org/index.html</a></li>
<li>Emacs and SciTE will evaluate a Python buffer within the editor.</li>
</ul>
<div class="section" id="resources">
<h3><a class="toc-backref" href="#id29">1.1.1&nbsp;&nbsp;&nbsp;Resources</a></h3>
<p>Where else to get help:</p>
<ul>
<li><p class="first">Python home page -- <a class="reference external" href="http://www.python.org">http://www.python.org</a></p>
</li>
<li><p class="first">Python standard documentation -- <a class="reference external" href="http://www.python.org/doc/">http://www.python.org/doc/</a>.</p>
<p>You will also find links to tutorials there.</p>
</li>
<li><p class="first">FAQs -- <a class="reference external" href="http://www.python.org/doc/faq/">http://www.python.org/doc/faq/</a>.</p>
</li>
<li><p class="first">The Python Wiki -- <a class="reference external" href="http://wiki.python.org/">http://wiki.python.org/</a></p>
</li>
<li><p class="first">The Python Package Index -- Lots of Python packages --
<a class="reference external" href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a></p>
</li>
<li><p class="first">Special interest groups (SIGs) -- <a class="reference external" href="http://www.python.org/sigs/">http://www.python.org/sigs/</a></p>
</li>
<li><p class="first">Other python related mailing lists and lists for specific
applications (for example, Zope, Twisted, etc).  Try:
<a class="reference external" href="http://dir.gmane.org/search.php?match=python">http://dir.gmane.org/search.php?match=python</a>.</p>
</li>
<li><p class="first"><a class="reference external" href="http://sourceforge.net">http://sourceforge.net</a> -- Lots of projects.  Search for &quot;python&quot;.</p>
</li>
<li><p class="first">USENET -- comp.lang.python.  Can also be accessed through Gmane:
<a class="reference external" href="http://dir.gmane.org/gmane.comp.python.general">http://dir.gmane.org/gmane.comp.python.general</a>.</p>
</li>
<li><p class="first">The Python tutor email list --
<a class="reference external" href="http://mail.python.org/mailman/listinfo/tutor">http://mail.python.org/mailman/listinfo/tutor</a></p>
</li>
</ul>
<p>Local documentation:</p>
<ul>
<li><p class="first">On MS Windows, the Python documentation is installed with the
standard installation.</p>
</li>
<li><p class="first">Install the standard Python documentation on your machine from
<a class="reference external" href="http://www.python.org/doc/">http://www.python.org/doc/</a>.</p>
</li>
<li><p class="first"><tt class="docutils literal">pydoc</tt>.  Example, on the command line, type: <tt class="docutils literal">pydoc re</tt>.</p>
</li>
<li><p class="first">Import a module, then view its <tt class="docutils literal">.__doc__</tt> attribute.</p>
</li>
<li><p class="first">At the interactive prompt, use <tt class="docutils literal">help(obj)</tt>.  You might need to
import it first.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; import urllib
&gt;&gt;&gt; help(urllib)
</pre>
</li>
<li><p class="first">In IPython, the question mark operator gives help.  Example:</p>
<pre class="literal-block">
In [13]: open?
Type:           builtin_function_or_method
Base Class:     &lt;type 'builtin_function_or_method'&gt;
String Form:    &lt;built-in function open&gt;
Namespace:      Python builtin
Docstring:
    open(name[, mode[, buffering]]) -&gt; file object

    Open a file using the file() type, returns a file object.
Constructor Docstring:
    x.__init__(...) initializes x; see x.__class__.__doc__ for signature
Callable:       Yes
Call def:       Calling definition not available.Call docstring:
    x.__call__(...) &lt;==&gt; x(...)
</pre>
</li>
</ul>
</div>
<div class="section" id="a-general-description-of-python">
<h3><a class="toc-backref" href="#id30">1.1.2&nbsp;&nbsp;&nbsp;A general description of Python</a></h3>
<p>Python is a high-level general purpose programming language:</p>
<ul class="simple">
<li>Because code is automatically compiled to byte code and executed,
Python is suitable for use as a scripting language, Web application
implementation language, etc.</li>
<li>Because Python can be extended in C and C++, Python can provide the
speed needed for even compute intensive tasks.</li>
<li>Because of its strong structuring constructs (nested code blocks,
functions, classes, modules, and packages) and its consistent use of
objects and object-oriented programming, Python enables us to write
clear, logical applications for small and large tasks.</li>
</ul>
<p>Important features of Python:</p>
<ul class="simple">
<li>Built-in high level data types: strings, lists, dictionaries, etc.</li>
<li>The usual control structures: if, if-else, if-elif-else, while, plus
a powerful collection iterator (for).</li>
<li>Multiple levels of organizational structure: functions, classes,
modules, and packages. These assist in organizing code. An excellent
and large example is the Python standard library.</li>
<li>Compile on the fly to byte code -- Source code is compiled to byte
code without a separate compile step. Source code modules can also
be &quot;pre-compiled&quot; to byte code files.</li>
<li>Object-oriented -- Python provides a consistent way to use
objects: everything is an object.  And, in Python it is easy to
implement new object types (called classes in object-oriented
programming).</li>
<li>Extensions in C and C++ -- Extension modules and extension types can
be written by hand. There are also tools that help with this, for
example, SWIG, sip, Pyrex.</li>
<li>Jython is a version of Python that &quot;plays well with&quot; Java.  See:
<a class="reference external" href="http://www.jython.org/Project/">The Jython Project --
http://www.jython.org/Project/</a>.</li>
</ul>
<p>Some things you will need to know:</p>
<ul>
<li><p class="first">Python uses indentation to show block structure. Indent one level to
show the beginning of a block. Out-dent one level to show the end of
a block. As an example, the following C-style code:</p>
<pre class="literal-block">
if (x)
{
    if (y)
    {
        f1()
    }
    f2()
}
</pre>
<p>in Python would be:</p>
<pre class="literal-block">
if x:
    if y:
        f1()
    f2()
</pre>
</li>
</ul>
<p>And, the convention is to use four spaces (and no hard tabs) for
each level of indentation.  Actually, it's more than a convention;
it's practically a requirement.  Following that &quot;convention&quot; will
make it so much easier to merge your Python code with code from
other sources.</p>
<p>An overview of Python:</p>
<ul>
<li><p class="first">A scripting language -- Python is suitable (1) for embedding, (2)
for writing small unstructured scripts, (3) for &quot;quick and dirty&quot;
programs.</p>
</li>
<li><p class="first"><em>Not</em> a scripting language -- (1) Python scales.  (2) Python
encourages us to write code that is clear and well-structured.</p>
</li>
<li><p class="first">Interpreted, but also compiled to byte-code.  Modules are
automatically compiled (to .pyc) when imported, but may also be
explicitly compiled.</p>
</li>
<li><p class="first">Provides an interactive command line and interpreter shell.  In
fact, there are several.</p>
</li>
<li><p class="first">Dynamic -- For example:</p>
<ul class="simple">
<li>Types are bound to values, not to variables.</li>
<li>Function and method lookup is done at runtime.</li>
<li>Values are inspect-able.</li>
<li>There is an interactive interpreter, more than one, in fact.</li>
<li>You can list the methods supported by any given object.</li>
</ul>
</li>
<li><p class="first">Strongly typed at run-time, not compile-time.  Objects (values)
have a type, but variables do not.</p>
</li>
<li><p class="first">Reasonably high level -- High level built-in data types; high level
control structures (for walking lists and iterators, for example).</p>
</li>
<li><p class="first">Object-oriented -- Almost everything is an object.  Simple object
definition.  Data hiding by agreement.  Multiple inheritance.
Interfaces by convention. Polymorphism.</p>
</li>
<li><p class="first">Highly structured -- Statements, functions, classes, modules,
and packages enable us to write large, well-structured
applications.  Why structure?  Readability, locate-ability,
modifiability.</p>
</li>
<li><p class="first">Explicitness</p>
</li>
<li><p class="first">First-class objects:</p>
<ul class="simple">
<li>Definition: Can (1) pass to function; (2) return from function;
(3) stuff into a data structure.</li>
<li>Operators can be applied to <em>values</em> (not variables).  Example:
<tt class="docutils literal"><span class="pre">f(x)[3]</span></tt></li>
</ul>
</li>
<li><p class="first">Indented block structure -- &quot;Python is pseudo-code that runs.&quot;</p>
</li>
<li><p class="first">Embedding and extending Python -- Python provides a
well-documented and supported way (1) to embed the Python
interpreter in C/C++ applications and (2) to extend Python with
modules and objects implemented in C/C++.</p>
<ul class="simple">
<li>In some cases, SWIG can generate wrappers for existing C/C++
code automatically.  See <a class="reference external" href="http://www.swig.org/">http://www.swig.org/</a></li>
<li>Cython enables us to generate C code from Python <em>and</em> to
&quot;easily&quot; create wrappers for C/C++ functions.  See
<a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/</a></li>
<li>To embed and extend Python with Java, there is Jython.  See
<a class="reference external" href="http://www.jython.org/">http://www.jython.org/</a></li>
</ul>
</li>
<li><p class="first">Automatic garbage collection. (But, there is a <tt class="docutils literal">gc</tt> module to
allow explicit control of garbage collection.)</p>
</li>
<li><p class="first">Comparison with other languages: compiled languages (e.g. C/C++);
Java; Perl, Tcl, and Ruby.  Python excells at: development speed,
execution speed, clarity and maintainability.</p>
</li>
<li><p class="first">Varieties of Python:</p>
<ul>
<li><p class="first">CPython -- Standard Python 2.x implemented in C.</p>
</li>
<li><p class="first">Jython -- Python for the Java environment --
<a class="reference external" href="http://www.jython.org/">http://www.jython.org/</a></p>
</li>
<li><p class="first">PyPy -- Python with a JIT compiler and stackless mode --
<a class="reference external" href="http://pypy.org/">http://pypy.org/</a></p>
</li>
<li><p class="first">Stackless -- Python with enhanced thread support and
microthreads etc. -- <a class="reference external" href="http://www.stackless.com/">http://www.stackless.com/</a></p>
</li>
<li><p class="first">IronPython -- Python for .NET and the CLR --
<a class="reference external" href="http://ironpython.net/">http://ironpython.net/</a></p>
</li>
<li><p class="first">Python 3 -- The new, new Python.  This is intended as a
replacement for Python 2.x. -- <a class="reference external" href="http://www.python.org/doc/">http://www.python.org/doc/</a>.
A few differences (from Python 2.x):</p>
<ul class="simple">
<li>The <tt class="docutils literal">print</tt> statement changed to the <tt class="docutils literal">print</tt> function.</li>
<li>Strings are unicode by default.</li>
<li>Classes are all &quot;new style&quot; classes.</li>
<li>Changes to syntax for catching exceptions.</li>
<li>Changes to integers -- no long integer; integer division with
automatic convert to float.</li>
<li>More pervasive use of iterables (rather than collections).</li>
<li>Etc.</li>
</ul>
<p>For a more information about differences between Python 2.x and
Python 3.x, see the description of the various fixes that can be
applied with the <tt class="docutils literal">2to3</tt> tool:
<a class="reference external" href="http://docs.python.org/3/library/2to3.html#fixers">http://docs.python.org/3/library/2to3.html#fixers</a></p>
<p>The migration tool, <tt class="docutils literal">2to3</tt>, eases the conversion of 2.x code
to 3.x.</p>
</li>
</ul>
</li>
<li><p class="first">Also see <a class="reference external" href="http://www.python.org/peps/pep-0020.html">The Zen of Python</a> --
<a class="reference external" href="http://www.python.org/peps/pep-0020.html">http://www.python.org/peps/pep-0020.html</a>.
Or, at the Python interactive prompt, type:</p>
<pre class="literal-block">
&gt;&gt;&gt; import this
</pre>
</li>
</ul>
</div>
<div class="section" id="interactive-python">
<h3><a class="toc-backref" href="#id31">1.1.3&nbsp;&nbsp;&nbsp;Interactive Python</a></h3>
<p>If you execute Python from the command line with no script (no
arguments), Python gives you an interactive prompt. This is an
excellent facility for learning Python and for trying small snippets
of code. Many of the examples that follow were developed using the
Python interactive prompt.</p>
<p>Start the Python interactive interpreter by typing <tt class="docutils literal">python</tt> with
no arguments at the command line.  For example:</p>
<pre class="literal-block">
$ python
Python 2.6.1 (r261:67515, Jan 11 2009, 15:19:23)
[GCC 4.3.2] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more
information.
&gt;&gt;&gt; print 'hello'
hello
&gt;&gt;&gt;
</pre>
<p>You may also want to consider using IDLE. IDLE is a graphical
integrated development environment for Python; it contains a Python
shell.  It is likely that Idle was installed for you when you
installed Python. You will find a script to start up IDLE in the
Tools/scripts directory of your Python distribution. IDLE requires
Tkinter.</p>
<p>In addition, there are tools that will give you a more powerful and
fancy Python interactive interpreter.  One example is IPython, which
is available at <a class="reference external" href="http://ipython.scipy.org/">http://ipython.scipy.org/</a>.</p>
</div>
</div>
<div class="section" id="lexical-matters">
<h2><a class="toc-backref" href="#id32">1.2&nbsp;&nbsp;&nbsp;Lexical matters</a></h2>
<div class="section" id="lines">
<h3><a class="toc-backref" href="#id33">1.2.1&nbsp;&nbsp;&nbsp;Lines</a></h3>
<ul class="simple">
<li>Python does what you want it to do <em>most</em> of the time so that you
only have to add extra characters <em>some</em> of the time.</li>
<li>Statement separator is a semi-colon, but is only needed when
there is more than one statement on a line.  And, writing more
than one statement on the same line is considered bad form.</li>
<li>Continuation lines -- A back-slash as last character of the line
makes the following line a continuation of the current line.  But,
note that an opening &quot;context&quot; (parenthesis, square bracket, or
curly bracket) makes the back-slash unnecessary.</li>
</ul>
</div>
<div class="section" id="comments">
<h3><a class="toc-backref" href="#id34">1.2.2&nbsp;&nbsp;&nbsp;Comments</a></h3>
<p>Everything after &quot;#&quot; on a line is ignored.  No block comments, but
doc strings are a comment in quotes at the beginning of a module,
class, method or function.  Also, editors with support for Python
often provide the ability to comment out selected blocks of code,
usually with &quot;##&quot;.</p>
</div>
<div class="section" id="names-and-tokens">
<h3><a class="toc-backref" href="#id35">1.2.3&nbsp;&nbsp;&nbsp;Names and tokens</a></h3>
<ul class="simple">
<li>Allowed characters: a-z A-Z 0-9 underscore, and must begin with a
letter or underscore.</li>
<li>Names and identifiers are case sensitive.</li>
<li>Identifiers can be of unlimited length.</li>
<li>Special names, customizing, etc. -- Usually begin and end in
double underscores.</li>
<li>Special name classes -- Single and double underscores.<ul>
<li>Single leading single underscore -- Suggests a &quot;private&quot; method
or variable name.  Not imported by &quot;from module import *&quot;.</li>
<li>Single trailing underscore -- Use it to avoid conflicts with
Python keywords.</li>
<li>Double leading underscores -- Used in a class definition to
cause name mangling (weak hiding).  But, not often used.</li>
</ul>
</li>
<li>Naming conventions -- Not rigid, but:<ul>
<li>Modules and packages -- all lower case.</li>
<li>Globals and constants -- Upper case.</li>
<li>Classes -- Bumpy caps with initial upper.</li>
<li>Methods and functions -- All lower case with words separated by
underscores.</li>
<li>Local variables -- Lower case (with underscore between words) or
bumpy caps with initial lower or your choice.</li>
<li>Good advice -- Follow the conventions used in the code on which
you are working.</li>
</ul>
</li>
<li>Names/variables in Python do not have a type.  Values have types.</li>
</ul>
</div>
<div class="section" id="blocks-and-indentation">
<h3><a class="toc-backref" href="#id36">1.2.4&nbsp;&nbsp;&nbsp;Blocks and indentation</a></h3>
<p>Python represents block structure and nested block structure with
indentation, not with begin and end brackets.</p>
<p>The empty block -- Use the <tt class="docutils literal">pass</tt> no-op statement.</p>
<p>Benefits of the use of indentation to indicate structure:</p>
<ul class="simple">
<li>Reduces the need for a coding standard.  Only need to specify that
indentation is 4 spaces and no hard tabs.</li>
<li>Reduces inconsistency.  Code from different sources follow the
same indentation style.  It has to.</li>
<li>Reduces work.  Only need to get the indentation correct, not
<em>both</em> indentation and brackets.</li>
<li>Reduces clutter.  Eliminates all the curly brackets.</li>
<li>If it looks correct, it is correct.  Indentation cannot fool
the reader.</li>
</ul>
<p>Editor considerations -- The standard is 4 spaces (no hard tabs) for
each indentation level.  You will need a text editor that helps you
respect that.</p>
</div>
<div class="section" id="doc-strings">
<h3><a class="toc-backref" href="#id37">1.2.5&nbsp;&nbsp;&nbsp;Doc strings</a></h3>
<p>Doc strings are like comments, but they are carried with executing
code.  Doc strings can be viewed with several tools, e.g. <tt class="docutils literal">help()</tt>,
<tt class="docutils literal">obj.__doc__</tt>, and, in IPython, a question mark (<tt class="docutils literal">?</tt>) after a
name will produce help.</p>
<p>A doc string is written as a quoted string that is at the top of a
module or the first lines after the header line of a function or
class.</p>
<p>We can use triple-quoting to create doc strings that span multiple
lines.</p>
<p>There are also tools that extract and format doc strings, for example:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.python.org/lib/module-pydoc.html">pydoc -- Documentation generator and online help system</a> --
<a class="reference external" href="http://docs.python.org/lib/module-pydoc.html">http://docs.python.org/lib/module-pydoc.html</a>.</li>
<li><a class="reference external" href="http://epydoc.sourceforge.net/">epydoc</a>  -- Epydoc: Automatic API Documentation Generation for
Python -- <a class="reference external" href="http://epydoc.sourceforge.net/index.html">http://epydoc.sourceforge.net/index.html</a></li>
<li>Sphinx -- Can also extract documentation from Python doc strings.
See <a class="reference external" href="http://sphinx-doc.org/index.html">http://sphinx-doc.org/index.html</a>.</li>
</ul>
<p>See the following for suggestions and more information on doc
strings: <a class="reference external" href="http://www.python.org/dev/peps/pep-0257/">Docstring conventions --
http://www.python.org/dev/peps/pep-0257/</a>.</p>
</div>
<div class="section" id="program-structure">
<h3><a class="toc-backref" href="#id38">1.2.6&nbsp;&nbsp;&nbsp;Program structure</a></h3>
<ul class="simple">
<li>Execution -- def, class, etc are executable statements that add
something to the current name-space.  Modules can be both
executable and import-able.</li>
<li>Statements, data structures, functions, classes, modules,
packages.</li>
<li>Functions</li>
<li>Classes</li>
<li>Modules correspond to files with a &quot;*.py&quot; extension.  Packages
correspond to a directory (or folder) in the file system; a
package contains a file named &quot;__init__.py&quot;.  Both modules and
packages can be imported (see section <a class="reference internal" href="#import-statement">import statement</a>).</li>
<li>Packages -- A directory containing a file named &quot;__init__.py&quot;.
Can provide additional initialization when the package or a module
in it is loaded (imported).</li>
</ul>
</div>
<div class="section" id="operators">
<h3><a class="toc-backref" href="#id39">1.2.7&nbsp;&nbsp;&nbsp;Operators</a></h3>
<ul>
<li><p class="first">See: <a class="reference external" href="http://docs.python.org/ref/operators.html">http://docs.python.org/ref/operators.html</a>.  Python defines
the following operators:</p>
<pre class="literal-block">
+       -       *       **      /       //      %
&lt;&lt;      &gt;&gt;      &amp;       |       ^       ~
&lt;       &gt;       &lt;=      &gt;=      ==      !=      &lt;&gt;
</pre>
<p>The comparison operators <tt class="docutils literal">&lt;&gt;</tt> and <tt class="docutils literal">!=</tt> are alternate spellings of
the same operator. <tt class="docutils literal">!=</tt> is the preferred spelling; <tt class="docutils literal">&lt;&gt;</tt> is
obsolescent.</p>
</li>
<li><p class="first">Logical operators:</p>
<pre class="literal-block">
and     or      is      not     in
</pre>
</li>
<li><p class="first">There are also (1) the dot operator, (2) the subscript
operator <tt class="docutils literal">[]</tt>, and the function/method call operator <tt class="docutils literal">()</tt>.</p>
</li>
<li><p class="first">For information on the precedences of operators, see the table at
<a class="reference external" href="http://docs.python.org/2/reference/expressions.html#operator-precedence">http://docs.python.org/2/reference/expressions.html#operator-precedence</a>,
which is reproduced below.</p>
</li>
<li><p class="first">For information on what the different operators <em>do</em>, the section
in the &quot;Python Language Reference&quot; titled &quot;Special method
names&quot; may be of help:
<a class="reference external" href="http://docs.python.org/2/reference/datamodel.html#special-method-names">http://docs.python.org/2/reference/datamodel.html#special-method-names</a></p>
<p>The following table summarizes the operator precedences in Python,
from lowest precedence (least binding) to highest precedence (most
binding). Operators on the same line have the same
precedence. Unless the syntax is explicitly given, operators are
binary. Operators on the same line group left to right (except for
comparisons, including tests, which all have the same precedence
and chain from left to right -- see <a class="reference external" href="http://docs.python.org/ref/comparisons.html#comparisons">section 5.9</a>
-- and
exponentiation, which groups from right to left):</p>
<pre class="literal-block">
Operator                  Description
========================  ==================
lambda                    Lambda expression
or                        Boolean OR
and                       Boolean AND
not x                     Boolean NOT
in, not in                Membership tests
is, is not                Identity tests
&lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, !=, ==  Comparisons
|                         Bitwise OR
^                         Bitwise XOR
&amp;                         Bitwise AND
&lt;&lt;, &gt;&gt;                    Shifts
+, -                      Addition and subtraction
*, /, %                   Multiplication, division, remainder
+x, -x                    Positive, negative
~x                        Bitwise not
**                        Exponentiation
x.attribute               Attribute reference
x[index]                  Subscription
x[index:index]            Slicing
f(arguments...)           Function call
(expressions...)          Binding or tuple display
[expressions...]          List display
{key:datum...}            Dictionary display
`expressions...`          String conversion
</pre>
</li>
<li><p class="first">Note that most operators result in calls to methods with special
names, for example <tt class="docutils literal">__add__</tt>, <tt class="docutils literal">__sub__</tt>, <tt class="docutils literal">__mul__</tt>, etc.
See <a class="reference external" href="http://docs.python.org/2/reference/datamodel.html#special-method-names">Special method names
http://docs.python.org/2/reference/datamodel.html#special-method-names</a></p>
<p>Later, we will see how these operators can be emulated in classes
that you define yourself, through the use of these special names.</p>
</li>
</ul>
</div>
<div class="section" id="also-see">
<h3><a class="toc-backref" href="#id40">1.2.8&nbsp;&nbsp;&nbsp;Also see</a></h3>
<p>For more on lexical matters and Python styles, see:</p>
<ul class="simple">
<li><a class="reference external" href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html">Code Like a Pythonista: Idiomatic Python</a> --
<a class="reference external" href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html">http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html</a>.</li>
<li><a class="reference external" href="http://www.python.org/dev/peps/pep-0008/">Style Guide for Python Code --
http://www.python.org/dev/peps/pep-0008/</a></li>
<li>The flake8 style checking program.  See
<a class="reference external" href="https://pypi.python.org/pypi/flake8">https://pypi.python.org/pypi/flake8</a>.  Also see the pylint code
checker: <a class="reference external" href="https://pypi.python.org/pypi/pylint">https://pypi.python.org/pypi/pylint</a>.</li>
</ul>
</div>
<div class="section" id="code-evaluation">
<h3><a class="toc-backref" href="#id41">1.2.9&nbsp;&nbsp;&nbsp;Code evaluation</a></h3>
<p>Understanding the Python execution model -- How Python evaluates and
executes your code.</p>
<p>Evaluating expressions.</p>
<p>Creating names/variables -- Binding -- The following all create names
(variables) and bind values (objects) to them: (1) assignment, (2)
function definition, (3) class definition, (4) function and method
call, (5) importing a module, ...</p>
<p>First class objects -- Almost all objects in Python are first class.
Definition: An object is first class if: (1) we can put it in a
structured object; (2) we can pass it to a function; (3) we can return
it from a function.</p>
<p>References -- Objects (or references to them) can be shared.
What does this mean?</p>
<ul class="simple">
<li>The object(s) satisfy the identity test operator <tt class="docutils literal">is</tt>.</li>
<li>The built-in function <tt class="docutils literal">id()</tt> returns the same value.</li>
<li>The consequences for mutable objects are different from those for
immutable objects.</li>
<li>Changing (updating) a mutable object referenced through one variable
or container also changes that object referenced through other
variables or containers, because <em>it is the same object</em>.</li>
<li><tt class="docutils literal">del()</tt> -- The built-in function <tt class="docutils literal">del()</tt> removes a reference,
not (necessarily) the object itself.</li>
</ul>
</div>
</div>
<div class="section" id="statements-and-inspection-preliminaries">
<h2><a class="toc-backref" href="#id42">1.3&nbsp;&nbsp;&nbsp;Statements and inspection -- preliminaries</a></h2>
<p><tt class="docutils literal">print</tt> -- Example:</p>
<pre class="literal-block">
print obj
print &quot;one&quot;, &quot;two&quot;, 'three'
</pre>
<p><tt class="docutils literal">for:</tt> -- Example:</p>
<pre class="literal-block">
stuff = ['aa', 'bb', 'cc']
for item in stuff:
    print item
</pre>
<p>Learn what the <em>type</em> of an object is -- Example:</p>
<pre class="literal-block">
type(obj)
</pre>
<p>Learn what attributes an object has and what it's capabilities are
-- Example:</p>
<pre class="literal-block">
dir(obj)
value = &quot;a message&quot;
dir(value)
</pre>
<p>Get help on a class or an object -- Example:</p>
<pre class="literal-block">
help(str)
help(&quot;&quot;)
value = &quot;abc&quot;
help(value)
help(value.upper)
</pre>
<p>In IPython (but not standard Python), you can also get help at the
interactive prompt by typing &quot;?&quot; and &quot;??&quot; after an object.
Example:</p>
<pre class="literal-block">
In [48]: a = ''
In [49]: a.upper?
Type:       builtin_function_or_method
String Form:&lt;built-in method upper of str object at 0x7f1c426e0508&gt;
Docstring:
S.upper() -&gt; string

Return a copy of the string S converted to uppercase.
</pre>
</div>
<div class="section" id="built-in-data-types">
<h2><a class="toc-backref" href="#id43">1.4&nbsp;&nbsp;&nbsp;Built-in data-types</a></h2>
<p>For information on built-in data types, see section
<a class="reference external" href="http://docs.python.org/lib/types.html">Built-in Types --
http://docs.python.org/lib/types.html</a>
in the Python standard documentation.</p>
<div class="section" id="numeric-types">
<h3><a class="toc-backref" href="#id44">1.4.1&nbsp;&nbsp;&nbsp;Numeric types</a></h3>
<p>The numeric types are:</p>
<ul class="simple">
<li>Plain integers -- Same precision as a C long, usually a 32-bit
binary number.</li>
<li>Long integers -- Define with <tt class="docutils literal">100L</tt>.  But, plain integers are
automatically promoted when needed.</li>
<li>Floats -- Implemented as a C double.  Precision depends on your
machine.  See <tt class="docutils literal">sys.float_info</tt>.</li>
<li>Complex numbers -- Define with, for example, <tt class="docutils literal">3j</tt> or
<tt class="docutils literal">complex(3.0, 2.0)</tt>.</li>
</ul>
<p>See <a class="reference external" href="http://docs.python.org/lib/typesnumeric.html">2.3.4 Numeric Types -- int, float, long, complex</a> --
<a class="reference external" href="http://docs.python.org/lib/typesnumeric.html">http://docs.python.org/lib/typesnumeric.html</a>.</p>
<p>Python does mixed arithmetic.</p>
<p>Integer division truncates.  This is changed in Python 3.  Use
<tt class="docutils literal">float(n)</tt> to force coercion to a float.  Example:</p>
<pre class="literal-block">
In [8]: a = 4
In [9]: b = 5
In [10]: a / b
Out[10]: 0               # possibly wrong?
In [11]: float(a) / b
Out[11]: 0.8
</pre>
<p>Applying the function call operator (parentheses) to a type or class
creates an instance of that type or class.</p>
<p>Scientific and heavily numeric programming -- High level Python is
not very efficient for numerical programming.  But, there are
libraries that help -- Numpy and SciPy -- See: <a class="reference external" href="http://scipy.org/">SciPy: Scientific
Tools for Python -- http://scipy.org/</a></p>
</div>
<div class="section" id="tuples-and-lists">
<h3><a class="toc-backref" href="#id45">1.4.2&nbsp;&nbsp;&nbsp;Tuples and lists</a></h3>
<p>List -- A list is a dynamic array/sequence.  It is ordered and
indexable.  A list is mutable.</p>
<p>List constructors: <tt class="docutils literal">[]</tt>, <tt class="docutils literal">list()</tt>.</p>
<p><tt class="docutils literal">range()</tt> and <tt class="docutils literal">xrange()</tt>:</p>
<ul class="simple">
<li><tt class="docutils literal">range(n)</tt> creates a list of n integers.  Optional arguments are
the starting integer and a stride.</li>
<li><tt class="docutils literal">xrange</tt> is like <tt class="docutils literal">range</tt>, except that it creates an iterator
that produces the items in the list of integers instead of the
list itself.</li>
</ul>
<p>Tuples -- A tuple is a sequence.  A tuple is immutable.</p>
<p>Tuple constructors: <tt class="docutils literal">()</tt>, but really a comma; also <tt class="docutils literal">tuple()</tt>.</p>
<p>Tuples are like lists, but are not mutable.</p>
<p>Python lists are (1) heterogeneous (2) indexable, and (3) dynamic.
For example,  we can add to a list and make it longer.</p>
<p>Notes on sequence constructors:</p>
<ul class="simple">
<li>To construct a tuple with a single element, use <tt class="docutils literal">(x,)</tt>; a
tuple with a single element requires a comma.</li>
<li>You can spread elements across multiple lines (and no need for
backslash continuation character &quot;\&quot;).</li>
<li>A comma can follow the last element.</li>
</ul>
<p>The length of a tuple or list (or other container): <tt class="docutils literal">len(mylist)</tt>.</p>
<p>Operators for lists:</p>
<ul>
<li><p class="first">Try: <tt class="docutils literal">list1 + list2</tt>, <tt class="docutils literal">list1 * n</tt>, <tt class="docutils literal">list1 += list2</tt>, etc.</p>
</li>
<li><p class="first">Comparison operators: <tt class="docutils literal">&lt;</tt>, <tt class="docutils literal">==</tt>, <tt class="docutils literal">&gt;=</tt>, etc.</p>
</li>
<li><p class="first">Test for membership with the <tt class="docutils literal">in</tt> operator.  Example:</p>
<pre class="literal-block">
In [77]: a = [11, 22, 33]
In [78]: a
Out[78]: [11, 22, 33]
In [79]: 22 in a
Out[79]: True
In [80]: 44 in a
Out[80]: False
</pre>
</li>
</ul>
<p>Subscription:</p>
<ul class="simple">
<li>Indexing into a sequence</li>
<li>Negative indexes -- Effectively, length of sequence plus (minus) index.</li>
<li>Slicing -- Example: <tt class="docutils literal">data[2:5]</tt>.  Default values: beginning and
end of list.</li>
<li>Slicing with strides -- Example: <tt class="docutils literal"><span class="pre">data[::2]</span></tt>.</li>
</ul>
<p>Operations on tuples -- No operations that change the tuple, since
tuples are immutable.  We can do iteration and subscription.  We can
do &quot;contains&quot; (the <tt class="docutils literal">in</tt> operator) and get the length (the <tt class="docutils literal">len()</tt>
operator).  We can use certain boolean operators.</p>
<p>Operations on lists -- Operations similar to tuples plus:</p>
<ul class="simple">
<li>Append -- <tt class="docutils literal">mylist.append(newitem)</tt>.</li>
<li>Insert -- <tt class="docutils literal">mylist.insert(index, newitem)</tt>.  Note on efficiency:
The <tt class="docutils literal">insert</tt> method is not as fast as the <tt class="docutils literal">append</tt> method.  If
you find that you need to do a large number of <tt class="docutils literal">mylist.insert(0,
obj)</tt> (that is, inserting at the beginning of the list) consider
using a deque instead.  See:
<a class="reference external" href="http://docs.python.org/2/library/collections.html#collections.deque">http://docs.python.org/2/library/collections.html#collections.deque</a>.
Or, use <tt class="docutils literal">append</tt> and <tt class="docutils literal">reverse</tt>.</li>
<li>Extend -- <tt class="docutils literal">mylist.extend(anotherlist)</tt>.  Also can use <tt class="docutils literal">+</tt> and
<tt class="docutils literal">+=</tt>.</li>
<li>Remove -- <tt class="docutils literal">mylist.remove(item)</tt> and <tt class="docutils literal">mylist.pop()</tt>.  Note
that <tt class="docutils literal">append()</tt> together with <tt class="docutils literal">pop()</tt> implements a stack.</li>
<li>Delete -- <tt class="docutils literal">del mylist[index]</tt>.</li>
<li>Pop -- Get last (right-most) item and remove from list --
<tt class="docutils literal">mylist.pop()</tt>.</li>
</ul>
<p>List operators -- <tt class="docutils literal">+</tt>, <tt class="docutils literal">*</tt>, etc.</p>
<p>For more operations and operators on sequences, see:
<a class="reference external" href="http://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange">http://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange</a>.</p>
<p>Exercises:</p>
<ul>
<li><p class="first">Create an empty list.  Append 4 strings to the list.  Then pop
one item off the end of the list.  Solution:</p>
<pre class="literal-block">
In [25]: a = []
In [26]: a.append('aaa')
In [27]: a.append('bbb')
In [28]: a.append('ccc')
In [29]: a.append('ddd')
In [30]: print a
['aaa', 'bbb', 'ccc', 'ddd']
In [31]: a.pop()
Out[31]: 'ddd'
</pre>
</li>
<li><p class="first">Use the <tt class="docutils literal">for</tt> statement to print the items in the list.
Solution:</p>
<pre class="literal-block">
In [32]: for item in a:
   ....:         print item
   ....:
aaa
bbb
ccc
</pre>
</li>
<li><p class="first">Use the string <tt class="docutils literal">join</tt> operation to concatenate the items in
the list.  Solution:</p>
<pre class="literal-block">
In [33]: '||'.join(a)
Out[33]: 'aaa||bbb||ccc'
</pre>
</li>
<li><p class="first">Use lists containing three (3) elements to create and show a tree:</p>
<pre class="literal-block">
In [37]: b = ['bb', None, None]
In [38]: c = ['cc', None, None]
In [39]: root = ['aa', b, c]
In [40]:
In [40]:
In [40]: def show_tree(t):
   ....:     if not t:
   ....:         return
   ....:     print t[0]
   ....:     show_tree(t[1])
   ....:     show_tree(t[2])
   ....:
   ....:
In [41]: show_tree(root)
aa
bb
cc
</pre>
<p>Note that we will learn a better way to represent tree
structures when we cover implementing classes in Python.</p>
</li>
</ul>
</div>
<div class="section" id="strings">
<h3><a class="toc-backref" href="#id46">1.4.3&nbsp;&nbsp;&nbsp;Strings</a></h3>
<p>Strings are sequences.  They are immutable.  They are indexable.
They are iterable.</p>
<p>For operations on strings, see
<a class="reference external" href="http://docs.python.org/lib/string-methods.html">http://docs.python.org/lib/string-methods.html</a> or use:</p>
<pre class="literal-block">
&gt;&gt;&gt; help(str)
</pre>
<p>Or:</p>
<pre class="literal-block">
&gt;&gt;&gt; dir(&quot;abc&quot;)
</pre>
<p>String operations (methods).</p>
<p>String operators, e.g. <tt class="docutils literal">+</tt>, <tt class="docutils literal">&lt;</tt>, <tt class="docutils literal">&lt;=</tt>, <tt class="docutils literal">==</tt>, etc..</p>
<p>Constructors/literals:</p>
<ul class="simple">
<li>Quotes:  single and double.  Escaping quotes and other special
characters with a back-slash.</li>
<li>Triple quoting -- Use triple single quotes or double quotes to
define multi-line strings.</li>
<li><tt class="docutils literal">str()</tt> -- The constructor and the name of the type/class.</li>
<li><tt class="docutils literal"><span class="pre">'aSeparator'.join(aList)</span></tt></li>
<li>Many more.</li>
</ul>
<p>Escape characters in strings -- <tt class="docutils literal">\t</tt>, <tt class="docutils literal">\n</tt>, <tt class="docutils literal">\\</tt>, etc.</p>
<p>String formatting -- See:
<a class="reference external" href="http://docs.python.org/2/library/stdtypes.html#string-formatting-operations">http://docs.python.org/2/library/stdtypes.html#string-formatting-operations</a></p>
<p>Examples:</p>
<pre class="literal-block">
In [18]: name = 'dave'
In [19]: size = 25
In [20]: factor = 3.45
In [21]: print 'Name: %s  Size: %d  Factor: %3.4f' % (name, size, factor, )
Name: dave  Size: 25  Factor: 3.4500
In [25]: print 'Name: %s  Size: %d  Factor: %08.4f' % (name, size, factor, )
Name: dave  Size: 25  Factor: 003.4500
</pre>
<p>If the right-hand argument to the formatting operator is a
dictionary, then you can (actually, must) use the names of keys in
the dictionary in your format strings.  Examples:</p>
<pre class="literal-block">
In [115]: values = {'vegetable': 'chard', 'fruit': 'nectarine'}
In [116]: 'I love %(vegetable)s and I love %(fruit)s.' % values
Out[116]: 'I love chard and I love nectarine.'
</pre>
<p>Also consider using the right justify and left justify operations.
Examples: <tt class="docutils literal">mystring.rjust(20)</tt>, <tt class="docutils literal">mystring.ljust(20, <span class="pre">':')</span></tt>.</p>
<p>In Python 3, the <tt class="docutils literal">str.format</tt> method is preferred to the string
formatting operator.  This method is also available in Python 2.7.
It has benefits and advantages over the string formatting operator.
You can start learning about it here:
<a class="reference external" href="http://docs.python.org/2/library/stdtypes.html#string-methods">http://docs.python.org/2/library/stdtypes.html#string-methods</a></p>
<p>Exercises:</p>
<ul>
<li><p class="first">Use a literal to create a string containing (1) a single quote,
(2) a double quote, (3) both a single and double quote.
Solutions:</p>
<pre class="literal-block">
&quot;Some 'quoted' text.&quot;
'Some &quot;quoted&quot; text.'
'Some &quot;quoted&quot; \'extra\' text.'
</pre>
</li>
<li><p class="first">Write a string literal that spans multiple lines.  Solution:</p>
<pre class="literal-block">
&quot;&quot;&quot;This string
spans several lines
because it is a little long.
&quot;&quot;&quot;
</pre>
</li>
<li><p class="first">Use the string <tt class="docutils literal">join</tt> operation to create a string that
contains a colon as a separator.  Solution:</p>
<pre class="literal-block">
&gt;&gt;&gt; content = []
&gt;&gt;&gt; content.append('finch')
&gt;&gt;&gt; content.append('sparrow')
&gt;&gt;&gt; content.append('thrush')
&gt;&gt;&gt; content.append('jay')
&gt;&gt;&gt; contentstr = ':'.join(content)
&gt;&gt;&gt; print contentstr
finch:sparrow:thrush:jay
</pre>
</li>
<li><p class="first">Use string formatting to produce a string containing your last
and first names, separated by a comma.  Solution:</p>
<pre class="literal-block">
&gt;&gt;&gt; first = 'Dave'
&gt;&gt;&gt; last = 'Kuhlman'
&gt;&gt;&gt; full = '%s, %s' % (last, first, )
&gt;&gt;&gt; print full
Kuhlman, Dave
</pre>
</li>
</ul>
<p>Incrementally building up large strings from lots of small strings
-- <strong>the old way</strong> -- Since strings in Python are immutable,
appending to a string requires a re-allocation.  So, it is faster to
append to a list, then use <tt class="docutils literal">join</tt>.  Example:</p>
<pre class="literal-block">
In [25]: strlist = []
In [26]: strlist.append('Line #1')
In [27]: strlist.append('Line #2')
In [28]: strlist.append('Line #3')
In [29]: str = '\n'.join(strlist)
In [30]: print str
Line #1
Line #2
Line #3
</pre>
<p>Incrementally building up large strings from lots of small strings
-- <strong>the new way</strong> -- The <tt class="docutils literal">+=</tt> operation on strings has been
optimized.  So, when you do this <tt class="docutils literal">str1 += str2</tt>, even many times,
it is efficient.</p>
<p>The <tt class="docutils literal">translate</tt> method enables us to map the characters in a
string, replacing those in one table by those in another.  And, the
<tt class="docutils literal">maketrans</tt> function in the <tt class="docutils literal">string</tt> module, makes it easy to
create the mapping table:</p>
<pre class="literal-block">
import string

def test():
    a = 'axbycz'
    t = string.maketrans('abc', '123')
    print a
    print a.translate(t)

test()
</pre>
<div class="section" id="the-new-string-format-method">
<h4><a class="toc-backref" href="#id47">1.4.3.1&nbsp;&nbsp;&nbsp;The new string.format method</a></h4>
<p>The new way to do string formatting (which is standard in Python 3
and <em>perhaps</em> preferred for new code in Python 2) is to use the
<tt class="docutils literal">string.format</tt> method.  See here:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.python.org/2/library/stdtypes.html#str.format">http://docs.python.org/2/library/stdtypes.html#str.format</a></li>
<li><a class="reference external" href="http://docs.python.org/2/library/string.html#format-string-syntax">http://docs.python.org/2/library/string.html#format-string-syntax</a></li>
<li><a class="reference external" href="http://docs.python.org/2/library/string.html#format-specification-mini-language">http://docs.python.org/2/library/string.html#format-specification-mini-language</a></li>
</ul>
<p>Some examples:</p>
<pre class="literal-block">
In [1]: 'aaa {1} bbb {0} ccc {1} ddd'.format('xx', 'yy', )
Out[1]: 'aaa yy bbb xx ccc yy ddd'
In [2]: 'number: {0:05d} ok'.format(25)
Out[2]: 'number: 00025 ok'
In [4]: 'n1: {num1}  n2: {num2}'.format(num2=25, num1=100)
Out[4]: 'n1: 100  n2: 25'
In [5]: 'n1: {num1}  n2: {num2}  again: {num1}'.format(num2=25, num1=100)
Out[5]: 'n1: 100  n2: 25  again: 100'
In [6]: 'number: {:05d} ok'.format(25)
Out[6]: 'number: 00025 ok'
In [7]: values = {'name': 'dave', 'hobby': 'birding'}
In [8]: 'user: {name}  activity: {hobby}'.format(**values)
Out[8]: 'user: dave  activity: birding'
</pre>
</div>
<div class="section" id="unicode-strings">
<h4><a class="toc-backref" href="#id48">1.4.3.2&nbsp;&nbsp;&nbsp;Unicode strings</a></h4>
<p>Representing unicode:</p>
<pre class="literal-block">
In [96]: a = u'abcd'
In [97]: a
Out[97]: u'abcd'
In [98]: b = unicode('efgh')
In [99]: b
Out[99]: u'efgh'
</pre>
<p>Convert to unicode: <tt class="docutils literal">a_string.decode(encoding)</tt>.  Examples:</p>
<pre class="literal-block">
In [102]: 'abcd'.decode('utf-8')
Out[102]: u'abcd'
In [103]:
In [104]: 'abcd'.decode(sys.getdefaultencoding())
Out[104]: u'abcd'
</pre>
<p>Convert out of unicode:  <tt class="docutils literal">a_unicode_string.encode(encoding)</tt>.
Examples:</p>
<pre class="literal-block">
In [107]: a = u'abcd'
In [108]: a.encode('utf-8')
Out[108]: 'abcd'
In [109]: a.encode(sys.getdefaultencoding())
Out[109]: 'abcd'
In [110]: b = u'Sel\xe7uk'
In [111]: print b.encode('utf-8')
Seluk
</pre>
<p>Test for unicode type -- Example:</p>
<pre class="literal-block">
In [122]: import types
In [123]: a = u'abcd'
In [124]: type(a) is types.UnicodeType
Out[124]: True
In [125]:
In [126]: type(a) is type(u'')
Out[126]: True
</pre>
<p>Or better:</p>
<pre class="literal-block">
In [127]: isinstance(a, unicode)
Out[127]: True
</pre>
<p>An example with a character &quot;c&quot; with a hachek:</p>
<pre class="literal-block">
In [135]: name = 'Ivan Krsti\xc4\x87'
In [136]: name.decode('utf-8')
Out[136]: u'Ivan Krsti\u0107'
In [137]:
In [138]: len(name)
Out[138]: 12
In [139]: len(name.decode('utf-8'))
Out[139]: 11
</pre>
<p>You can also create a unicode character by using the <tt class="docutils literal">unichr()</tt>
built-in function:</p>
<pre class="literal-block">
In [2]: a = 'aa' + unichr(170) + 'bb'
In [3]: a
Out[3]: u'aa\xaabb'
In [6]: b = a.encode('utf-8')
In [7]: b
Out[7]: 'aa\xc2\xaabb'
In [8]: print b
aabb
</pre>
<p>Guidance for use of encodings and unicode -- If you are working with
a multibyte character set:</p>
<ol class="arabic simple">
<li>Convert/decode from an external encoding to unicode <em>early</em>
(<tt class="docutils literal">my_string.decode(encoding)</tt>).</li>
<li>Do your work in unicode.</li>
<li>Convert/encode to an external encoding <em>late</em>
(<tt class="docutils literal">my_string.encode(encoding)</tt>).</li>
</ol>
<p>For more information, see:</p>
<ul class="simple">
<li><a class="reference external" href="http://farmdev.com/talks/unicode/">Unicode In Python, Completely Demystified --
http://farmdev.com/talks/unicode/</a></li>
<li><a class="reference external" href="http://www.python.org/dev/peps/pep-0100/">PEP 100: Python Unicode Integration --
http://www.python.org/dev/peps/pep-0100/</a></li>
<li>In the Python standard library:<ul>
<li><a class="reference external" href="http://docs.python.org/2/library/codecs.html#module-codecs">codecs -- Codec registry and base classes --
http://docs.python.org/2/library/codecs.html#module-codecs</a></li>
<li><a class="reference external" href="http://docs.python.org/2/library/codecs.html#standard-encodings">Standard Encodings --
http://docs.python.org/2/library/codecs.html#standard-encodings</a></li>
</ul>
</li>
</ul>
<p>If you are reading and writing multibyte character data from or to a
<em>file</em>, then look at the <tt class="docutils literal">codecs.open()</tt> in the <a class="reference external" href="http://docs.python.org/2/library/codecs.html#codecs.open">codecs module
-- http://docs.python.org/2/library/codecs.html#codecs.open</a>.</p>
<p>Handling multi-byte character sets in Python 3 is easier, I think,
but different.  One hint is to use the <tt class="docutils literal">encoding</tt> keyword
parameter to the <tt class="docutils literal">open</tt> built-in function.  Here is an example:</p>
<pre class="literal-block">
def test():
    infile = open('infile1.txt', 'r', encoding='utf-8')
    outfile = open('outfile1.txt', 'w', encoding='utf-8')
    for line in infile:
        line = line.upper()
        outfile.write(line)
    infile.close()
    outfile.close()

test()
</pre>
</div>
</div>
<div class="section" id="dictionaries">
<h3><a class="toc-backref" href="#id49">1.4.4&nbsp;&nbsp;&nbsp;Dictionaries</a></h3>
<p>A dictionary is a collection, whose values are accessible by key.  It
is a collection of name-value pairs.</p>
<p>The order of elements in a dictionary is undefined.  But, we can
iterate over (1) the keys, (2) the values, and (3) the items
(key-value pairs) in a dictionary.  We can set the value of a key and
we can get the value associated with a key.</p>
<p>Keys must be immutable objects: ints, strings, tuples, ...</p>
<p>Literals for constructing dictionaries:</p>
<pre class="literal-block">
d1 = {}
d2 = {key1: value1, key2: value2, }
</pre>
<p>Constructor for dictionaries -- <tt class="docutils literal">dict()</tt> can be used to create
instances of the class <tt class="docutils literal">dict</tt>.  Some examples:</p>
<pre class="literal-block">
dict({'one': 2, 'two': 3})
dict({'one': 2, 'two': 3}.items())
dict({'one': 2, 'two': 3}.iteritems())
dict(zip(('one', 'two'), (2, 3)))
dict([['two', 3], ['one', 2]])
dict(one=2, two=3)
dict([(['one', 'two'][i-2], i) for i in (2, 3)])
</pre>
<p>For operations on dictionaries, see
<a class="reference external" href="http://docs.python.org/lib/typesmapping.html">http://docs.python.org/lib/typesmapping.html</a> or use:</p>
<pre class="literal-block">
&gt;&gt;&gt; help({})
</pre>
<p>Or:</p>
<pre class="literal-block">
&gt;&gt;&gt; dir({})
</pre>
<p>Indexing -- Access or add items to a dictionary with the indexing
operator <tt class="docutils literal">[ ]</tt>.  Example:</p>
<pre class="literal-block">
In [102]: dict1 = {}
In [103]: dict1['name'] = 'dave'
In [104]: dict1['category'] = 38
In [105]: dict1
Out[105]: {'category': 38, 'name': 'dave'}
</pre>
<p>Some of the operations produce the keys, the values, and the items
(pairs) in a dictionary.  Examples:</p>
<pre class="literal-block">
In [43]: d = {'aa': 111, 'bb': 222}
In [44]: d.keys()
Out[44]: ['aa', 'bb']
In [45]: d.values()
Out[45]: [111, 222]
In [46]: d.items()
Out[46]: [('aa', 111), ('bb', 222)]
</pre>
<p>When iterating over large dictionaries, use methods <tt class="docutils literal">iterkeys()</tt>,
<tt class="docutils literal">itervalues()</tt>, and <tt class="docutils literal">iteritems()</tt>.  Example:</p>
<pre class="literal-block">
In [47]:
In [47]: d = {'aa': 111, 'bb': 222}
In [48]: for key in d.iterkeys():
   ....:     print key
   ....:
   ....:
aa
bb
</pre>
<p>To test for the existence of a key in a dictionary, use the <tt class="docutils literal">in</tt>
operator or the <tt class="docutils literal">mydict.has_key(k)</tt> method.  The <tt class="docutils literal">in</tt> operator
is preferred.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = {'tomato': 101, 'cucumber': 102}
&gt;&gt;&gt; k = 'tomato'
&gt;&gt;&gt; k in d
True
&gt;&gt;&gt; d.has_key(k)
True
</pre>
<p>You can often avoid the need for a test by using method <tt class="docutils literal">get</tt>.
Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = {'tomato': 101, 'cucumber': 102}
&gt;&gt;&gt; d.get('tomato', -1)
101
&gt;&gt;&gt; d.get('chard', -1)
-1
&gt;&gt;&gt; if d.get('eggplant') is None:
...     print 'missing'
...
missing
</pre>
<p>Dictionary &quot;view&quot; objects provide dynamic (automatically updated)
views of the keys or the values or the items in a dictionary.  View
objects also support set operations.  Create views with
<tt class="docutils literal">mydict.viewkeys()</tt>, <tt class="docutils literal">mydict.viewvalues()</tt>, and
<tt class="docutils literal">mydict.viewitems()</tt>.  See:
<a class="reference external" href="http://docs.python.org/2/library/stdtypes.html#dictionary-view-objects">http://docs.python.org/2/library/stdtypes.html#dictionary-view-objects</a>.</p>
<p>The dictionary <tt class="docutils literal">setdefault</tt> method provides a way to get the value
associated with a key from a dictionary and to set that value if the
key is missing.  Example:</p>
<pre class="literal-block">
In [106]: a
Out[106]: {}
In [108]: a.setdefault('cc', 33)
Out[108]: 33
In [109]: a
Out[109]: {'cc': 33}
In [110]: a.setdefault('cc', 44)
Out[110]: 33
In [111]: a
Out[111]: {'cc': 33}
</pre>
<p>Exercises:</p>
<ul>
<li><p class="first">Write a literal that defines a dictionary using both string
literals and variables containing strings.  Solution:</p>
<pre class="literal-block">
&gt;&gt;&gt; first = 'Dave'
&gt;&gt;&gt; last = 'Kuhlman'
&gt;&gt;&gt; name_dict = {first: last, 'Elvis': 'Presley'}
&gt;&gt;&gt; print name_dict
{'Dave': 'Kuhlman', 'Elvis': 'Presley'}
</pre>
</li>
<li><p class="first">Write statements that iterate over (1) the keys, (2) the values,
and (3) the items in a dictionary.  (Note: Requires introduction
of the <tt class="docutils literal">for</tt> statement.)  Solutions:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = {'aa': 111, 'bb': 222, 'cc': 333}
&gt;&gt;&gt; for key in d.keys():
...   print key
...
aa
cc
bb
&gt;&gt;&gt; for value in d.values():
...   print value
...
111
333
222
&gt;&gt;&gt; for item in d.items():
...   print item
...
('aa', 111)
('cc', 333)
('bb', 222)
&gt;&gt;&gt; for key, value in d.items():
...   print key, '::', value
...
aa :: 111
cc :: 333
bb :: 222
</pre>
</li>
</ul>
<p>Additional notes on dictionaries:</p>
<ul>
<li><p class="first">You can use <tt class="docutils literal">iterkeys()</tt>, <tt class="docutils literal">itervalues()</tt>, <tt class="docutils literal">iteritems()</tt> to
obtain iterators over keys, values, and items.</p>
</li>
<li><p class="first">A dictionary itself is iterable: it iterates over its keys.  So,
the following two lines are equivalent:</p>
<pre class="literal-block">
for k in myDict: print k
for k in myDict.iterkeys(): print k
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">in</tt> operator tests for a key in a dictionary.  Example:</p>
<pre class="literal-block">
In [52]: mydict = {'peach': 'sweet', 'lemon': 'tangy'}
In [53]: key = 'peach'
In [54]: if key in mydict:
   ....:     print mydict[key]
   ....:
sweet
</pre>
</li>
</ul>
</div>
<div class="section" id="files">
<h3><a class="toc-backref" href="#id50">1.4.5&nbsp;&nbsp;&nbsp;Files</a></h3>
<p>Open a file with the <tt class="docutils literal">open</tt> factory method.  Example:</p>
<pre class="literal-block">
In [28]: f = open('mylog.txt', 'w')
In [29]: f.write('message #1\n')
In [30]: f.write('message #2\n')
In [31]: f.write('message #3\n')
In [32]: f.close()
In [33]: f = file('mylog.txt', 'r')
In [34]: for line in f:
   ....:     print line,
   ....:
message #1
message #2
message #3
In [35]: f.close()
</pre>
<p>Notes:</p>
<ul>
<li><p class="first">Use the (built-in) <tt class="docutils literal">open(path, mode)</tt> function to open a file and
create a file object.  You could also use <tt class="docutils literal">file()</tt>, but <tt class="docutils literal">open()</tt>
is recommended.</p>
</li>
<li><p class="first">A file object that is open for reading a text file supports the
iterator protocol and, therefore, can be used in a <tt class="docutils literal">for</tt>
statement.  It iterates over the <em>lines</em> in the file.  This is
most likely only useful for text files.</p>
</li>
<li><p class="first"><tt class="docutils literal">open</tt> is a factory method that creates file objects.  Use it to
open files for reading, writing, and appending.  Examples:</p>
<pre class="literal-block">
infile = open('myfile.txt', 'r')    # open for reading
outfile = open('myfile.txt', 'w')   # open for (over-) writing
log = open('myfile.txt', 'a')       # open for appending to existing content
</pre>
</li>
<li><p class="first">When you have finished with a file, close it.  Examples:</p>
<pre class="literal-block">
infile.close()
outfile.close()
</pre>
</li>
<li><p class="first">You can also use the <tt class="docutils literal">with:</tt> statement to automatically close
the file.  Example:</p>
<pre class="literal-block">
with open('tmp01.txt', 'r') as infile:
    for x in infile:
        print x,
</pre>
<p>The above works because a file is a context manager: it obeys the
context manager protocol.  A file has methods <tt class="docutils literal">__enter__</tt> and
<tt class="docutils literal">__exit__</tt>, and the <tt class="docutils literal">__exit__</tt> method automatically closes the
file for us.  See the section on the <a class="reference internal" href="#with-statement">with: statement</a>.</p>
</li>
<li><p class="first">In order to open multiple files, you can nest <tt class="docutils literal">with:</tt>
statements, or use a single <tt class="docutils literal">with:</tt> statement with multiple
&quot;expression as target&quot; clauses.  Example:</p>
<pre class="literal-block">
def test():
    #
    # use multiple nested with: statements.
    with open('small_file.txt', 'r') as infile:
        with open('tmp_outfile.txt', 'w') as outfile:
            for line in infile:
                outfile.write('line: %s' % line.upper())
    print infile
    print outfile
    #
    # use a single with: statement.
    with open('small_file.txt', 'r') as infile, \
            open('tmp_outfile.txt', 'w') as outfile:
        for line in infile:
            outfile.write('line: %s' % line.upper())
    print infile
    print outfile

test()
</pre>
</li>
<li><p class="first"><tt class="docutils literal">file</tt> is the file type and can be used as a constructor to create
file objects.  <em>But</em>, <tt class="docutils literal">open</tt> is preferred.</p>
</li>
<li><p class="first">Lines read from a text file have a newline.  Strip it off with
something like: <tt class="docutils literal"><span class="pre">line.rstrip('\n')</span></tt>.</p>
</li>
<li><p class="first">For binary files you should add the binary mode, for example:
<tt class="docutils literal">rb</tt>, <tt class="docutils literal">wb</tt>.  For more about modes, see the description of the
<tt class="docutils literal">open()</tt> function at <a class="reference external" href="http://docs.python.org/lib/built-in-funcs.html">Built-in Functions</a> --
<a class="reference external" href="http://docs.python.org/lib/built-in-funcs.html">http://docs.python.org/lib/built-in-funcs.html</a>.</p>
</li>
<li><p class="first">Learn more about file objects and the methods they provide at:
<a class="reference external" href="http://docs.python.org/2/library/stdtypes.html#file-objects">2.3.9 File Objects --
http://docs.python.org/2/library/stdtypes.html#file-objects</a>.</p>
</li>
</ul>
<p>You can also append to an existing file.  Note the &quot;a&quot; mode in the
following example:</p>
<pre class="literal-block">
In [39]: f = open('mylog.txt', 'a')
In [40]: f.write('message #4\n')
In [41]: f.close()
In [42]: f = file('mylog.txt', 'r')
In [43]: for line in f:
   ....:     print line,
   ....:
message #1
message #2
message #3
message #4
In [44]: f.close()
</pre>
<p>For binary files, add &quot;b&quot; to the mode.  Not strictly necessary on
UNIX, but needed on MS Windows.  And, you will want to make your
code portable across platforms.  Example:</p>
<pre class="literal-block">
In [62]: import zipfile
In [63]: outfile = open('tmp1.zip', 'wb')
In [64]: zfile = zipfile.ZipFile(outfile, 'w', zipfile.ZIP_DEFLATED)
In [65]: zfile.writestr('entry1', 'my heroes have always been cowboys')
In [66]: zfile.writestr('entry2', 'and they still are it seems')
In [67]: zfile.writestr('entry3', 'sadly in search of and')
In [68]: zfile.writestr('entry4', 'on step in back of')
In [69]:
In [70]: zfile.writestr('entry4', 'one step in back of')
In [71]: zfile.writestr('entry5', 'themselves and their slow moving ways')
In [72]: zfile.close()
In [73]: outfile.close()
In [75]:
$
$ unzip -lv tmp1.zip
Archive:  tmp1.zip
 Length   Method    Size  Ratio   Date   Time   CRC-32    Name
--------  ------  ------- -----   ----   ----   ------    ----
      34  Defl:N       36  -6%  05-29-08 17:04  f6b7d921  entry1
      27  Defl:N       29  -7%  05-29-08 17:07  10da8f3d  entry2
      22  Defl:N       24  -9%  05-29-08 17:07  3fd17fda  entry3
      18  Defl:N       20 -11%  05-29-08 17:08  d55182e6  entry4
      19  Defl:N       21 -11%  05-29-08 17:08  1a892acd  entry4
      37  Defl:N       39  -5%  05-29-08 17:09  e213708c  entry5
--------          -------  ---                            -------
     157              169  -8%                            6 files
</pre>
<p>Exercises:</p>
<ul>
<li><p class="first">Read all of the lines of a file into a list.  Print the 3rd and
5th lines in the file/list.  Solution:</p>
<pre class="literal-block">
In [55]: f = open('tmp1.txt', 'r')
In [56]: lines = f.readlines()
In [57]: f.close()
In [58]: lines
Out[58]: ['the\n', 'big\n', 'brown\n', 'dog\n', 'had\n', 'long\n', 'hair\n']
In [59]: print lines[2]
brown

In [61]: print lines[4]
had
</pre>
</li>
</ul>
<p>More notes:</p>
<ul class="simple">
<li>Strip newlines (and other whitespace) from a string with methods
<tt class="docutils literal">strip()</tt>, <tt class="docutils literal">lstrip()</tt>, and <tt class="docutils literal">rstrip()</tt>.</li>
<li>Get the current position within a file by using <tt class="docutils literal">myfile.tell()</tt>.</li>
<li>Set the current position within a file by using <tt class="docutils literal">myfile.seek()</tt>.
It may be helpful to use <tt class="docutils literal">os.SEEK_CUR</tt> and <tt class="docutils literal">os.SEEK_END</tt>.  For
example:<ul>
<li><tt class="docutils literal">f.seek(2, os.SEEK_CUR)</tt> advances the position by two</li>
<li><tt class="docutils literal"><span class="pre">f.seek(-3,</span> os.SEEK_END)</tt> sets the position to the third to last.</li>
<li><tt class="docutils literal">f.seek(25)</tt> sets the position relative to the beginning of the file.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="other-built-in-types">
<h3><a class="toc-backref" href="#id51">1.4.6&nbsp;&nbsp;&nbsp;Other built-in types</a></h3>
<p>Other built-in data types are described in section
<a class="reference external" href="http://docs.python.org/lib/types.html">Built-in Types --
http://docs.python.org/lib/types.html</a>
in the Python standard documentation.</p>
<div class="section" id="the-none-value-type">
<h4><a class="toc-backref" href="#id52">1.4.6.1&nbsp;&nbsp;&nbsp;The None value/type</a></h4>
<p>The unique value <tt class="docutils literal">None</tt> is used to indicate &quot;no value&quot;, &quot;nothing&quot;,
&quot;non-existence&quot;, etc.  There is only one <tt class="docutils literal">None</tt> value; in other
words, it's a singleton.</p>
<p>Use <tt class="docutils literal">is</tt> to test for <tt class="docutils literal">None</tt>.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; flag = None
&gt;&gt;&gt;
&gt;&gt;&gt; if flag is None:
...     print 'clear'
...
clear
&gt;&gt;&gt; if flag is not None:
...     print 'hello'
...
&gt;&gt;&gt;
</pre>
</div>
<div class="section" id="boolean-values">
<h4><a class="toc-backref" href="#id53">1.4.6.2&nbsp;&nbsp;&nbsp;Boolean values</a></h4>
<p><tt class="docutils literal">True</tt> and <tt class="docutils literal">False</tt> are the boolean values.</p>
<p>The following values also count as false, for example, in an <tt class="docutils literal">if:</tt>
statement: <tt class="docutils literal">False</tt>, numeric zero, <tt class="docutils literal">None</tt>, the empty string, an
empty list, an empty dictionary, any empty container, etc.  All
other values, including <tt class="docutils literal">True</tt>, act as true values.</p>
</div>
<div class="section" id="sets-and-frozensets">
<h4><a class="toc-backref" href="#id54">1.4.6.3&nbsp;&nbsp;&nbsp;Sets and frozensets</a></h4>
<p>A set is an unordered collection of immutable objects.  A set does not
contain duplicates.</p>
<p>Sets support several set operations, for example: union, intersection,
difference, ...</p>
<p>A frozenset is like a set, except that a frozenset is immutable.
Therefore, a frozenset is hash-able and can be used as a key in a
dictionary, and it can be added to a set.</p>
<p>Create a set with the set constructor.  Examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = set()
&gt;&gt;&gt; a
set([])
&gt;&gt;&gt; a.add('aa')
&gt;&gt;&gt; a.add('bb')
&gt;&gt;&gt; a
set(['aa', 'bb'])
&gt;&gt;&gt; b = set([11, 22])
&gt;&gt;&gt; b
set([11, 22])
&gt;&gt;&gt; c = set([22, 33])
&gt;&gt;&gt; b.union(c)
set([33, 11, 22])
&gt;&gt;&gt; b.intersection(c)
set([22])
</pre>
<p>For more information on sets, see:
<a class="reference external" href="http://docs.python.org/lib/types-set.html">Set Types -- set, frozenset --
http://docs.python.org/lib/types-set.html</a></p>
</div>
</div>
</div>
<div class="section" id="functions-and-classes-a-preview">
<h2><a class="toc-backref" href="#id55">1.5&nbsp;&nbsp;&nbsp;Functions and Classes -- A Preview</a></h2>
<p>Structured code -- Python programs are made up of expressions,
statements, functions, classes, modules, and packages.</p>
<p>Python objects are first-class objects.</p>
<p>Expressions are evaluated.</p>
<p>Statements are executed.</p>
<p>Functions (1) are objects and (2) are callable.</p>
<p>Object-oriented programming in Python.  Modeling &quot;real world&quot;
objects. (1) Encapsulation; (2) data hiding; (3) inheritance.
Polymorphism.</p>
<p>Classes -- (1) encapsulation; (2) data hiding; (3) inheritance.</p>
<p>An overview of the structure of a typical class: (1) methods; (2) the
constructor; (3) class (static) variables; (4) super/subclasses.</p>
</div>
<div class="section" id="statements">
<h2><a class="toc-backref" href="#id56">1.6&nbsp;&nbsp;&nbsp;Statements</a></h2>
<div class="section" id="assignment-statement">
<h3><a class="toc-backref" href="#id57">1.6.1&nbsp;&nbsp;&nbsp;Assignment statement</a></h3>
<p>Form -- <tt class="docutils literal">target = expression</tt>.</p>
<p>Possible targets:</p>
<ul>
<li><p class="first">Identifier</p>
</li>
<li><p class="first">Tuple or list -- Can be nested.  Left and right sides must have
equivalent structure.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; x, y, z = 11, 22, 33
&gt;&gt;&gt; [x, y, z] = 111, 222, 333
&gt;&gt;&gt; a, (b, c) = 11, (22, 33)
&gt;&gt;&gt; a, B = 11, (22, 33)
</pre>
<p>This feature can be used to simulate an enum:</p>
<pre class="literal-block">
In [22]: LITTLE, MEDIUM, LARGE = range(1, 4)
In [23]: LITTLE
Out[23]: 1
In [24]: MEDIUM
Out[24]: 2
</pre>
</li>
<li><p class="first">Subscription of a sequence, dictionary, etc.  Example:</p>
<pre class="literal-block">
In [10]: a = range(10)
In [11]: a
Out[11]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
In [12]: a[3] = 'abc'
In [13]: a
Out[13]: [0, 1, 2, 'abc', 4, 5, 6, 7, 8, 9]
In [14]:
In [14]: b = {'aa': 11, 'bb': 22}
In [15]: b
Out[15]: {'aa': 11, 'bb': 22}
In [16]: b['bb'] = 1000
In [17]: b['cc'] = 2000
In [18]: b
Out[18]: {'aa': 11, 'bb': 1000, 'cc': 2000}
</pre>
</li>
<li><p class="first">A slice of a sequence -- Note that the sequence must be mutable.
Example:</p>
<pre class="literal-block">
In [1]: a = range(10)
In [2]: a
Out[2]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
In [3]: a[2:5] = [11, 22, 33, 44, 55, 66]
In [4]: a
Out[4]: [0, 1, 11, 22, 33, 44, 55, 66, 5, 6, 7, 8, 9]
</pre>
</li>
<li><p class="first">Attribute reference -- Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; class MyClass:
...     pass
...
&gt;&gt;&gt; anObj = MyClass()
&gt;&gt;&gt; anObj.desc = 'pretty'
&gt;&gt;&gt; print anObj.desc
pretty
</pre>
</li>
</ul>
<p>There is also augmented assignment.  Examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; index = 0
&gt;&gt;&gt; index += 1
&gt;&gt;&gt; index += 5
&gt;&gt;&gt; index += f(x)
&gt;&gt;&gt; index -= 1
&gt;&gt;&gt; index *= 3
</pre>
<p>Things to note:</p>
<ul>
<li><p class="first">Assignment to a name creates a new variable (if it does not exist in
the namespace) and a binding.  Specifically, it binds a value to the
new name.  Calling a function also does this to the (formal)
parameters within the local namespace.</p>
</li>
<li><p class="first">In Python, a language with dynamic typing, the data type is
associated with the value, not the variable, as is the case in
statically typed languages.</p>
</li>
<li><p class="first">Assignment can also cause sharing of an object.  Example:</p>
<pre class="literal-block">
obj1 = A()
obj2 = obj1
</pre>
<p>Check to determine that the same object is shared with
<tt class="docutils literal">id(obj)</tt> or the <tt class="docutils literal">is</tt> operator.  Example:</p>
<pre class="literal-block">
In [23]: a = range(10)
In [24]: a
Out[24]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
In [25]: b = a
In [26]: b
Out[26]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
In [27]: b[3] = 333
In [28]: b
Out[28]: [0, 1, 2, 333, 4, 5, 6, 7, 8, 9]
In [29]: a
Out[29]: [0, 1, 2, 333, 4, 5, 6, 7, 8, 9]
In [30]: a is b
Out[30]: True
In [31]: print id(a), id(b)
31037920 31037920
</pre>
</li>
<li><p class="first">You can also do multiple assignment in a single statement.
Example:</p>
<pre class="literal-block">
In [32]: a = b = 123
In [33]: a
Out[33]: 123
In [34]: b
Out[34]: 123
In [35]:
In [35]:
In [35]: a = b = [11, 22]
In [36]: a is b
Out[36]: True
</pre>
</li>
<li><p class="first">You can interchange (swap) the value of two variables using
assignment and packing/unpacking:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = 111
&gt;&gt;&gt; b = 222
&gt;&gt;&gt; a, b = b, a
&gt;&gt;&gt; a
222
&gt;&gt;&gt; b
111
</pre>
</li>
</ul>
</div>
<div class="section" id="import-statement">
<h3><a class="toc-backref" href="#id58">1.6.2&nbsp;&nbsp;&nbsp;import statement</a></h3>
<p>Make module (or objects in the module) available.</p>
<p>What <tt class="docutils literal">import</tt> does:</p>
<ul>
<li><p class="first">Evaluate the content of a module.</p>
</li>
<li><p class="first">Likely to create variables in the local (module) namespace.</p>
</li>
<li><p class="first">Evaluation of a specific module only happens once during a given run
of the program.  Therefore, a module is shared across an
application.</p>
</li>
<li><p class="first">A module is evaluated from top to bottom.  Later statements can
replace values created earlier.  This is true of functions and
classes, as well as (other) variables.</p>
</li>
<li><p class="first">Which statements are evaluated?  Assignment, <tt class="docutils literal">class</tt>, <tt class="docutils literal">def</tt>,
...</p>
</li>
<li><p class="first">Use the following idiom to make a module both run-able and
import-able:</p>
<pre class="literal-block">
if __name__ == '__main__':
    # import pdb; pdb.set_trace()
    main()        # or &quot;test()&quot; or some other function defined in module
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The above condition will be true <em>only when</em> the module is run
as a script and will <em>not</em> be true when the module is imported.</li>
<li>The line containing <tt class="docutils literal">pdb</tt> can be copied any place in your
program and un-commented, and then the program will drop into
the Python debugger when that location is reached.</li>
</ul>
</li>
</ul>
<p>Where <tt class="docutils literal">import</tt> looks for modules:</p>
<ul>
<li><p class="first"><tt class="docutils literal">sys.path</tt> shows where it looks.</p>
</li>
<li><p class="first">There are some standard places.</p>
</li>
<li><p class="first">Add additional directories by setting the environment variable
<tt class="docutils literal">PYTHONPATH</tt>.</p>
</li>
<li><p class="first">You can also add paths by modifying <tt class="docutils literal">sys.path</tt>, for example:</p>
<pre class="literal-block">
import sys
sys.path.insert(0, '/path/to/my/module')
</pre>
</li>
<li><p class="first">Packages need a file named <tt class="docutils literal">__init__.py</tt>.</p>
</li>
<li><p class="first">Extensions -- To determine what extensions import looks for,
do:</p>
<pre class="literal-block">
&gt;&gt;&gt; import imp
&gt;&gt;&gt; imp.get_suffixes()
[('.so', 'rb', 3), ('module.so', 'rb', 3), ('.py', 'U', 1), ('.pyc', 'rb', 2)]
</pre>
</li>
</ul>
<p>Forms of the <tt class="docutils literal">import</tt> statement:</p>
<ul class="simple">
<li><tt class="docutils literal">import A</tt> -- Names in the local (module) namespace are
accessible with the dot operator.</li>
<li><tt class="docutils literal">import A as B</tt> -- Import the module A, but bind the module
object to the variable B.</li>
<li><tt class="docutils literal">import A1, A2</tt> -- Not recommended</li>
<li><tt class="docutils literal">from A import B</tt></li>
<li><tt class="docutils literal">from A import B1, B2</tt></li>
<li><tt class="docutils literal">from A import B as C</tt></li>
<li><tt class="docutils literal">from A import *</tt> -- Not recommended: clutters and mixes
name-spaces.</li>
<li><tt class="docutils literal">from A.B import C</tt> -- (1) Possibly import object <tt class="docutils literal">C</tt> from module <tt class="docutils literal">B</tt>
in package <tt class="docutils literal">A</tt> or (2) possibly import module <tt class="docutils literal">C</tt> from
sub-package <tt class="docutils literal">B</tt> in package <tt class="docutils literal">A</tt>.</li>
<li><tt class="docutils literal">import A.B.C</tt> -- To reference attributes in <tt class="docutils literal">C</tt>, must use
fully-qualified name, for example use <tt class="docutils literal">A.B.C.D</tt> to reference <tt class="docutils literal">D</tt>
inside of <tt class="docutils literal">C</tt>.</li>
</ul>
<p>More notes on the <tt class="docutils literal">import</tt> statement:</p>
<ul>
<li><p class="first">The import statement and packages -- A file named <tt class="docutils literal">__init__.py</tt> is
required in a package.  This file is evaluated the first time either
the package is imported or a file in the package is imported.
Question: What is made available when you do <tt class="docutils literal">import aPackage</tt>?
Answer: All variables (names) that are global inside the
<tt class="docutils literal">__init__.py</tt> module in that package.  But, see notes on the use
of <tt class="docutils literal">__all__</tt>: <a class="reference external" href="http://docs.python.org/ref/import.html">The import statement --
http://docs.python.org/ref/import.html</a></p>
</li>
<li><p class="first">The use of <tt class="docutils literal">if __name__ == &quot;__main__&quot;:</tt> -- Makes a module both
import-able and executable.</p>
</li>
<li><p class="first">Using dots in the import statement -- From the Python language
reference manual:</p>
<blockquote>
<p>&quot;Hierarchical module names:when the module names contains one or
more dots, the module search path is carried out differently. The
sequence of identifiers up to the last dot is used to find a
<tt class="docutils literal">package</tt>; the final identifier is then searched inside the
package. A package is generally a subdirectory of a directory on
sys.path that has a file __init__.py.&quot;</p>
</blockquote>
<p>See: <a class="reference external" href="http://docs.python.org/ref/import.html">The import statement --
http://docs.python.org/ref/import.html</a></p>
</li>
</ul>
<p>Exercises:</p>
<ul>
<li><p class="first">Import a module from the standard library, for example <tt class="docutils literal">re</tt>.</p>
</li>
<li><p class="first">Import an element from a module from the standard library, for
example import <tt class="docutils literal">compile</tt> from the <tt class="docutils literal">re</tt> module.</p>
</li>
<li><p class="first">Create a simple Python package with a single module in it.
Solution:</p>
<ol class="arabic">
<li><p class="first">Create a directory named <tt class="docutils literal">simplepackage</tt> in the current
directory.</p>
</li>
<li><p class="first">Create an (empty) <tt class="docutils literal">__init__.py</tt> in the new directory.</p>
</li>
<li><p class="first">Create an <tt class="docutils literal">simple.py</tt> in the new directory.</p>
</li>
<li><p class="first">Add a simple function name <tt class="docutils literal">test1</tt> in <tt class="docutils literal">simple.py</tt>.</p>
</li>
<li><p class="first">Import using any of the following:</p>
<pre class="literal-block">
&gt;&gt;&gt; import simplepackage.simple
&gt;&gt;&gt; from simplepackage import simple
&gt;&gt;&gt; from simplepackage.simple import test1
&gt;&gt;&gt; from simplepackage.simple import test1 as mytest
</pre>
</li>
</ol>
</li>
</ul>
</div>
<div class="section" id="print-statement">
<h3><a class="toc-backref" href="#id59">1.6.3&nbsp;&nbsp;&nbsp;print statement</a></h3>
<p><tt class="docutils literal">print</tt> sends output to <tt class="docutils literal">sys.stdout</tt>.  It adds a newline, unless
an extra comma is added.</p>
<p>Arguments to <tt class="docutils literal">print</tt>:</p>
<ul class="simple">
<li>Multiple items -- Separated by commas.</li>
<li>End with comma to suppress carriage return.</li>
<li>Use string formatting for more control over output.</li>
<li>Also see various &quot;pretty-printing&quot; functions and methods, in
particular, <tt class="docutils literal">pprint</tt>.  See
<a class="reference external" href="http://docs.python.org/lib/module-pprint.html">3.27 pprint -- Data pretty printer</a> --
<a class="reference external" href="http://docs.python.org/lib/module-pprint.html">http://docs.python.org/lib/module-pprint.html</a>.</li>
</ul>
<p>String formatting -- Arguments are a tuple.  Reference:
<a class="reference external" href="http://docs.python.org/lib/typesseq-strings.html">2.3.6.2 String Formatting Operations</a> --
<a class="reference external" href="http://docs.python.org/lib/typesseq-strings.html">http://docs.python.org/lib/typesseq-strings.html</a>.</p>
<p>Can also use <tt class="docutils literal">sys.stdout</tt>.  Note that a carriage return is <em>not</em>
automatically added.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.stdout.write('hello\n')
</pre>
<p>Controlling the destination and format of print -- Replace
<tt class="docutils literal">sys.stdout</tt> with an instance of any class that implements the
method <tt class="docutils literal">write</tt> taking one parameter.  Example:</p>
<pre class="literal-block">
import sys

class Writer:
    def __init__(self, file_name):
        self.out_file = file(file_name, 'a')
    def write(self, msg):
        self.out_file.write('[[%s]]' % msg)
    def close(self):
        self.out_file.close()

def test():
    writer = Writer('outputfile.txt')
    save_stdout = sys.stdout
    sys.stdout = writer
    print 'hello'
    print 'goodbye'
    writer.close()
    # Show the output.
    tmp_file = file('outputfile.txt')
    sys.stdout = save_stdout
    content = tmp_file.read()
    tmp_file.close()
    print content

test()
</pre>
<p>There is an alternative form of the <tt class="docutils literal">print</tt> statement that takes a
file-like object, in particular an object that has a <tt class="docutils literal">write</tt>
method.  For example:</p>
<pre class="literal-block">
In [1]: outfile = open('tmp.log', 'w')
In [2]: print &gt;&gt; outfile, 'Message #1'
In [3]: print &gt;&gt; outfile, 'Message #2'
In [4]: print &gt;&gt; outfile, 'Message #3'
In [5]: outfile.close()
In [6]:
In [6]: infile = open('tmp.log', 'r')
In [7]: for line in infile:
   ...:     print 'Line:', line.rstrip('\n')
   ...:
Line: Message #1
Line: Message #2
Line: Message #3
In [8]: infile.close()
</pre>
<p>Future deprecation warning -- There is no print <em>statement</em> in Python
3.  There is a print built-in <em>function</em>.</p>
</div>
<div class="section" id="if-elif-else-statement">
<h3><a class="toc-backref" href="#id60">1.6.4&nbsp;&nbsp;&nbsp;if: elif: else: statement</a></h3>
<p>A template for the <tt class="docutils literal">if:</tt> statement:</p>
<pre class="literal-block">
if condition1:
    statements
elif condition2:
    statements
elif condition3:
    statements
else:
    statements
</pre>
<p>The <tt class="docutils literal">elif</tt> and <tt class="docutils literal">else</tt> clauses are optional.</p>
<p>Conditions -- Expressions -- Anything that returns a value.
Compare with <tt class="docutils literal">eval()</tt> and <tt class="docutils literal">exec</tt>.</p>
<p>Truth values:</p>
<ul class="simple">
<li>False -- <tt class="docutils literal">False</tt>, <tt class="docutils literal">None</tt>, numeric zero, the empty string, an
empty collection (list or tuple or dictionary or ...).</li>
<li>True -- <tt class="docutils literal">True</tt> and everything else.</li>
</ul>
<p>Operators:</p>
<ul>
<li><p class="first"><tt class="docutils literal">and</tt> and <tt class="docutils literal">or</tt> -- Note that both <tt class="docutils literal">and</tt> and <tt class="docutils literal">or</tt> do short
circuit evaluation.</p>
</li>
<li><p class="first"><tt class="docutils literal">not</tt></p>
</li>
<li><p class="first"><tt class="docutils literal">is</tt> and <tt class="docutils literal">is not</tt> -- The identical object.  Cf. <tt class="docutils literal">a is b</tt> and
<tt class="docutils literal">id(a) == id(b)</tt>.  Useful to test for <tt class="docutils literal">None</tt>, for example:</p>
<pre class="literal-block">
if x is None:
    ...
if x is not None:
    ...
</pre>
</li>
<li><p class="first"><tt class="docutils literal">in</tt> and <tt class="docutils literal">not in</tt> -- Can be used to test for existence of a
key in a dictionary or for the presence of a value in a
collection.</p>
<p>The <tt class="docutils literal">in</tt> operator tests for equality, not identity.</p>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = {'aa': 111, 'bb': 222}
&gt;&gt;&gt; 'aa' in d
True
&gt;&gt;&gt; 'aa' not in d
False
&gt;&gt;&gt; 'xx' in d
False
</pre>
</li>
<li><p class="first">Comparison operators, for example <tt class="docutils literal">==</tt>, <tt class="docutils literal">!=</tt>, <tt class="docutils literal">&lt;</tt>, <tt class="docutils literal">&lt;=</tt>, ...</p>
</li>
</ul>
<p>There is an <tt class="docutils literal">if</tt> expression.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = 'aa'
&gt;&gt;&gt; b = 'bb'
&gt;&gt;&gt; x = 'yes' if a == b else 'no'
&gt;&gt;&gt; x
'no'
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The <tt class="docutils literal">elif:</tt> clauses and the <tt class="docutils literal">else:</tt> clause are optional.</li>
<li>The <tt class="docutils literal">if:</tt>, <tt class="docutils literal">elif:</tt>, and <tt class="docutils literal">else:</tt> clauses are all header lines
in the sense that they are each followed by an indented block of
code and each of these header lines ends with a colon.  (To put an
empty block after one of these, or any other, statement header
line, use the <tt class="docutils literal">pass</tt> statement.  It's effectively a no-op.)</li>
<li>Parentheses around the condition in an <tt class="docutils literal">if:</tt> or <tt class="docutils literal">elif:</tt> are
not required and are considered bad form, unless the condition
extends over multiple lines, in which case parentheses are
preferred over use of a line continuation character (backslash at
the end of the line).</li>
</ul>
<p>Exercises:</p>
<ul class="simple">
<li>Write an <tt class="docutils literal">if</tt> statement with an <tt class="docutils literal">and</tt> operator.</li>
<li>Write an <tt class="docutils literal">if</tt> statement with an <tt class="docutils literal">or</tt> operator.</li>
<li>Write an <tt class="docutils literal">if</tt> statement containing both <tt class="docutils literal">and</tt> and <tt class="docutils literal">or</tt>
operators.</li>
</ul>
</div>
<div class="section" id="for-statement">
<h3><a class="toc-backref" href="#id61">1.6.5&nbsp;&nbsp;&nbsp;for: statement</a></h3>
<p>Iterate over a sequence or an &quot;iterable&quot; object.</p>
<p>Form:</p>
<pre class="literal-block">
for x in y:
    block
</pre>
<p>Iterator -- Some notes on what it means to be iterable:</p>
<ul class="simple">
<li>An iterable is something that can be used in an iterator context,
for example, in a <tt class="docutils literal">for:</tt> statement, in a list comprehension, and
in a generator expression.</li>
<li>Sequences and containers are iterable.  Examples: tuples, lists,
strings, dictionaries.</li>
<li>Instances of classes that obey the iterator protocol are
iterable.  See <a class="reference external" href="http://docs.python.org/lib/typeiter.html">http://docs.python.org/lib/typeiter.html</a>.</li>
<li>We can create an iterator object with built-in functions such as
<tt class="docutils literal">iter()</tt> and <tt class="docutils literal">enumerate()</tt>.  See
<a class="reference external" href="http://docs.python.org/lib/built-in-funcs.html">Built-in Functions --
http://docs.python.org/lib/built-in-funcs.html</a>
in the Python standard library reference.</li>
<li>Functions that use the <tt class="docutils literal">yield</tt> statement, produce an iterator,
although it's actually called a generator.</li>
<li>An iterable implements the iterator interface and satisfies the
iterator protocol.  The iterator protocol: <tt class="docutils literal">__iter__()</tt> and
<tt class="docutils literal">next()</tt> methods.  See <a class="reference external" href="http://docs.python.org/lib/typeiter.html">2.3.5 Iterator Types</a> --
(<a class="reference external" href="http://docs.python.org/lib/typeiter.html">http://docs.python.org/lib/typeiter.html</a>).</li>
</ul>
<p>Testing for &quot;iterability&quot;:</p>
<ul class="simple">
<li>If you can use an object in a <tt class="docutils literal">for:</tt> statement, it's iterable.</li>
<li>If the expresion <tt class="docutils literal">iter(obj)</tt> does not produce a <tt class="docutils literal">TypeError</tt>
exception, it's iterable.</li>
</ul>
<p>Some ways to produce iterators:</p>
<ul>
<li><p class="first"><tt class="docutils literal">iter()</tt> and <tt class="docutils literal">enumerate()</tt> -- See:
<a class="reference external" href="http://docs.python.org/lib/built-in-funcs.html">http://docs.python.org/lib/built-in-funcs.html</a>.</p>
</li>
<li><p class="first"><tt class="docutils literal">some_dict.iterkeys()</tt>, <tt class="docutils literal">some_dict.itervalues()</tt>,
<tt class="docutils literal">some_dict.iteritems()</tt>.</p>
</li>
<li><p class="first">Use a sequence in an iterator context, for example in a <tt class="docutils literal">for</tt>
statement.  Lists, tuples, dictionaries, and strings can be used in
an iterator context to produce an iterator.</p>
</li>
<li><p class="first">Generator expressions -- Latest Python only.  Syntactically like
list comprehensions, but (1) surrounded by parentheses instead of
square brackets and (2) use lazy evaluation.</p>
</li>
<li><p class="first">A class that implements the iterator protocol -- Example:</p>
<pre class="literal-block">
class A(object):
    def __init__(self):
        self.data = [11,22,33]
        self.idx = 0
    def __iter__(self):
        return self
    def next(self):
        if self.idx &lt; len(self.data):
            x = self.data[self.idx]
            self.idx +=1
            return x
        else:
            raise StopIteration

def test():
    a = A()
    for x in a:
        print x

test()
</pre>
<p>Note that the iterator protocol changes in Python 3.</p>
</li>
<li><p class="first">A function containing a yield statement.  See:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.python.org/2/reference/expressions.html#yield-expressions">Yield expressions --
http://docs.python.org/2/reference/expressions.html#yield-expressions</a></li>
<li><a class="reference external" href="http://docs.python.org/2/reference/simple_stmts.html#the-yield-statement">The yield statement --
http://docs.python.org/2/reference/simple_stmts.html#the-yield-statement</a></li>
</ul>
</li>
<li><p class="first">Also see <tt class="docutils literal">itertools</tt> module in the Python standard library for
much more help with iterators:
<a class="reference external" href="http://docs.python.org/2/library/itertools.html#module-itertools">itertools  Functions creating iterators for efficient looping --
http://docs.python.org/2/library/itertools.html#module-itertools</a></p>
</li>
</ul>
<p>The <tt class="docutils literal">for:</tt> statement can also do unpacking.  Example:</p>
<pre class="literal-block">
In [25]: items = ['apple', 'banana', 'cherry', 'date']
In [26]: for idx, item in enumerate(items):
   ....:     print '%d.  %s' % (idx, item, )
   ....:
0.  apple
1.  banana
2.  cherry
3.  date
</pre>
<p>The <tt class="docutils literal">for</tt> statement can also have an optional <tt class="docutils literal">else:</tt> clause.  The
<tt class="docutils literal">else:</tt> clause is executed if the <tt class="docutils literal">for</tt> statement completes
normally, that is if a <tt class="docutils literal">break</tt> statement is <em>not</em> executed.</p>
<p>Helpful functions with <tt class="docutils literal">for</tt>:</p>
<ul>
<li><p class="first"><tt class="docutils literal">enumerate(iterable)</tt> -- Returns an iterable that produces
pairs (tuples) containing count (index) and value.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; for idx, value in enumerate([11,22,33]):
...     print idx, value
...
0 11
1 22
2 33
</pre>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">range([start,]</span> stop[, step])</tt> and <tt class="docutils literal"><span class="pre">xrange([start,]</span> stop[, step])</tt>.</p>
</li>
</ul>
<p>List comprehensions -- Since list comprehensions create lists, they
are useful in <tt class="docutils literal">for</tt> statements, although, when the number of
elements is large, you should consider using a generator expression
instead.  A list comprehension looks a bit like a <tt class="docutils literal">for:</tt>
statement, but is inside square brackets, and it is an expression,
not a statement.  Two forms (among others):</p>
<ul class="simple">
<li><tt class="docutils literal">[f(x) for x in iterable]</tt></li>
<li><tt class="docutils literal">[f(x) for x in iterable if t(x)]</tt></li>
</ul>
<p>Generator expressions -- A generator expression looks similar to a
list comprehension, except that it is surrounded by parentheses
rather than square brackets.  Example:</p>
<pre class="literal-block">
In [28]: items = ['apple', 'banana', 'cherry', 'date']
In [29]: gen1 = (item.upper() for item in items)
In [30]: for x in gen1:
   ....:     print 'x:', x
   ....:
x: APPLE
x: BANANA
x: CHERRY
x: DATE
</pre>
<p>Exercises:</p>
<ul>
<li><p class="first">Write a list comprehension that returns all the keys in a
dictionary whose associated values are greater than zero.</p>
<ul class="simple">
<li>The dictionary: <tt class="docutils literal">{'aa': 11, 'cc': 33, 'dd': <span class="pre">-55,</span> 'bb': 22}</tt></li>
<li>Solution: <tt class="docutils literal">[x[0] for x in my_dict.iteritems() if x[1] &gt; 0]</tt></li>
</ul>
</li>
<li><p class="first">Write a list comprehension that produces even integers from 0 to
10.  Use a <tt class="docutils literal">for</tt> statement to iterate over those values.
Solution:</p>
<pre class="literal-block">
for x in [y for y in range(10) if y % 2 == 0]:
    print 'x: %s' % x
</pre>
</li>
<li><p class="first">Write a list comprehension that iterates over two lists and
produces all the combinations of items from the lists.  Solution:</p>
<pre class="literal-block">
In [19]: a = range(4)
In [20]: b = [11,22,33]
In [21]: a
Out[21]: [0, 1, 2, 3]
In [22]: b
Out[22]: [11, 22, 33]
In [23]: c = [(x, y) for x in a for y in b]
In [24]: print c
[(0, 11), (0, 22), (0, 33), (1, 11), (1, 22), (1, 33),
(2, 11), (2, 22), (2, 33), (3, 11), (3, 22), (3, 33)]
</pre>
</li>
</ul>
<p>But, note that in the previous exercise, a generator expression
would often be better.  A generator expression is like a list
comprehension, except that, instead of creating the entire list,
it produces a generator that can be used to produce each of the
elements.</p>
<p>The <tt class="docutils literal">break</tt> and <tt class="docutils literal">continue</tt> statements are often useful in a
<tt class="docutils literal">for</tt> statement.  See <a class="reference internal" href="#continue-and-break-statements">continue and break statements</a></p>
<p>The <tt class="docutils literal">for</tt> statement can also have an optional <tt class="docutils literal">else:</tt> clause.
The <tt class="docutils literal">else:</tt> clause is executed if the <tt class="docutils literal">for</tt> statement completes
normally, that is if a <tt class="docutils literal">break</tt> statement is <em>not</em> executed.
Example:</p>
<pre class="literal-block">
for item in data1:
    if item &gt; 100:
        value1 = item
        break
else:
    value1 = 'not found'
print 'value1:', value1
</pre>
<p>When run, it prints:</p>
<pre class="literal-block">
value1: not found
</pre>
</div>
<div class="section" id="while-statement">
<h3><a class="toc-backref" href="#id62">1.6.6&nbsp;&nbsp;&nbsp;while: statement</a></h3>
<p>Form:</p>
<pre class="literal-block">
while condition:
    block
</pre>
<p>The <tt class="docutils literal">while:</tt> statement is not often used in Python because the
<tt class="docutils literal">for:</tt> statement is usually more convenient, more idiomatic, and
more Pythonic.</p>
<p>Exercises:</p>
<ul>
<li><p class="first">Write a <tt class="docutils literal">while</tt> statement that prints integers from zero to 5.
Solution:</p>
<pre class="literal-block">
count = 0
while count &lt; 5:
    count += 1
    print count
</pre>
</li>
</ul>
<p>The <tt class="docutils literal">break</tt> and <tt class="docutils literal">continue</tt> statements are often useful in a
<tt class="docutils literal">while</tt> statement.  See <a class="reference internal" href="#continue-and-break-statements">continue and break statements</a></p>
<p>The <tt class="docutils literal">while</tt> statement can also have an optional <tt class="docutils literal">else:</tt> clause.
The <tt class="docutils literal">else:</tt> clause is executed if the <tt class="docutils literal">while</tt> statement completes
normally, that is if a <tt class="docutils literal">break</tt> statement is <em>not</em> executed.</p>
</div>
<div class="section" id="continue-and-break-statements">
<h3><a class="toc-backref" href="#id63">1.6.7&nbsp;&nbsp;&nbsp;continue and break statements</a></h3>
<p>The <tt class="docutils literal">break</tt> statement exits from a loop.</p>
<p>The <tt class="docutils literal">continue</tt> statement causes execution to immediately
continue at the start of the loop.</p>
<p>Can be used in <tt class="docutils literal">for:</tt> and <tt class="docutils literal">while:</tt>.</p>
<p>When the <tt class="docutils literal">for:</tt> statement or the <tt class="docutils literal">while:</tt> statement has an
<tt class="docutils literal">else:</tt> clause, the block in the <tt class="docutils literal">else:</tt> clause is executed only
if a <tt class="docutils literal">break</tt> statement is <em>not</em> executed.</p>
<p>Exercises:</p>
<ul>
<li><p class="first">Using <tt class="docutils literal">break</tt>, write a <tt class="docutils literal">while</tt> statement that prints
integers from zero to 5.  Solution:</p>
<pre class="literal-block">
count = 0
while True:
    count += 1
    if count &gt; 5:
        break
    print count
</pre>
<p>Notes:</p>
<ul class="simple">
<li>A <tt class="docutils literal">for</tt> statement that uses <tt class="docutils literal">range()</tt> or <tt class="docutils literal">xrange()</tt> would
be better than a <tt class="docutils literal">while</tt> statement for this use.</li>
</ul>
</li>
<li><p class="first">Using <tt class="docutils literal">continue</tt>, write a <tt class="docutils literal">while</tt> statement that processes
only even integers from 0 to 10.  Note: <tt class="docutils literal">%</tt> is the modulo
operator.  Solution:</p>
<pre class="literal-block">
count = 0
while count &lt; 10:
    count += 1
    if count % 2 == 0:
        continue
    print count
</pre>
</li>
</ul>
</div>
<div class="section" id="try-except-statement">
<h3><a class="toc-backref" href="#id64">1.6.8&nbsp;&nbsp;&nbsp;try: except: statement</a></h3>
<p>Exceptions are a systematic and consistent way of processing errors
and &quot;unusual&quot; events in Python.</p>
<p>Caught and un-caught exceptions -- Uncaught exceptions terminate a
program.</p>
<p>The <tt class="docutils literal">try:</tt> statement catches an exception.</p>
<p>Almost all errors in Python are exceptions.</p>
<p>Evaluation (execution model) of the <tt class="docutils literal">try</tt> statement -- When an
exception occurs in the <tt class="docutils literal">try</tt> block, even if inside a nested
function call, execution of the <tt class="docutils literal">try</tt> block ends and the <tt class="docutils literal">except</tt>
clauses are searched for a matching exception.</p>
<p>Tracebacks -- Also see the <tt class="docutils literal">traceback</tt> module:
<a class="reference external" href="http://docs.python.org/lib/module-traceback.html">http://docs.python.org/lib/module-traceback.html</a></p>
<p>Exceptions are classes.</p>
<p>Exception classes -- subclassing, args.</p>
<p>An exception class in an <tt class="docutils literal">except:</tt> clause catches instances of
that exception class and all subclasses, but <em>not</em> superclasses.</p>
<p>Built-in exception classes -- See:</p>
<ul class="simple">
<li>Module <tt class="docutils literal">exceptions</tt>.</li>
<li>Built-in exceptions -- <a class="reference external" href="http://docs.python.org/lib/module-exceptions.html">http://docs.python.org/lib/module-exceptions.html</a>.</li>
</ul>
<p>User defined exception classes -- subclasses of <tt class="docutils literal">Exception</tt>.</p>
<p>Example:</p>
<pre class="literal-block">
try:
    raise RuntimeError('this silly error')
except RuntimeError, exp:
    print &quot;[[[%s]]]&quot; % exp
</pre>
<p>Reference: <a class="reference external" href="http://docs.python.org/lib/module-exceptions.html">http://docs.python.org/lib/module-exceptions.html</a></p>
<p>You can also get the arguments passed to the constructor of an
exception object.  In the above example, these would be:</p>
<pre class="literal-block">
exp.args
</pre>
<p>Why would you define your own exception class?  One answer:  You
want a user of your code to catch your exception and no others.</p>
<p>Catching an exception by exception class catches exceptions of that
class and all its subclasses.  So:</p>
<pre class="literal-block">
except SomeExceptionClass, exp:
</pre>
<p>matches and catches an exception if SomeExceptionClass is the
exception class or a base class (superclass) of the exception class.
The exception object (usually an instance of some exception class)
is bound to <tt class="docutils literal">exp</tt>.</p>
<p>A more &quot;modern&quot; syntax is:</p>
<pre class="literal-block">
except SomeExceptionClass as exp:
</pre>
<p>So:</p>
<pre class="literal-block">
class MyE(ValueError):
    pass

try:
    raise MyE()
except ValueError:
    print 'caught exception'
</pre>
<p>will print &quot;caught exception&quot;, because <tt class="docutils literal">ValueError</tt> is a base class
of <tt class="docutils literal">MyE</tt>.</p>
<p>Also see the entries for &quot;EAFP&quot; and &quot;LBYL&quot; in the Python glossary:
<a class="reference external" href="http://docs.python.org/3/glossary.html">http://docs.python.org/3/glossary.html</a>.</p>
<p>Exercises:</p>
<ul>
<li><p class="first">Write a <em>very</em> simple, empty exception subclass.  Solution:</p>
<pre class="literal-block">
class MyE(Exception):
    pass
</pre>
</li>
<li><p class="first">Write a <tt class="docutils literal">try:except:</tt> statement that raises your exception and
also catches it.  Solution:</p>
<pre class="literal-block">
try:
    raise MyE('hello there dave')
except MyE, e:
    print e
</pre>
</li>
</ul>
</div>
<div class="section" id="raise-statement">
<h3><a class="toc-backref" href="#id65">1.6.9&nbsp;&nbsp;&nbsp;raise statement</a></h3>
<p>Throw or raise an exception.</p>
<p>Forms:</p>
<ul class="simple">
<li><tt class="docutils literal">raise instance</tt></li>
<li><tt class="docutils literal">raise MyExceptionClass(value)</tt> -- preferred.</li>
<li><tt class="docutils literal">raise MyExceptionClass, value</tt></li>
</ul>
<p>The <tt class="docutils literal">raise</tt> statement takes:</p>
<ul class="simple">
<li>An (instance of) a built-in exception class.</li>
<li>An instance of class <tt class="docutils literal">Exception</tt> or</li>
<li>An instance of a built-in subclass of class <tt class="docutils literal">Exception</tt> or</li>
<li>An instance of a user-defined subclass of class <tt class="docutils literal">Exception</tt> or</li>
<li>One of the above classes and (optionally) a value (for example,
a string or a tuple).</li>
</ul>
<p>See <a class="reference external" href="http://docs.python.org/ref/raise.html">http://docs.python.org/ref/raise.html</a>.</p>
<p>For a list of built-in exceptions, see
<a class="reference external" href="http://docs.python.org/lib/module-exceptions.html">http://docs.python.org/lib/module-exceptions.html</a>.</p>
<p>The following example defines an exception subclass and throws an
instance of that subclass.  It also shows how to pass and catch
multiple arguments to the exception:</p>
<pre class="literal-block">
class NotsobadError(Exception):
    pass

def test(x):
    try:
        if x == 0:
            raise NotsobadError('a moderately bad error', 'not too bad')
    except NotsobadError, e:
        print 'Error args: %s' % (e.args, )

test(0)
</pre>
<p>Which prints out the following:</p>
<pre class="literal-block">
Error args: ('a moderately bad error', 'not too bad')
</pre>
<p>Notes:</p>
<ul class="simple">
<li>In order to pass in multiple arguments with the exception, we use
a tuple, or we pass multiple arguments to the constructor.</li>
</ul>
<p>The following example does a small amount of processing of the
arguments:</p>
<pre class="literal-block">
class NotsobadError(Exception):
    &quot;&quot;&quot;An exception class.
    &quot;&quot;&quot;
    def get_args(self):
        return '::::'.join(self.args)

def test(x):
    try:
        if x == 0:
            raise NotsobadError('a moderately bad error', 'not too bad')
    except NotsobadError, e:
        print 'Error args: {{{%s}}}' % (e.get_args(), )

test(0)
</pre>
</div>
<div class="section" id="with-statement">
<h3><a class="toc-backref" href="#id66">1.6.10&nbsp;&nbsp;&nbsp;with: statement</a></h3>
<p>The <tt class="docutils literal">with</tt> statement enables us to use a context manager (any
object that satisfies the context manager protocol) to add code
before (on entry to) and after (on exit from) a block of code.</p>
<div class="section" id="writing-a-context-manager">
<h4><a class="toc-backref" href="#id67">1.6.10.1&nbsp;&nbsp;&nbsp;Writing a context manager</a></h4>
<p>A context manager is an instance of a class that satisfies this
interface:</p>
<pre class="literal-block">
class Context01(object):
    def __enter__(self):
        pass
    def __exit__(self, exc_type, exc_value, traceback):
        pass
</pre>
<p>Here is an example that uses the above context manager:</p>
<pre class="literal-block">
class Context01(object):
    def __enter__(self):
        print 'in __enter__'
        return 'some value or other'    # usually we want to return self
    def __exit__(self, exc_type, exc_value, traceback):
        print 'in __exit__'
</pre>
<p>Notes:</p>
<ul>
<li><p class="first">The <tt class="docutils literal">__enter__</tt> method is called <em>before</em> our block of code is
entered.</p>
</li>
<li><p class="first">Usually, but not always, we will want the <tt class="docutils literal">__enter__</tt> method to
return <tt class="docutils literal">self</tt>, that is, the instance of our context manager
class.  We do this so that we can write:</p>
<pre class="literal-block">
with MyContextManager() as obj:
    pass
</pre>
<p>and then use the instance (<tt class="docutils literal">obj</tt> in this case) in the nested
block.</p>
</li>
<li><p class="first">The <tt class="docutils literal">__exit__</tt> method is called when our block of code is
exited either normally or because of an exception.</p>
</li>
<li><p class="first">If an exception is supplied, and the method wishes to suppress the
exception (i.e., prevent it from being propagated), it should
return a true value. Otherwise, the exception will be processed
normally upon exit from this method.</p>
</li>
<li><p class="first">If the block exits normally, the value of <tt class="docutils literal">exc_type</tt>,
<tt class="docutils literal">exc_value</tt>, and <tt class="docutils literal">traceback</tt> will be <tt class="docutils literal">None</tt>.</p>
</li>
</ul>
<p>For more information on the <tt class="docutils literal">with:</tt> statement, see
<a class="reference external" href="http://docs.python.org/2/library/stdtypes.html#context-manager-types">Context Manager Types --
http://docs.python.org/2/library/stdtypes.html#context-manager-types</a>.</p>
<p>See module <tt class="docutils literal">contextlib</tt> for strange ways of writing context
managers:
<a class="reference external" href="http://docs.python.org/2/library/contextlib.html#module-contextlib">http://docs.python.org/2/library/contextlib.html#module-contextlib</a></p>
</div>
<div class="section" id="using-the-with-statement">
<h4><a class="toc-backref" href="#id68">1.6.10.2&nbsp;&nbsp;&nbsp;Using the with: statement</a></h4>
<p>Here are examples:</p>
<pre class="literal-block">
# example 1
with Context01():
    print 'in body'

# example 2
with Context02() as a_value:
    print 'in body'
    print 'a_value: &quot;%s&quot;' % (a_value, )
    a_value.some_method_in_Context02()

# example 3
with open(infilename, 'r') as infile, open(outfilename, 'w') as outfile:
    for line in infile:
        line = line.rstrip()
        outfile.write('%s\n' % line.upper())
</pre>
<p>Notes:</p>
<ul class="simple">
<li>In the form <tt class="docutils literal">with ... as val</tt>, the value returned by the
<tt class="docutils literal">__enter__</tt> method is assigned to the variable (<tt class="docutils literal">val</tt> in this
case).</li>
<li>In order to use more than one context manager, you can nest
<tt class="docutils literal">with:</tt> statements, or separate uses of of the context managers
with commas, which is usually preferred.  See example 3 above.</li>
</ul>
</div>
</div>
<div class="section" id="del">
<h3><a class="toc-backref" href="#id69">1.6.11&nbsp;&nbsp;&nbsp;del</a></h3>
<p>The <tt class="docutils literal">del</tt> statement can be used to:</p>
<ul class="simple">
<li>Remove names from namespace.</li>
<li>Remove items from a collection.</li>
</ul>
<p>If name is listed in a <tt class="docutils literal">global</tt> statement, then <tt class="docutils literal">del</tt> removes
name from the global namespace.</p>
<p>Names can be a (nested) list.  Examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; del a
&gt;&gt;&gt; del a, b, c
</pre>
<p>We can also delete items from a list or dictionary (and perhaps from
other objects that we can subscript).  Examples:</p>
<pre class="literal-block">
In [9]:d = {'aa': 111, 'bb': 222, 'cc': 333}
In [10]:print d
{'aa': 111, 'cc': 333, 'bb': 222}
In [11]:del d['bb']
In [12]:print d
{'aa': 111, 'cc': 333}
In [13]:
In [13]:a = [111, 222, 333, 444]
In [14]:print a
[111, 222, 333, 444]
In [15]:del a[1]
In [16]:print a
[111, 333, 444]
</pre>
<p>And, we can delete an attribute from an instance.  Example:</p>
<pre class="literal-block">
In [17]:class A:
   ....:    pass
   ....:
In [18]:a = A()
In [19]:a.x = 123
In [20]:dir(a)
Out[20]:['__doc__', '__module__', 'x']
In [21]:print a.x
123
In [22]:del a.x
In [23]:dir(a)
Out[23]:['__doc__', '__module__']
In [24]:print a.x
----------------------------------------------
exceptions.AttributeError     Traceback (most recent call last)

/home/dkuhlman/a1/Python/Test/&lt;console&gt;

AttributeError: A instance has no attribute 'x'
</pre>
</div>
<div class="section" id="case-statement">
<h3><a class="toc-backref" href="#id70">1.6.12&nbsp;&nbsp;&nbsp;case statement</a></h3>
<p>There is no case statement in Python.  Use the <tt class="docutils literal">if:</tt> statement
with a sequence of <tt class="docutils literal">elif:</tt> clauses.  Or, use a dictionary of
functions.</p>
</div>
</div>
<div class="section" id="functions-modules-packages-and-debugging">
<h2><a class="toc-backref" href="#id71">1.7&nbsp;&nbsp;&nbsp;Functions, Modules, Packages, and Debugging</a></h2>
<div class="section" id="functions">
<h3><a class="toc-backref" href="#id72">1.7.1&nbsp;&nbsp;&nbsp;Functions</a></h3>
<div class="section" id="the-def-statement">
<h4><a class="toc-backref" href="#id73">1.7.1.1&nbsp;&nbsp;&nbsp;The def statement</a></h4>
<p>The <tt class="docutils literal">def</tt> statement is used to define functions and methods.</p>
<p>The <tt class="docutils literal">def</tt> statement is evaluated.  It produces a function/method
(object) and binds it to a variable in the current name-space.</p>
<p>Although the <tt class="docutils literal">def</tt> statement is evaluated, the code in its nested
block is not executed.  Therefore, many errors may not be detected
until each and every path through that code is tested.
Recommendations: (1) Use a Python code checker, for example
<tt class="docutils literal">flake8</tt> or <tt class="docutils literal">pylint</tt>; (2) Do thorough testing and use the Python
<tt class="docutils literal">unittest</tt> framework.  Pythonic wisdom: If it's not tested, it's
broken.</p>
</div>
<div class="section" id="returning-values">
<h4><a class="toc-backref" href="#id74">1.7.1.2&nbsp;&nbsp;&nbsp;Returning values</a></h4>
<p>The <tt class="docutils literal">return</tt> statement is used to return values from a function.</p>
<p>The <tt class="docutils literal">return</tt> statement takes zero or more values, separated by
commas.  Using commas actually returns a single tuple.</p>
<p>The default value is <tt class="docutils literal">None</tt>.</p>
<p>To return multiple values, use a tuple or list.  Don't forget that
(assignment) unpacking can be used to capture multiple values.
Returning multiple items separated by commas is equivalent to
returning a tuple.  Example:</p>
<pre class="literal-block">
In [8]: def test(x, y):
   ...:     return x * 3, y * 4
   ...:
In [9]: a, b = test(3, 4)
In [10]: print a
9
In [11]: print b
16
</pre>
</div>
<div class="section" id="parameters">
<h4><a class="toc-backref" href="#id75">1.7.1.3&nbsp;&nbsp;&nbsp;Parameters</a></h4>
<p>Default values -- Example:</p>
<pre class="literal-block">
In [53]: def t(max=5):
   ....:     for val in range(max):
   ....:         print val
   ....:
   ....:
In [54]: t(3)
0
1
2
In [55]: t()
0
1
2
3
4
</pre>
<p>Giving a parameter a default value makes that parameter optional.</p>
<p>Note: If a function has a parameter with a default value, then all
&quot;normal&quot; arguments must proceed the parameters with default values.
More completely, parameters must be given from left to right in the
following order:</p>
<ol class="arabic simple">
<li>Normal arguments.</li>
<li>Arguments with default values.</li>
<li>Argument list (<tt class="docutils literal">*args</tt>).</li>
<li>Keyword arguments (<tt class="docutils literal">**kwargs</tt>).</li>
</ol>
<p>List parameters -- <tt class="docutils literal">*args</tt>.  It's a tuple.</p>
<p>Keyword parameters -- <tt class="docutils literal">**kwargs</tt>.  It's a dictionary.</p>
</div>
<div class="section" id="arguments">
<h4><a class="toc-backref" href="#id76">1.7.1.4&nbsp;&nbsp;&nbsp;Arguments</a></h4>
<p>When calling a function, values may be passed to a function with
positional arguments or keyword arguments.</p>
<p>Positional arguments must placed before (to the left of) keyword
arguments.</p>
<p>Passing lists to a function as multiple arguments --
<tt class="docutils literal"><span class="pre">some_func(*aList)</span></tt>.  Effectively, this syntax causes Python to
unroll the arguments.  Example:</p>
<pre class="literal-block">
def fn1(*args, **kwargs):
    fn2(*args, **kwargs)
</pre>
</div>
<div class="section" id="local-variables">
<h4><a class="toc-backref" href="#id77">1.7.1.5&nbsp;&nbsp;&nbsp;Local variables</a></h4>
<p>Creating local variables -- Any binding operation creates a local
variable.  Examples are (1) parameters of a function; (2) assignment
to a variable in a function; (3) the <tt class="docutils literal">import</tt> statement; (4) etc.
Contrast with accessing a variable.</p>
<p>Variable look-up -- The LGB/LEGB rule -- The local, enclosing,
global, built-in scopes are searched in that order.  See:
<a class="reference external" href="http://www.python.org/dev/peps/pep-0227/">http://www.python.org/dev/peps/pep-0227/</a></p>
<p>The <tt class="docutils literal">global</tt> statement -- Inside a function, we must use
<tt class="docutils literal">global</tt> when we want to set the value of a global variable.
Example:</p>
<pre class="literal-block">
def fn():
    global Some_global_variable, Another_global_variable
    Some_global_variable = 'hello'
    ...
</pre>
</div>
<div class="section" id="other-things-to-know-about-functions">
<h4><a class="toc-backref" href="#id78">1.7.1.6&nbsp;&nbsp;&nbsp;Other things to know about functions</a></h4>
<ul>
<li><p class="first">Functions are first-class -- You can store them in a structure,
pass them to a function, and return them from a function.</p>
</li>
<li><p class="first">Function calls can take keyword arguments.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; test(size=25)
</pre>
</li>
<li><p class="first">Formal parameters to a function can have default values.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; def test(size=0):
        ...
</pre>
<p>Do <em>not</em> use mutable objects as default values.</p>
</li>
<li><p class="first">You can &quot;capture&quot; remaining arguments with <tt class="docutils literal">*args</tt>, and
<tt class="docutils literal">**kwargs</tt>. (Spelling is not significant.)  Example:</p>
<pre class="literal-block">
In [13]: def test(size, *args, **kwargs):
   ....:     print size
   ....:     print args
   ....:     print kwargs
   ....:
   ....:
In [14]: test(32, 'aa', 'bb', otherparam='xyz')
32
('aa', 'bb')
{'otherparam': 'xyz'}
</pre>
</li>
<li><p class="first">Normal arguments must come before default arguments which must
come before keyword arguments.</p>
</li>
<li><p class="first">A function that does not explicitly return a value, returns
<tt class="docutils literal">None</tt>.</p>
</li>
<li><p class="first">In order to <em>set</em> the value of a global variable, declare the
variable with <tt class="docutils literal">global</tt>.</p>
</li>
</ul>
<p>Exercises:</p>
<ul>
<li><p class="first">Write a function that takes a single argument, prints the value
of the argument, and returns the argument as a string.  Solution:</p>
<pre class="literal-block">
&gt;&gt;&gt; def t(x):
...     print 'x: %s' % x
...     return '[[%s]]' % x
...
&gt;&gt;&gt; t(3)
x: 3
'[[3]]'
</pre>
</li>
<li><p class="first">Write a function that takes a variable number of arguments and
prints them all.  Solution:</p>
<pre class="literal-block">
&gt;&gt;&gt; def t(*args):
...     for arg in args:
...         print 'arg: %s' % arg
...
&gt;&gt;&gt; t('aa', 'bb', 'cc')
arg: aa
arg: bb
arg: cc
</pre>
</li>
<li><p class="first">Write a function that prints the names and values of keyword
arguments passed to it.  Solution:</p>
<pre class="literal-block">
&gt;&gt;&gt; def t(**kwargs):
...     for key in kwargs.keys():
...         print 'key: %s  value: %s' % (key, kwargs[key], )
...
&gt;&gt;&gt; t(arg1=11, arg2=22)
key: arg1  value: 11
key: arg2  value: 22
</pre>
</li>
</ul>
</div>
<div class="section" id="global-variables-and-the-global-statement">
<h4><a class="toc-backref" href="#id79">1.7.1.7&nbsp;&nbsp;&nbsp;Global variables and the global statement</a></h4>
<p>By default, assignment in a function or method creates local
variables.</p>
<p>Reference (not assignment) to a variable, accesses a local
variable if it has already been created, else accesses a global
variable.</p>
<p>In order to assign a value to a global variable, declare the
variable as global at the beginning of the function or method.</p>
<p>If in a function or method, you both reference and assign to a
variable, then you must either:</p>
<ol class="arabic simple">
<li>Assign to the variable first, or</li>
<li>Declare the variable as global.</li>
</ol>
<p>The <tt class="docutils literal">global</tt> statement declares one or more variables, separated
by commas, to be global.</p>
<p>Some examples:</p>
<pre class="literal-block">
In [1]:
In [1]: X = 3
In [2]: def t():
   ...:       print X
   ...:
In [3]:
In [3]: t()
3
In [4]: def s():
   ...:      X = 4
   ...:
In [5]:
In [5]:
In [5]: s()
In [6]: t()
3
In [7]: X = -1
In [8]: def u():
   ...:      global X
   ...:      X = 5
   ...:
In [9]:
In [9]: u()
In [10]: t()
5
In [16]: def v():
   ....:     x = X
   ....:     X = 6
   ....:     return x
   ....:
In [17]:
In [17]: v()
------------------------------------------------------------
Traceback (most recent call last):
  File &quot;&lt;ipython console&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;ipython console&gt;&quot;, line 2, in v
UnboundLocalError: local variable 'X' referenced before assignment
In [18]: def w():
   ....:     global X
   ....:     x = X
   ....:     X = 7
   ....:     return x
   ....:
In [19]:
In [19]: w()
Out[19]: 5
In [20]: X
Out[20]: 7
</pre>
</div>
<div class="section" id="doc-strings-for-functions">
<h4><a class="toc-backref" href="#id80">1.7.1.8&nbsp;&nbsp;&nbsp;Doc strings for functions</a></h4>
<p>Add docstrings as a triple-quoted string beginning with the first
line of a function or method. See <a class="reference external" href="http://epydoc.sourceforge.net/">epydoc</a> for a suggested format.</p>
</div>
<div class="section" id="decorators-for-functions">
<h4><a class="toc-backref" href="#id81">1.7.1.9&nbsp;&nbsp;&nbsp;Decorators for functions</a></h4>
<p>A decorator performs a transformation on a function.  Examples of
decorators that are built-in functions are: <tt class="docutils literal">&#64;classmethod</tt>,
<tt class="docutils literal">&#64;staticmethod</tt>, and <tt class="docutils literal">&#64;property</tt>.  See:
<a class="reference external" href="http://docs.python.org/2/library/functions.html#built-in-functions">http://docs.python.org/2/library/functions.html#built-in-functions</a></p>
<p>A decorator is applied using the &quot;&#64;&quot; character on a line immediately
preceeding the function definition header.  Examples:</p>
<pre class="literal-block">
class SomeClass(object):

    &#64;classmethod
    def HelloClass(cls, arg):
        pass
    ## HelloClass = classmethod(HelloClass)

    &#64;staticmethod
    def HelloStatic(arg):
        pass
    ## HelloStatic = staticmethod(HelloStatic)

#
# Define/implement a decorator.
def wrapper(fn):
    def inner_fn(*args, **kwargs):
        print '&gt;&gt;'
        result = fn(*args, **kwargs)
        print '&lt;&lt;'
        return result
    return inner_fn

#
# Apply a decorator.
&#64;wrapper
def fn1(msg):
    pass
## fn1 = wrapper(fn1)
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The decorator form (with the &quot;&#64;&quot; character) is equivalent to the
form (commented out) that calls the decorator function explicitly.</li>
<li>The use of <tt class="docutils literal">classmethods</tt> and <tt class="docutils literal">staticmethod</tt> will be explained
later in the section on object-oriented programming.</li>
<li>A decorator is implemented as a function.  Therefore, to learn
about some specific decorator, you should search for the
documentation on or the implementation of that function.  Remember
that in order to use a function, it must be defined in the current
module or imported by the current module or be a built-in.</li>
<li>The form that explicitly calls the decorator function (commented
out in the example above) is equivalent to the form using the &quot;&#64;&quot;
character.</li>
</ul>
</div>
</div>
<div class="section" id="lambda">
<h3><a class="toc-backref" href="#id82">1.7.2&nbsp;&nbsp;&nbsp;lambda</a></h3>
<p>Use a lambda, as a convenience, when you need a function that both:</p>
<ul class="simple">
<li>is anonymous (does not need a name) and</li>
<li>contains only an expression and no statements.</li>
</ul>
<p>Example:</p>
<pre class="literal-block">
In [1]: fn = lambda x, y, z: (x ** 2) + (y * 2) + z
In [2]: fn(4, 5, 6)
Out[2]: 32
In [3]:
In [3]: format = lambda obj, category: 'The &quot;%s&quot; is a &quot;%s&quot;.' % (obj, category, )
In [4]: format('pine tree', 'conifer')
Out[4]: 'The &quot;pine tree&quot; is a &quot;conifer&quot;.'
</pre>
<p>A lambda can take multiple arguments and can return (like a
function) multiple values.  Example:</p>
<pre class="literal-block">
In [79]: a = lambda x, y: (x * 3, y * 4, (x, y))
In [80]:
In [81]: a(3, 4)
Out[81]: (9, 16, (3, 4))
</pre>
<p>Suggestion: In some cases, a lambda may be useful as an event
handler.</p>
<p>Example:</p>
<pre class="literal-block">
class Test:
    def __init__(self, first='', last=''):
        self.first = first
        self.last = last
    def test(self, formatter):
        &quot;&quot;&quot;
        Test for lambdas.
        formatter is a function taking 2 arguments, first and last
          names.  It should return the formatted name.
        &quot;&quot;&quot;
        msg = 'My name is %s' % (formatter(self.first, self.last),)
        print msg

def test():
    t = Test('Dave', 'Kuhlman')
    t.test(lambda first, last: '%s %s' % (first, last, ))
    t.test(lambda first, last: '%s, %s' % (last, first, ))

test()
</pre>
<p>A <tt class="docutils literal">lambda</tt> enables us to define &quot;functions&quot; where we do not need
names for those functions.  Example:</p>
<pre class="literal-block">
In [45]: a = [
   ....: lambda x: x,
   ....: lambda x: x * 2,
   ....: ]
In [46]:
In [46]: a
Out[46]: [&lt;function __main__.&lt;lambda&gt;&gt;, &lt;function __main__.&lt;lambda&gt;&gt;]
In [47]: a[0](3)
Out[47]: 3
In [48]: a[1](3)
Out[48]: 6
</pre>
<p>Reference:
<a class="reference external" href="http://docs.python.org/2/reference/expressions.html#lambda">http://docs.python.org/2/reference/expressions.html#lambda</a></p>
</div>
<div class="section" id="iterators-and-generators">
<h3><a class="toc-backref" href="#id83">1.7.3&nbsp;&nbsp;&nbsp;Iterators and generators</a></h3>
<p>Concepts:</p>
<dl class="docutils">
<dt>iterator</dt>
<dd>And iterator is something that satisfies the iterator protocol.
Clue: If it's an iterator, you can use it in a <tt class="docutils literal">for:</tt>
statement.</dd>
<dt>generator</dt>
<dd>A generator is a class or function that implements an
iterator, i.e. that implements the iterator protocol.</dd>
<dt>the iterator protocol</dt>
<dd><p class="first">An object satisfies the iterator protocol if it does the
following:</p>
<ul class="last simple">
<li>It implements a <tt class="docutils literal">__iter__</tt> method, which returns an iterator
object.</li>
<li>It implements a <tt class="docutils literal">next</tt> function, which returns the next item
from the collection, sequence, stream, etc of items to be
iterated over</li>
<li>It raises the <tt class="docutils literal">StopIteration</tt> exception when the items are
exhausted and the <tt class="docutils literal">next()</tt> method is called.</li>
</ul>
</dd>
<dt><tt class="docutils literal">yield</tt></dt>
<dd>The <tt class="docutils literal">yield</tt> statement enables us to write functions that are
generators.  Such functions may be similar to coroutines, since
they may &quot;yield&quot; multiple times and are resumed.</dd>
</dl>
<p>For more information on iterators, see <a class="reference external" href="http://docs.python.org/2/library/stdtypes.html#iterator-types">the section on iterator
types in the Python Library Reference --
http://docs.python.org/2/library/stdtypes.html#iterator-types</a>.</p>
<p>For more on the <tt class="docutils literal">yield</tt> statement, see:
<a class="reference external" href="http://docs.python.org/2/reference/simple_stmts.html#the-yield-statement">http://docs.python.org/2/reference/simple_stmts.html#the-yield-statement</a></p>
<p>Actually, <tt class="docutils literal">yield</tt> is an expression.  For more on yield expressions
and on the <tt class="docutils literal">next()</tt> and <tt class="docutils literal">send()</tt> generator methods, as well as
others, see: <a class="reference external" href="http://docs.python.org/2/reference/expressions.html#yield-expressions">Yield expression --
http://docs.python.org/2/reference/expressions.html#yield-expressions</a>
in the Python
language reference manual.</p>
<p>A function or method containing a <tt class="docutils literal">yield</tt> statement implements a
generator.  Adding the <tt class="docutils literal">yield</tt> statement to a function or method
turns that function or method into one which, when called, returns
a generator, i.e. an object that implements the iterator protocol.</p>
<p>A generator (a function containing <tt class="docutils literal">yield</tt>) provides a convenient
way to implement a filter.  But, also consider:</p>
<ul class="simple">
<li>The <tt class="docutils literal">filter()</tt> built-in function</li>
<li>List comprehensions with an <tt class="docutils literal">if</tt> clause</li>
</ul>
<p>Here are a few examples:</p>
<pre class="literal-block">
def simplegenerator():
    yield 'aaa'                          # Note 1
    yield 'bbb'
    yield 'ccc'

def list_tripler(somelist):
    for item in somelist:
        item *= 3
        yield item

def limit_iterator(somelist, max):
    for item in somelist:
        if item &gt; max:
            return                       # Note 2
        yield item

def test():
    print '1.', '-' * 30
    it = simplegenerator()
    for item in it:
        print item
    print '2.', '-' * 30
    alist = range(5)
    it = list_tripler(alist)
    for item in it:
        print item
    print '3.', '-' * 30
    alist = range(8)
    it = limit_iterator(alist, 4)
    for item in it:
        print item
    print '4.', '-' * 30
    it = simplegenerator()
    try:
        print it.next()                  # Note 3
        print it.next()
        print it.next()
        print it.next()
    except StopIteration, exp:           # Note 4
        print 'reached end of sequence'

if __name__ == '__main__':
    test()
</pre>
<p>Notes:</p>
<ol class="arabic simple">
<li>The <tt class="docutils literal">yield</tt> statement returns a value.  When the next item is
requested and the iterator is &quot;resumed&quot;, execution continues
immediately after the <tt class="docutils literal">yield</tt> statement.</li>
<li>We can terminate the sequence generated by an iterator by using a
<tt class="docutils literal">return</tt> statement with no value.</li>
<li>To resume a generator, use the generator's <tt class="docutils literal">next()</tt> or
<tt class="docutils literal">send()</tt> methods.  <tt class="docutils literal">send()</tt> is like <tt class="docutils literal">next()</tt>, but provides
a value to the yield expression.</li>
<li>We can alternatively obtain the items in a sequence by calling
the iterator's <tt class="docutils literal">next()</tt> method.  Since an iterator is a
first-class object, we can save it in a data structure and can
pass it around for use at different locations and times in our
program.</li>
</ol>
<ol class="arabic simple" start="6">
<li>When an iterator is exhausted or empty, it throws the
<tt class="docutils literal">StopIteration</tt> exception, which we can catch.</li>
</ol>
<p>And here is the output from running the above example:</p>
<pre class="literal-block">
$ python test_iterator.py
1. ------------------------------
aaa
bbb
ccc
2. ------------------------------
0
3
6
9
12
3. ------------------------------
0
1
2
3
4
4. ------------------------------
aaa
bbb
ccc
reached end of sequence
</pre>
<p>An instance of a class which implements the <tt class="docutils literal">__iter__</tt> method,
returning an iterator, is iterable.  For example, it can be used
in a <tt class="docutils literal">for</tt> statement or in a list comprehension, or in a
generator expression, or as an argument to the <tt class="docutils literal">iter()</tt> built-in
method.  But, notice that the class most likely implements a
generator method which can be called directly.</p>
<p>Examples -- The following code implements an iterator that
produces all the objects in a tree of objects:</p>
<pre class="literal-block">
class Node:
    def __init__(self, data, children=None):
        self.initlevel = 0
        self.data = data
        if children is None:
            self.children = []
        else:
            self.children = children
    def set_initlevel(self, initlevel): self.initlevel = initlevel
    def get_initlevel(self): return self.initlevel
    def addchild(self, child):
        self.children.append(child)
    def get_data(self):
        return self.data
    def get_children(self):
        return self.children
    def show_tree(self, level):
        self.show_level(level)
        print 'data: %s' % (self.data, )
        for child in self.children:
            child.show_tree(level + 1)
    def show_level(self, level):
        print '   ' * level,
    #
    # Generator method #1
    # This generator turns instances of this class into iterable objects.
    #
    def walk_tree(self, level):
        yield (level, self, )
        for child in self.get_children():
            for level1, tree1 in child.walk_tree(level+1):
                yield level1, tree1
    def __iter__(self):
        return self.walk_tree(self.initlevel)


#
# Generator method #2
# This generator uses a support function (walk_list) which calls
#   this function to recursively walk the tree.
# If effect, this iterates over the support function, which
#   iterates over this function.
#
def walk_tree(tree, level):
    yield (level, tree)
    for child in walk_list(tree.get_children(), level+1):
        yield child

def walk_list(trees, level):
    for tree in trees:
        for tree in walk_tree(tree, level):
            yield tree


#
# Generator method #3
# This generator is like method #2, but calls itself (as an iterator),
#   rather than calling a support function.
#
def walk_tree_recur(tree, level):
    yield (level, tree,)
    for child in tree.get_children():
        for level1, tree1 in walk_tree_recur(child, level+1):
            yield (level1, tree1, )


def show_level(level):
    print '   ' * level,


def test():
    a7 = Node('777')
    a6 = Node('666')
    a5 = Node('555')
    a4 = Node('444')
    a3 = Node('333', [a4, a5])
    a2 = Node('222', [a6, a7])
    a1 = Node('111', [a2, a3])
    initLevel = 2
    a1.show_tree(initLevel)
    print '=' * 40
    for level, item in walk_tree(a1, initLevel):
        show_level(level)
        print 'item:', item.get_data()
    print '=' * 40
    for level, item in walk_tree_recur(a1, initLevel):
        show_level(level)
        print 'item:', item.get_data()
    print '=' * 40
    a1.set_initlevel(initLevel)
    for level, item in a1:
        show_level(level)
        print 'item:', item.get_data()
    iter1 = iter(a1)
    print iter1
    print iter1.next()
    print iter1.next()
    print iter1.next()
    print iter1.next()
    print iter1.next()
    print iter1.next()
    print iter1.next()
##    print iter1.next()
    return a1

if __name__ == '__main__':
    test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>An instance of class <tt class="docutils literal">Node</tt> is &quot;iterable&quot;.  It can be used
directly in a <tt class="docutils literal">for</tt> statement, a list comprehension, etc.  So,
for example, when an instance of <tt class="docutils literal">Node</tt> is used in a <tt class="docutils literal">for</tt>
statement, it produces an iterator.</li>
<li>We could also call the <tt class="docutils literal">Node.walk_method</tt> directly to obtain
an iterator.</li>
<li>Method <tt class="docutils literal">Node.walk_tree</tt> and functions <tt class="docutils literal">walk_tree</tt> and
<tt class="docutils literal">walk_tree_recur</tt> are generators.  When called, they return an
iterator.  They do this because they each contain a <tt class="docutils literal">yield</tt>
statement.</li>
<li>These methods/functions are recursive.  They call themselves.
Since they are generators, they must call themselves in a context
that uses an iterator, for example in a <tt class="docutils literal">for</tt> statement.</li>
</ul>
</div>
<div class="section" id="modules">
<h3><a class="toc-backref" href="#id84">1.7.4&nbsp;&nbsp;&nbsp;Modules</a></h3>
<p>A module is a Python source code file.</p>
<p>A module can be imported.  When imported, the module is evaluated,
and a module object is created.  The module object has
attributes. The following attributes are of special interest:</p>
<ul class="simple">
<li><tt class="docutils literal">__doc__</tt> -- The doc string of the module.</li>
<li><tt class="docutils literal">__name__</tt> -- The name of the module when the module is
imported, but the string &quot;__main__&quot; when the module is executed.</li>
<li>Other names that are created (bound) in the module.</li>
</ul>
<p>A module can be run.</p>
<p>To make a module both import-able and run-able, use the following
idiom (at the end of the module):</p>
<pre class="literal-block">
def main():
    o
    o
    o

if __name__ == '__main__':
    main()
</pre>
<p>Where Python looks for modules:</p>
<ul class="simple">
<li>See <tt class="docutils literal">sys.path</tt>.</li>
<li>Standard places.</li>
<li>Environment variable <tt class="docutils literal">PYTHONPATH</tt>.</li>
</ul>
<p>Notes about modules and objects:</p>
<ul class="simple">
<li>A module is an object.</li>
<li>A module (object) can be shared.</li>
<li>A specific module is imported only once in a single run.  This
means that a single module object is shared by all the modules
that import it.</li>
</ul>
<div class="section" id="doc-strings-for-modules">
<h4><a class="toc-backref" href="#id85">1.7.4.1&nbsp;&nbsp;&nbsp;Doc strings for modules</a></h4>
<p>Add docstrings as a triple-quoted string at or near the top of the
file. See <a class="reference external" href="http://epydoc.sourceforge.net/">epydoc</a> for a suggested format.</p>
</div>
</div>
<div class="section" id="packages">
<h3><a class="toc-backref" href="#id86">1.7.5&nbsp;&nbsp;&nbsp;Packages</a></h3>
<p>A package is a directory on the file system which contains a file
named <tt class="docutils literal">__init__.py</tt>.</p>
<p>The <tt class="docutils literal">__init__.py</tt> file:</p>
<ul>
<li><p class="first">Why is it there? -- It makes modules in the directory
&quot;import-able&quot;.</p>
</li>
<li><p class="first">Can <tt class="docutils literal">__init__.py</tt> be empty? -- Yes.  Or, just include a
comment.</p>
</li>
<li><p class="first">When is it evaluated? -- It is evaluated the first time that an
application imports anything from that directory/package.</p>
</li>
<li><p class="first">What can you do with it? -- Any code that should be executed
exactly once and during import.  For example:</p>
<ul class="simple">
<li>Perform initialization needed by the package.</li>
<li>Make variables, functions, classes, etc available.  For
example, when the package is imported rather than modules in
the package.  You can also expose objects defined in modules
contained in the package.</li>
</ul>
</li>
<li><p class="first">Define a variable named <tt class="docutils literal">__all__</tt> to specify the list of names
that will be imported by <tt class="docutils literal">from my_package import *</tt>.  For
example, if the following is present in
<tt class="docutils literal">my_package/__init__.py</tt>:</p>
<pre class="literal-block">
__all__ = ['func1', 'func2',]
</pre>
<p>Then, <tt class="docutils literal">from my_package import *</tt> will import <tt class="docutils literal">func1</tt> and
<tt class="docutils literal">func2</tt>, but not other names defined in <tt class="docutils literal">my_package</tt>.</p>
<p>Note that <tt class="docutils literal">__all__</tt> can be used at the module level, as well
as at the package level.</p>
</li>
</ul>
<p>For more information, see the section on packages in the Python
tutorial: <a class="reference external" href="http://docs.python.org/2/tutorial/modules.html#packages">http://docs.python.org/2/tutorial/modules.html#packages</a>.</p>
<p>Guidance and suggestions:</p>
<ul>
<li><p class="first">&quot;Flat is better&quot; -- Use the <tt class="docutils literal">__init__.py</tt> file to present a
&quot;flat&quot; view of the API for your code.  Enable your users to do
<tt class="docutils literal">import mypackage</tt> and then reference:</p>
<ul class="simple">
<li><tt class="docutils literal">mypackage.item1</tt></li>
<li><tt class="docutils literal">mypackage.item2</tt></li>
<li><tt class="docutils literal">mypackage.item3</tt></li>
<li>Etc.</li>
</ul>
<p>Where <tt class="docutils literal">item1</tt>, <tt class="docutils literal">item2</tt>, etc compose the API you want your
users to use, even though the implementation of these items may be
buried deep in your code.</p>
</li>
<li><p class="first">Use the <tt class="docutils literal">__init__.py</tt> module to present a &quot;clean&quot; API.  Present
only the items that you intend your users to use, and by doing so,
&quot;hide&quot; items you do <em>not</em> intend them to use.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="classes">
<h2><a class="toc-backref" href="#id87">1.8&nbsp;&nbsp;&nbsp;Classes</a></h2>
<p>Classes model the behavior of objects in the &quot;real&quot; world. Methods
implement the behaviors of these types of objects.  Member
variables hold (current) state.  Classes enable us to implement new
data types in Python.</p>
<p>The <tt class="docutils literal">class:</tt> statement is used to define a class.  The <tt class="docutils literal">class:</tt>
statement creates a class object and binds it to a name.</p>
<div class="section" id="a-simple-class">
<h3><a class="toc-backref" href="#id88">1.8.1&nbsp;&nbsp;&nbsp;A simple class</a></h3>
<pre class="literal-block">
In [104]: class A:
   .....:     pass
   .....:
In [105]: a = A()
</pre>
<p>To define a new style class (recommended), inherit from <tt class="docutils literal">object</tt> or
from another class that does.  Example:</p>
<pre class="literal-block">
In [21]: class A(object):
   ....:     pass
   ....:
In [22]:
In [22]: a = A()
In [23]: a
Out[23]: &lt;__main__.A object at 0x82fbfcc&gt;
</pre>
</div>
<div class="section" id="defining-methods">
<h3><a class="toc-backref" href="#id89">1.8.2&nbsp;&nbsp;&nbsp;Defining methods</a></h3>
<p>A method is a function defined in class scope and with first
parameter <tt class="docutils literal">self</tt>:</p>
<pre class="literal-block">
In [106]: class B(object):
   .....:     def show(self):
   .....:         print 'hello from B'
   .....:
In [107]: b = B()
In [108]: b.show()
hello from B
</pre>
<p>A method as we describe it here is more properly called an
<em>instance method</em>, in order to distinguish it from <em>class methods</em>
and <em>static methods</em>.</p>
</div>
<div class="section" id="the-constructor">
<h3><a class="toc-backref" href="#id90">1.8.3&nbsp;&nbsp;&nbsp;The constructor</a></h3>
<p>The constructor is a method named <tt class="docutils literal">__init__</tt>.</p>
<p>Exercise:  Define a class with a member variable <tt class="docutils literal">name</tt> and a
<tt class="docutils literal">show</tt> method.  Use <tt class="docutils literal">print</tt> to show the name.  Solution:</p>
<pre class="literal-block">
In [109]: class A(object):
   .....:       def __init__(self, name):
   .....:           self.name = name
   .....:       def show(self):
   .....:           print 'name: &quot;%s&quot;' % self.name
   .....:
In [111]: a = A('dave')
In [112]: a.show()
name: &quot;dave&quot;
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The <tt class="docutils literal">self</tt> variable is explicit.  It references the current
object, that is the object whose method is currently executing.</li>
<li>The spelling (&quot;self&quot;) is optional, but <em>everyone</em> spells it that
way.</li>
</ul>
</div>
<div class="section" id="member-variables">
<h3><a class="toc-backref" href="#id91">1.8.4&nbsp;&nbsp;&nbsp;Member variables</a></h3>
<p>Defining member variables -- Member variables are created with
assignment.  Example:</p>
<pre class="literal-block">
class A(object):
    def __init__(self, name):
        self.name = name
</pre>
<p>A small gotcha -- Do this:</p>
<pre class="literal-block">
In [28]: class A(object):
   ....:     def __init__(self, items=None):
   ....:         if items is None:
   ....:             self.items = []
   ....:         else:
   ....:             self.items = items
</pre>
<p>Do <em>not</em> do this:</p>
<pre class="literal-block">
In [29]: class B:
   ....:     def __init__(self, items=[]):   # wrong.  list ctor evaluated only once.
   ....:         self.items = items
</pre>
<p>In the second example, the <tt class="docutils literal">def</tt> statement and the list
constructor are evaluated only once.  Therefore, the item member
variable of all instances of class B, will share the same value,
which is most likely <em>not</em> what you want.</p>
</div>
<div class="section" id="calling-methods">
<h3><a class="toc-backref" href="#id92">1.8.5&nbsp;&nbsp;&nbsp;Calling methods</a></h3>
<ul>
<li><p class="first">Use the instance and the dot operator.</p>
</li>
<li><p class="first">Calling a method defined in the same class or a superclass:</p>
<ul>
<li><p class="first">From outside the class -- Use the instance:</p>
<pre class="literal-block">
some_object.some_method()
an_array_of_of_objects[1].another_method()
</pre>
</li>
<li><p class="first">From within the same class -- Use <tt class="docutils literal">self</tt>:</p>
<pre class="literal-block">
self.a_method()
</pre>
</li>
<li><p class="first">From with a subclass when the method is in the superclass and
there is a method with the same name in the current class -- Use
the class (name) or use <tt class="docutils literal">super</tt>:</p>
<pre class="literal-block">
SomeSuperClass.__init__(self, arg1, arg2) super(CurrentClass,
self).__init__(arg1, arg2)
</pre>
</li>
</ul>
</li>
<li><p class="first">Calling a method defined in a specific superclass -- Use the
class (name).</p>
</li>
</ul>
</div>
<div class="section" id="adding-inheritance">
<h3><a class="toc-backref" href="#id93">1.8.6&nbsp;&nbsp;&nbsp;Adding inheritance</a></h3>
<p>Referencing superclasses -- Use the built-in <tt class="docutils literal">super</tt> or the
explicit name of the superclass.  Use of <tt class="docutils literal">super</tt> is preferred.
For example:</p>
<pre class="literal-block">
In [39]: class B(A):
   ....:     def __init__(self, name, size):
   ....:         super(B, self).__init__(name)
   ....:         # A.__init__(self, name)    # an older alternative form
   ....:         self.size = size
</pre>
<p>The use of <tt class="docutils literal">super()</tt> may solve problems searching for the base
class when using multiple inheritance.  A better solution is to not
use multiple inheritance.</p>
<p>You can also use multiple inheritance.  But, it can cause confusion.
For example, in the following, class C inherits from both A and B:</p>
<pre class="literal-block">
class C(A, B):
    ...
</pre>
<p>Python searches superclasses MRO (method resolution order).  If
only single inheritance is involved, there is little confusion.  If
multiple inheritance is being used, the search order of super
classes can get complex -- see here:
<a class="reference external" href="http://www.python.org/download/releases/2.3/mro">http://www.python.org/download/releases/2.3/mro</a></p>
<p>For more information on inheritance, see the tutorial in the
standard Python documentation set: <a class="reference external" href="http://docs.python.org/2/tutorial/classes.html#inheritance">9.5 Inheritance</a>
and <a class="reference external" href="http://docs.python.org/2/tutorial/classes.html#multiple-inheritance">9.5.1 Multiple Inheritance</a>.</p>
<p>Watch out for problems with inheriting from multiple classes that
have a common base class.</p>
</div>
<div class="section" id="class-variables">
<h3><a class="toc-backref" href="#id94">1.8.7&nbsp;&nbsp;&nbsp;Class variables</a></h3>
<ul>
<li><p class="first">Also called static data.</p>
</li>
<li><p class="first">A class variable is shared by instances of the class.</p>
</li>
<li><p class="first">Define at class level with assignment.  Example:</p>
<pre class="literal-block">
class A(object):
    size = 5
    def get_size(self):
        return A.size
</pre>
</li>
<li><p class="first">Reference with <tt class="docutils literal">classname.variable</tt>.</p>
</li>
<li><p class="first">Caution: <tt class="docutils literal">self.variable = x</tt> creates a new member variable.</p>
</li>
</ul>
</div>
<div class="section" id="class-methods-and-static-methods">
<h3><a class="toc-backref" href="#id95">1.8.8&nbsp;&nbsp;&nbsp;Class methods and static methods</a></h3>
<p>Instance (plain) methods:</p>
<ul class="simple">
<li>An instance method receives the instance as its first argument.</li>
</ul>
<p>Class methods:</p>
<ul class="simple">
<li>A class method receives the class as its first argument.</li>
<li>Define class methods with built-in function <tt class="docutils literal">classmethod()</tt> or
with decorator <tt class="docutils literal">&#64;classmethod</tt>.</li>
<li>See the description of <tt class="docutils literal">classmethod()</tt> built-in function at
&quot;Built-in Functions&quot;:
<a class="reference external" href="http://docs.python.org/2/library/functions.html#classmethod">http://docs.python.org/2/library/functions.html#classmethod</a></li>
</ul>
<p>Static methods:</p>
<ul class="simple">
<li>A static method receives neither the instance nor the class as its
first argument.</li>
<li>Define static methods with built-in function <tt class="docutils literal">staticmethod()</tt> or
with decorator <tt class="docutils literal">&#64;staticmethod</tt>.</li>
<li>See the description of <tt class="docutils literal">staticmethod()</tt> built-in function at
&quot;Built-in Functions&quot;:
<a class="reference external" href="http://docs.python.org/2/library/functions.html#staticmethod">http://docs.python.org/2/library/functions.html#staticmethod</a></li>
</ul>
<p>Notes on decorators:</p>
<ul>
<li><p class="first">A decorator of the form <tt class="docutils literal">&#64;afunc</tt> is the same as <tt class="docutils literal">m =
afunc(m)</tt>.  So, this:</p>
<pre class="literal-block">
&#64;afunc
def m(self): pass
</pre>
<p>is the same as:</p>
<pre class="literal-block">
def m(self): pass
m = afunc(m)
</pre>
</li>
<li><p class="first">You can use decorators <tt class="docutils literal">&#64;classmethod</tt> and <tt class="docutils literal">&#64;staticmethod</tt>
(instead of the <tt class="docutils literal">classmethod()</tt> and <tt class="docutils literal">staticmethod()</tt> built-in
functions) to declare class methods and static methods.</p>
</li>
</ul>
<p>Example:</p>
<pre class="literal-block">
class B(object):

    Count = 0

    def dup_string(x):
        s1 = '%s%s' % (x, x,)
        return s1
    dup_string = staticmethod(dup_string)

    &#64;classmethod
    def show_count(cls, msg):
        print '%s  %d' % (msg, cls.Count, )

def test():
    print B.dup_string('abcd')
    B.show_count('here is the count: ')
</pre>
<p>An alternative way to implement &quot;static methods&quot; -- Use a &quot;plain&quot;,
module-level function.  For example:</p>
<pre class="literal-block">
In [1]: def inc_count():
   ...:         A.count += 1
   ...:
In [2]:
In [2]: def dec_count():
   ...:         A.count -= 1
   ...:
In [3]:
In [3]: class A:
   ...:         count = 0
   ...:     def get_count(self):
   ...:             return A.count
   ...:
In [4]:
In [4]: a = A()
In [5]: a.get_count()
Out[5]: 0
In [6]:
In [6]:
In [6]: inc_count()
In [7]: inc_count()
In [8]: a.get_count()
Out[8]: 2
In [9]:
In [9]: b = A()
In [10]: b.get_count()
Out[10]: 2
</pre>
</div>
<div class="section" id="properties">
<h3><a class="toc-backref" href="#id96">1.8.9&nbsp;&nbsp;&nbsp;Properties</a></h3>
<p>The property built-in function enables us to write classes in a way
that does not require a user of the class to use getters and setters.
Example:</p>
<pre class="literal-block">
class TestProperty(object):
    def __init__(self, description):
        self._description = description
    def _set_description(self, description):
        print 'setting description'
        self._description = description
    def _get_description(self):
        print 'getting description'
        return self._description
    description = property(_get_description, _set_description)
</pre>
<p>The <tt class="docutils literal">property</tt> built-in function is also a decorator.  So, the
following is equivalent to the above example:</p>
<pre class="literal-block">
class TestProperty(object):
    def __init__(self, description):
        self._description = description

    &#64;property
    def description(self):
        print 'getting description'
        return self._description

    &#64;description.setter
    def description(self, description):
        print 'setting description'
        self._description = description
</pre>
<p>Notes:</p>
<ul class="simple">
<li>We mark the instance variable as private by prefixing it with and
underscore.</li>
<li>The name of the instance variable and the name of the property
must be different.  If they are not, we get recursion and an
error.</li>
</ul>
<p>For more information on properties, see
<a class="reference external" href="http://docs.python.org/2/library/functions.html#property">Built-in Functions -- properties --
http://docs.python.org/2/library/functions.html#property</a></p>
</div>
<div class="section" id="interfaces">
<h3><a class="toc-backref" href="#id97">1.8.10&nbsp;&nbsp;&nbsp;Interfaces</a></h3>
<p>In Python, to implement an interface is to implement a method with a
specific name and a specific arguments.</p>
<p>&quot;Duck typing&quot; -- If it walks like a duck and quacks like a duck ...</p>
<p>One way to define an &quot;interface&quot; is to define a class containing
methods that have a header and a doc string but no implementation.</p>
<p>Additional notes on interfaces:</p>
<ul class="simple">
<li>Interfaces are not enforced.</li>
<li>A class does not have to implement <em>all</em> of an interface.</li>
</ul>
</div>
<div class="section" id="new-style-classes">
<h3><a class="toc-backref" href="#id98">1.8.11&nbsp;&nbsp;&nbsp;New-style classes</a></h3>
<p>A new-style class is one that subclasses <tt class="docutils literal">object</tt> or a class that
subclasses <tt class="docutils literal">object</tt> (that is, another new-style class).</p>
<p>You can subclass Python's built-in data-types.</p>
<ul>
<li><p class="first">A simple example -- the following class extends the list data-type:</p>
<pre class="literal-block">
class C(list):
  def get_len(self):
    return len(self)

c = C((11,22,33))
c.get_len()

c = C((11,22,33,44,55,66,77,88))
print c.get_len()
# Prints &quot;8&quot;.
</pre>
</li>
<li><p class="first">A slightly more complex example -- the following class extends the
dictionary data-type:</p>
<pre class="literal-block">
class D(dict):
    def __init__(self, data=None, name='no_name'):
        if data is None:
            data = {}
        dict.__init__(self, data)
        self.name = name
    def get_len(self):
        return len(self)
    def get_keys(self):
        content = []
        for key in self:
            content.append(key)
        contentstr = ', '.join(content)
        return contentstr
    def get_name(self):
        return self.name

def test():
    d = D({'aa': 111, 'bb':222, 'cc':333})
    # Prints &quot;3&quot;
    print d.get_len()
    # Prints &quot;'aa, cc, bb'&quot;
    print d.get_keys()
    # Prints &quot;no_name&quot;
    print d.get_name()
</pre>
</li>
</ul>
<p>Some things to remember about new-style classes:</p>
<ul class="simple">
<li>In order to be new-style, a class must inherit (directly or
indirectly) from <tt class="docutils literal">object</tt>.  Note that if you inherit from a
built-in type, you get this automatically.</li>
<li>New-style classes unify types and classes.</li>
<li>You can subclass (built-in) types such as dict, str, list,
file, etc.</li>
<li>The built-in types now provide factory functions: <tt class="docutils literal">dict()</tt>,
<tt class="docutils literal">str()</tt>, <tt class="docutils literal">int()</tt>, <tt class="docutils literal">file()</tt>, etc.</li>
<li>The built-in types are introspect-able -- Use <tt class="docutils literal">x.__class__</tt>,
<tt class="docutils literal">dir(x.__class__)</tt>, <tt class="docutils literal">isinstance(x, list)</tt>, etc.</li>
<li>New-style classes give you properties and descriptors.</li>
<li>New-style classes enable you to define static methods.
Actually, all classes enable you to do this.</li>
<li>A new-style class is a user-defined type. For an instance of a
new-style class x, <tt class="docutils literal">type(x)</tt> is the same as <tt class="docutils literal">x.__class__</tt>.</li>
</ul>
<p>For more on new-style classes, see:
<a class="reference external" href="http://www.python.org/doc/newstyle/">http://www.python.org/doc/newstyle/</a></p>
<p>Exercises:</p>
<ul>
<li><p class="first">Write a class and a subclass of this class.</p>
<ul class="simple">
<li>Give the superclass one member variable, a name, which can be
entered when an instance is constructed.</li>
<li>Give the subclass one member variable, a description; the
subclass constructor should allow entry of both name and
description.</li>
<li>Put a <tt class="docutils literal">show()</tt> method in the superclass and override the
<tt class="docutils literal">show()</tt> method in the subclass.</li>
</ul>
<p>Solution:</p>
<pre class="literal-block">
class A(object):
    def __init__(self, name):
        self.name = name
    def show(self):
        print 'name: %s' % (self.name, )

class B(A):
    def __init__(self, name, desc):
        A.__init__(self, name)
        self.desc = desc
    def show(self):
        A.show(self)
        print 'desc: %s' % (self.desc, )
</pre>
</li>
</ul>
</div>
<div class="section" id="doc-strings-for-classes">
<h3><a class="toc-backref" href="#id99">1.8.12&nbsp;&nbsp;&nbsp;Doc strings for classes</a></h3>
<p>Add docstrings as a (triple-quoted) string beginning with the first
line of a class.  See <a class="reference external" href="http://epydoc.sourceforge.net/">epydoc</a> for a suggested format.</p>
</div>
<div class="section" id="private-members">
<h3><a class="toc-backref" href="#id100">1.8.13&nbsp;&nbsp;&nbsp;Private members</a></h3>
<p>Add an leading underscore to a member name (method or data variable)
to &quot;suggest&quot; that the member is private.</p>
</div>
</div>
<div class="section" id="special-tasks">
<h2><a class="toc-backref" href="#id101">1.9&nbsp;&nbsp;&nbsp;Special Tasks</a></h2>
<div class="section" id="debugging-tools">
<h3><a class="toc-backref" href="#id102">1.9.1&nbsp;&nbsp;&nbsp;Debugging tools</a></h3>
<p><tt class="docutils literal">pdb</tt> -- The Python debugger:</p>
<ul>
<li><p class="first">Start the debugger by running an expression:</p>
<pre class="literal-block">
pdb.run('expression')
</pre>
<p>Example:</p>
<pre class="literal-block">
if __name__ == '__main__':
    import pdb
    pdb.run('main()')
</pre>
</li>
<li><p class="first">Start up the debugger at a specific location with the following:</p>
<pre class="literal-block">
import pdb; pdb.set_trace()
</pre>
<p>Example:</p>
<pre class="literal-block">
if __name__ == '__main__':
    import pdb
    pdb.set_trace()
    main()
</pre>
</li>
<li><p class="first">Get help from within the debugger.  For example:</p>
<pre class="literal-block">
(Pdb) help
(Pdb) help next
</pre>
</li>
</ul>
<p>Can also embed IPython into your code.  See
<a class="reference external" href="http://ipython.scipy.org/doc/manual/manual.html">http://ipython.scipy.org/doc/manual/manual.html</a>.</p>
<p><tt class="docutils literal">ipdb</tt> -- Also consider using <tt class="docutils literal">ipdb</tt> (and <tt class="docutils literal">IPython</tt>).  The
<tt class="docutils literal">ipdb</tt> debugger interactive prompt has some additional features,
for example, it does tab name completion.</p>
<p>Inspecting:</p>
<ul class="simple">
<li><tt class="docutils literal">import inspect</tt></li>
<li>See <a class="reference external" href="http://docs.python.org/lib/module-inspect.html">http://docs.python.org/lib/module-inspect.html</a>.</li>
<li>Don't forget to try <tt class="docutils literal">dir(obj)</tt> and <tt class="docutils literal">type(obj)</tt> and
<tt class="docutils literal">help(obj)</tt>, first.</li>
</ul>
<p>Miscellaneous tools:</p>
<ul class="simple">
<li><tt class="docutils literal">id(obj)</tt></li>
<li><tt class="docutils literal">globals()</tt> and <tt class="docutils literal">locals()</tt>.</li>
<li><tt class="docutils literal">dir(obj)</tt> -- Returns interesting names, but list is not
necessarily complete.</li>
<li><tt class="docutils literal">obj.__class__</tt></li>
<li><tt class="docutils literal">cls.__bases__</tt></li>
<li><tt class="docutils literal">obj.__class__.__bases__</tt></li>
<li><tt class="docutils literal">obj.__doc__</tt>.  But usually, <tt class="docutils literal">help(obj)</tt> is better.  It
produces the doc string.</li>
<li>Customize the representation of your class.  Define the
following methods in your class:<ul>
<li><tt class="docutils literal">__repr__()</tt> -- Called by (1) <tt class="docutils literal">repr()</tt>, (2) interactive
interpreter when representation is needed.</li>
<li><tt class="docutils literal">__str__()</tt> -- Called by (1) <tt class="docutils literal">str()</tt>, (2) string
formatting.</li>
</ul>
</li>
</ul>
<p><tt class="docutils literal">pdb</tt> is implemented with the <tt class="docutils literal">cmd</tt> module in the Python
standard library.  You can implement similar command line interfaces
by using <tt class="docutils literal">cmd</tt>.  See:
<a class="reference external" href="http://docs.python.org/lib/module-cmd.html">cmd -- Support for line-oriented command interpreters --
http://docs.python.org/lib/module-cmd.html</a>.</p>
</div>
<div class="section" id="file-input-and-output">
<h3><a class="toc-backref" href="#id103">1.9.2&nbsp;&nbsp;&nbsp;File input and output</a></h3>
<p>Create a file object.  Use <tt class="docutils literal">open()</tt>.</p>
<p>This example reads and prints each line of a file:</p>
<pre class="literal-block">
def test():
    f = file('tmp.py', 'r')
    for line in f:
        print 'line:', line.rstrip()
    f.close()

test()
</pre>
<p>Notes:</p>
<ul>
<li><p class="first">A text file is an iterable.  It iterates over the lines in a
file.  The following is a common idiom:</p>
<pre class="literal-block">
infile = file(filename, 'r')
for line in infile:
    process_a_line(line)
infile.close()
</pre>
</li>
<li><p class="first"><tt class="docutils literal">string.rstrip()</tt> strips new-line and other whitespace from
the right side of each line.  To strip new-lines only, but not
other whitespace, try <tt class="docutils literal"><span class="pre">rstrip('\n')</span></tt>.</p>
</li>
<li><p class="first">Other ways of reading from a file/stream object:
<tt class="docutils literal">my_file.read()</tt>, <tt class="docutils literal">my_file.readline()</tt>, <tt class="docutils literal">my_file.readlines()</tt>,</p>
</li>
</ul>
<p>This example writes lines of text to a file:</p>
<pre class="literal-block">
def test():
    f = file('tmp.txt', 'w')
    for ch in 'abcdefg':
        f.write(ch * 10)
        f.write('\n')
    f.close()

test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The <tt class="docutils literal">write</tt> method, unlike the <tt class="docutils literal">print</tt> statement, does not
automatically add new-line characters.</li>
<li>Must close file in order to flush output.  Or, use
<tt class="docutils literal">my_file.flush()</tt>.</li>
</ul>
<p>And, don't forget the <tt class="docutils literal">with:</tt> statement.  It makes closing files
automatic.  The following example converts all the vowels in an
input file to upper case and writes the converted lines to an output
file:</p>
<pre class="literal-block">
import string

def show_file(infilename, outfilename):
    tran_table = string.maketrans('aeiou', 'AEIOU')
    with open(infilename, 'r') as infile, open(outfilename, 'w') as outfile:
        for line in infile:
            line = line.rstrip()
            outfile.write('%s\n' % line.translate(tran_table))
</pre>
</div>
<div class="section" id="unit-tests">
<h3><a class="toc-backref" href="#id104">1.9.3&nbsp;&nbsp;&nbsp;Unit tests</a></h3>
<p>For more documentation on the unit test framework, see
<a class="reference external" href="http://docs.python.org/2/library/unittest.html#module-unittest">unittest -- Unit testing framework --
http://docs.python.org/2/library/unittest.html#module-unittest</a></p>
<p>For help and more information do the following at the Python
interactive prompt:</p>
<pre class="literal-block">
&gt;&gt;&gt; import unittest
&gt;&gt;&gt; help(unittest)
</pre>
<p>And, you can read the source: <tt class="docutils literal">Lib/unittest.py</tt> in the Python
standard library.</p>
<div class="section" id="a-simple-example">
<h4><a class="toc-backref" href="#id105">1.9.3.1&nbsp;&nbsp;&nbsp;A simple example</a></h4>
<p>Here is a very simple example.  You can find more information about
this primitive way of structuring unit tests in the library
documentation for the <tt class="docutils literal">unittest</tt> module
<a class="reference external" href="http://docs.python.org/lib/minimal-example.html">Basic example --
http://docs.python.org/lib/minimal-example.html</a></p>
<pre class="literal-block">
import unittest

class UnitTests02(unittest.TestCase):

    def testFoo(self):
        self.failUnless(False)

class UnitTests01(unittest.TestCase):

    def testBar01(self):
        self.failUnless(False)

    def testBar02(self):
        self.failUnless(False)

def main():
    unittest.main()

if __name__ == '__main__':
    main()
</pre>
<p>Notes:</p>
<ul>
<li><p class="first">The call to <tt class="docutils literal">unittest.main()</tt> runs all tests in all test
fixtures in the module.  It actually creates an instance of class
<tt class="docutils literal">TestProgram</tt> in module <tt class="docutils literal">Lib/unittest.py</tt>, which
automatically runs tests.</p>
</li>
<li><p class="first">Test fixtures are classes that inherit from
<tt class="docutils literal">unittest.TestCase</tt>.</p>
</li>
<li><p class="first">Within a test fixture (a class), the tests are any methods whose
names begin with the prefix &quot;test&quot;.</p>
</li>
<li><p class="first">In any test, we check for success or failure with inherited
methods such as <tt class="docutils literal">failIf()</tt>, <tt class="docutils literal">failUnless()</tt>,
<tt class="docutils literal">assertNotEqual()</tt>, etc.  For more on these methods, see the
library documentation for the
<tt class="docutils literal">unittest</tt> module <a class="reference external" href="http://docs.python.org/lib/testcase-objects.html">TestCase Objects --
http://docs.python.org/lib/testcase-objects.html</a>.</p>
</li>
<li><p class="first">If you want to change (1) the test method prefix or (2) the
function used to sort (the order of) execution of tests within a
test fixture, then you can create your own instance of class
<tt class="docutils literal">unittest.TestLoader</tt> and customize it.  For example:</p>
<pre class="literal-block">
def main():
    my_test_loader = unittest.TestLoader()
    my_test_loader.testMethodPrefix = 'check'
    my_test_loader.sortTestMethodsUsing = my_cmp_func
    unittest.main(testLoader=my_test_loader)

if __name__ == '__main__':
    main()
</pre>
<p><strong>But</strong>, see the notes in section <a class="reference internal" href="#additional-unittest-features">Additional unittest features</a>
for instructions on a (possibly) better way to do this.</p>
</li>
</ul>
</div>
<div class="section" id="unit-test-suites">
<h4><a class="toc-backref" href="#id106">1.9.3.2&nbsp;&nbsp;&nbsp;Unit test suites</a></h4>
<p>Here is another, not quite so simple, example:</p>
<pre class="literal-block">
#!/usr/bin/env python

import sys, popen2
import getopt
import unittest


class GenTest(unittest.TestCase):

    def test_1_generate(self):
        cmd = 'python ../generateDS.py -f -o out2sup.py -s out2sub.py people.xsd'
        outfile, infile = popen2.popen2(cmd)
        result = outfile.read()
        outfile.close()
        infile.close()
        self.failUnless(len(result) == 0)

    def test_2_compare_superclasses(self):
        cmd = 'diff out1sup.py out2sup.py'
        outfile, infile = popen2.popen2(cmd)
        outfile, infile = popen2.popen2(cmd)
        result = outfile.read()
        outfile.close()
        infile.close()
        #print 'len(result):', len(result)
        # Ignore the differing lines containing the date/time.
        #self.failUnless(len(result) &lt; 130 and result.find('Generated') &gt; -1)
        self.failUnless(check_result(result))

    def test_3_compare_subclasses(self):
        cmd = 'diff out1sub.py out2sub.py'
        outfile, infile = popen2.popen2(cmd)
        outfile, infile = popen2.popen2(cmd)
        result = outfile.read()
        outfile.close()
        infile.close()
        # Ignore the differing lines containing the date/time.
        #self.failUnless(len(result) &lt; 130 and result.find('Generated') &gt; -1)
        self.failUnless(check_result(result))


def check_result(result):
    flag1 = 0
    flag2 = 0
    lines = result.split('\n')
    len1 = len(lines)
    if len1 &lt;= 5:
        flag1 = 1
    s1 = '\n'.join(lines[:4])
    if s1.find('Generated') &gt; -1:
        flag2 = 1
    return flag1 and flag2


# Make the test suite.
def suite():
    # The following is obsolete.  See Lib/unittest.py.
    #return unittest.makeSuite(GenTest)
    loader = unittest.TestLoader()
    # or alternatively
    # loader = unittest.defaultTestLoader
    testsuite = loader.loadTestsFromTestCase(GenTest)
    return testsuite


# Make the test suite and run the tests.
def test():
    testsuite = suite()
    runner = unittest.TextTestRunner(sys.stdout, verbosity=2)
    runner.run(testsuite)


USAGE_TEXT = &quot;&quot;&quot;
Usage:
    python test.py [options]
Options:
    -h, --help      Display this help message.
Example:
    python test.py
&quot;&quot;&quot;

def usage():
    print USAGE_TEXT
    sys.exit(-1)


def main():
    args = sys.argv[1:]
    try:
        opts, args = getopt.getopt(args, 'h', ['help'])
    except:
        usage()
    relink = 1
    for opt, val in opts:
        if opt in ('-h', '--help'):
            usage()
    if len(args) != 0:
        usage()
    test()


if __name__ == '__main__':
    main()
    #import pdb
    #pdb.run('main()')
</pre>
<p>Notes:</p>
<ul class="simple">
<li><tt class="docutils literal">GenTest</tt> is our test suite class.  It inherits from
<tt class="docutils literal">unittest.TestCase</tt>.</li>
<li>Each method in <tt class="docutils literal">GenTest</tt> whose name begins with &quot;test&quot; will be
run as a test.</li>
<li>The tests are run in alphabetic order by method name.</li>
<li>Defaults in class <tt class="docutils literal">TestLoader</tt> for the test name prefix and
sort comparison function can be overridden. See
<a class="reference external" href="http://docs.python.org/lib/testloader-objects.html">5.3.8 TestLoader Objects</a> --
<a class="reference external" href="http://docs.python.org/lib/testloader-objects.html">http://docs.python.org/lib/testloader-objects.html</a>.</li>
<li>A test case class may also implement methods named <tt class="docutils literal">setUp()</tt>
and <tt class="docutils literal">tearDown()</tt> to be run before and after tests.  See
<a class="reference external" href="http://docs.python.org/lib/testcase-objects.html">5.3.5 TestCase Objects</a> --
<a class="reference external" href="http://docs.python.org/lib/testcase-objects.html">http://docs.python.org/lib/testcase-objects.html</a>.
Actually, the first test method in our example should, perhaps,
be a <tt class="docutils literal">setUp()</tt> method.</li>
<li>The tests use calls such as <tt class="docutils literal">self.failUnless()</tt> to report
errors.  These are inherited from class <tt class="docutils literal">TestCase</tt>.  See
<a class="reference external" href="http://docs.python.org/lib/testcase-objects.html">5.3.5 TestCase Objects</a> --
<a class="reference external" href="http://docs.python.org/lib/testcase-objects.html">http://docs.python.org/lib/testcase-objects.html</a>.</li>
<li>Function <tt class="docutils literal">suite()</tt> creates an instance of the test suite.</li>
<li>Function <tt class="docutils literal">test()</tt> runs the tests.</li>
</ul>
</div>
<div class="section" id="additional-unittest-features">
<h4><a class="toc-backref" href="#id107">1.9.3.3&nbsp;&nbsp;&nbsp;Additional unittest features</a></h4>
<p>And, the following example shows several additional features.  See
the notes that follow the code:</p>
<pre class="literal-block">
import unittest

class UnitTests02(unittest.TestCase):
    def testFoo(self):
        self.failUnless(False)
    def checkBar01(self):
        self.failUnless(False)


class UnitTests01(unittest.TestCase):
    # Note 1
    def setUp(self):
        print 'setting up UnitTests01'
    def tearDown(self):
        print 'tearing down UnitTests01'
    def testBar01(self):
        print 'testing testBar01'
        self.failUnless(False)
    def testBar02(self):
        print 'testing testBar02'
        self.failUnless(False)

def function_test_1():
    name = 'mona'
    assert not name.startswith('mo')

def compare_names(name1, name2):
    if name1 &lt; name2:
        return 1
    elif name1 &gt; name2:
        return -1
    else:
        return 0

def make_suite():
    suite = unittest.TestSuite()
    # Note 2
    suite.addTest(unittest.makeSuite(UnitTests01, sortUsing=compare_names))
    # Note 3
    suite.addTest(unittest.makeSuite(UnitTests02, prefix='check'))
    # Note 4
    suite.addTest(unittest.FunctionTestCase(function_test_1))
    return suite

def main():
    suite = make_suite()
    runner = unittest.TextTestRunner()
    runner.run(suite)

if __name__ == '__main__':
    main()
</pre>
<p>Notes:</p>
<ol class="arabic simple">
<li>If you run this code, you will notice that the <tt class="docutils literal">setUp</tt> and
<tt class="docutils literal">tearDown</tt> methods in class <tt class="docutils literal">UnitTests01</tt> are run before and
after each test in that class.</li>
<li>We can control the order in which tests are run by passing a
compare function to the <tt class="docutils literal">makeSuite</tt> function.  The default is
the <tt class="docutils literal">cmp</tt> built-in function.</li>
<li>We can control which methods in a test fixture are selected to be
run by passing the optional argument <tt class="docutils literal">prefix</tt> to the
<tt class="docutils literal">makeSuite</tt> function.</li>
<li>If we have an existing function that we want to &quot;wrap&quot; and run
as a unit test, we can create a test case from a function with
the <tt class="docutils literal">FunctionTestCase</tt> function.  If we do that, notice that
we use the <tt class="docutils literal">assert</tt> statement to test and possibly cause
failure.</li>
</ol>
</div>
<div class="section" id="guidance-on-unit-testing">
<h4><a class="toc-backref" href="#id108">1.9.3.4&nbsp;&nbsp;&nbsp;Guidance on Unit Testing</a></h4>
<p>Why should we use unit tests?  Many reasons, including:</p>
<ul class="simple">
<li>Without unit tests, corner cases may not be checked.  This is
especially important, since Python does relatively little
compile time error checking.</li>
<li>Unit tests facilitate a frequent and short design and implement
and release development cycle.  See
<a class="reference external" href="http://www.onlamp.com/pub/a/python/2001/03/28/pythonnews.html">ONLamp.com -- Extreme Python --
http://www.onlamp.com/pub/a/python/2001/03/28/pythonnews.html</a>
and
<a class="reference external" href="http://www.xprogramming.com/what_is_xp.htm">What is XP --
http://www.xprogramming.com/what_is_xp.htm</a>.</li>
<li>Designing the tests before writing the code is &quot;a good idea&quot;.</li>
</ul>
<p>Additional notes:</p>
<ul>
<li><p class="first">In a test class, instance methods <tt class="docutils literal">setUp</tt> and <tt class="docutils literal">tearDown</tt> are run
automatically before each and after each individual test.</p>
</li>
<li><p class="first">In a test class, class methods <tt class="docutils literal">setUpClass</tt> and <tt class="docutils literal">tearDownClass</tt> are run
automatically <em>once</em> before and after <em>all</em> the tests in a class.</p>
</li>
<li><p class="first">Module level functions <tt class="docutils literal">setUpModule</tt> and <tt class="docutils literal">tearDownModule</tt> are
run before and after any tests in a module.</p>
</li>
<li><p class="first">In some cases you can also run tests directly from the command
line.  Do the following for help:</p>
<pre class="literal-block">
$ python -m unittest --help
</pre>
</li>
</ul>
</div>
</div>
<div class="section" id="doctest">
<h3><a class="toc-backref" href="#id109">1.9.4&nbsp;&nbsp;&nbsp;doctest</a></h3>
<p>For simple test harnesses, consider using <tt class="docutils literal">doctest</tt>.  With
<tt class="docutils literal">doctest</tt> you can (1) run a test at the Python interactive
prompt, then (2) copy and paste that test into a doc string in
your module, and then (3) run the tests automatically from within
your module under <tt class="docutils literal">doctest</tt>.</p>
<p>There are examples and explanation in the standard Python
documentation:
<a class="reference external" href="http://docs.python.org/lib/module-doctest.html">5.2 doctest -- Test interactive Python examples</a> --
<a class="reference external" href="http://docs.python.org/lib/module-doctest.html">http://docs.python.org/lib/module-doctest.html</a>.</p>
<p>A simple way to use <tt class="docutils literal">doctest</tt> in your module:</p>
<ol class="arabic">
<li><p class="first">Run several tests in the Python interactive interpreter.  Note
that because <tt class="docutils literal">doctest</tt> looks for the interpreter's &quot;&gt;&gt;&gt;&quot;
prompt, you must use the standard interpreter, and not, for
example, IPython.  Also, make sure that you include a line with
the &quot;&gt;&gt;&gt;&quot; prompt after each set of results; this enables
<tt class="docutils literal">doctest</tt> to determine the extent of the test results.</p>
</li>
<li><p class="first">Use copy and paste, to insert the tests and their results from
your interactive session into the docstrings.</p>
</li>
<li><p class="first">Add the following code at the bottom of your module:</p>
<pre class="literal-block">
def _test():
    import doctest
    doctest.testmod()

if __name__ == &quot;__main__&quot;:
    _test()
</pre>
</li>
</ol>
<p>Here is an example:</p>
<pre class="literal-block">
def f(n):
    &quot;&quot;&quot;
    Print something funny.

    &gt;&gt;&gt; f(1)
    10
    &gt;&gt;&gt; f(2)
    -10
    &gt;&gt;&gt; f(3)
    0
    &quot;&quot;&quot;
    if n == 1:
        return 10
    elif n == 2:
        return -10
    else:
        return 0


def test():
    import doctest, test_doctest
    doctest.testmod(test_doctest)

if __name__ == '__main__':
    test()
</pre>
<p>And, here is the output from running the above test with the <tt class="docutils literal"><span class="pre">-v</span></tt>
flag:</p>
<pre class="literal-block">
$ python test_doctest.py -v
Running test_doctest.__doc__
0 of 0 examples failed in test_doctest.__doc__
Running test_doctest.f.__doc__
Trying: f(1)
Expecting: 10
ok
Trying: f(2)
Expecting: -10
ok
Trying: f(3)
Expecting: 0
ok
0 of 3 examples failed in test_doctest.f.__doc__
Running test_doctest.test.__doc__
0 of 0 examples failed in test_doctest.test.__doc__
2 items had no tests:
    test_doctest
    test_doctest.test
1 items passed all tests:
   3 tests in test_doctest.f
3 tests in 3 items.
3 passed and 0 failed.
Test passed.
</pre>
</div>
<div class="section" id="the-python-database-api">
<h3><a class="toc-backref" href="#id110">1.9.5&nbsp;&nbsp;&nbsp;The Python database API</a></h3>
<p>Python database API defines a standard interface for access to a
relational database.</p>
<p>In order to use this API you must install the database adapter
(interface module) for your particular database, e.g. PostgreSQL,
MySQL, Oracle, etc.</p>
<p>You can learn more about the Python DB-API here:
<a class="reference external" href="http://www.python.org/dev/peps/pep-0249/">http://www.python.org/dev/peps/pep-0249/</a></p>
<p>The following simple example uses <a class="reference external" href="http://docs.python.org/2/library/sqlite3.html#module-sqlite3">sqlite3 --
http://docs.python.org/2/library/sqlite3.html</a></p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;
Create a relational database and a table in it.
Add some records.
Read and display the records.
&quot;&quot;&quot;

import sys
import sqlite3

def create_table(db_name):
    con = sqlite3.connect(db_name)
    cursor = con.cursor()
    cursor.execute('''CREATE TABLE plants
    (name text, desc text, cat int)''')
    cursor.execute(
        '''INSERT INTO plants VALUES ('tomato', 'red and juicy', 1)''')
    cursor.execute(
        '''INSERT INTO plants VALUES ('pepper', 'green and crunchy', 2)''')
    cursor.execute('''INSERT INTO plants VALUES ('pepper', 'purple', 2)''')
    con.commit()
    con.close()

def retrieve(db_name):
    con = sqlite3.connect(db_name)
    cursor = con.cursor()
    cursor.execute('''select * from plants''')
    rows = cursor.fetchall()
    print rows
    print '-' * 40
    cursor.execute('''select * from plants''')
    for row in cursor:
        print row
    con.close()

def test():
    args = sys.argv[1:]
    if len(args) != 1:
        sys.stderr.write('\nusage: test_db.py &lt;db_name&gt;\n\n')
        sys.exit(1)
    db_name = args[0]
    create_table(db_name)
    retrieve(db_name)

test()
</pre>
</div>
<div class="section" id="installing-python-packages">
<h3><a class="toc-backref" href="#id111">1.9.6&nbsp;&nbsp;&nbsp;Installing Python packages</a></h3>
<p>Simple:</p>
<pre class="literal-block">
$ python setup.py build
$ python setup.py install    # as root
</pre>
<p>More complex:</p>
<ul>
<li><p class="first">Look for a <tt class="docutils literal">README</tt> or <tt class="docutils literal">INSTALL</tt> file at the root of the
package.</p>
</li>
<li><p class="first">Type the following for help:</p>
<pre class="literal-block">
$ python setup.py cmd --help
$ python setup.py --help-commands
$ python setup.py --help [cmd1 cmd2 ...]
</pre>
</li>
<li><p class="first">And, for even more details, see
<a class="reference external" href="http://docs.python.org/inst/inst.html">Installing Python Modules --
http://docs.python.org/inst/inst.html</a></p>
</li>
</ul>
<p><tt class="docutils literal">pip</tt> is becoming popular for installing and managing Python
packages.  See: <a class="reference external" href="https://pypi.python.org/pypi/pip">https://pypi.python.org/pypi/pip</a></p>
<p>Also, consider using <tt class="docutils literal">virtualenv</tt>, especially if you suspect or
worry that installing some new package will alter the behavior of a
package currently installed on your machine.  See:
<a class="reference external" href="https://pypi.python.org/pypi/virtualenv">https://pypi.python.org/pypi/virtualenv</a>.  <tt class="docutils literal">virtualenv</tt> creates a
directory and sets up a Python environment into which you can
install and use Python packages without changing your usual Python
installation.</p>
</div>
</div>
<div class="section" id="more-python-features-and-exercises">
<h2><a class="toc-backref" href="#id112">1.10&nbsp;&nbsp;&nbsp;More Python Features and Exercises</a></h2>
<p>[As time permits, explain more features and do more exercises as
requested by class members.]</p>
<p>Thanks to David Goodger for the following list or references.  His
&quot;Code Like a Pythonista: Idiomatic Python&quot;
(<a class="reference external" href="http://python.net/~goodger/projects/pycon/2007/idiomatic/">http://python.net/~goodger/projects/pycon/2007/idiomatic/</a>) is worth
a careful reading:</p>
<ul class="simple">
<li>&quot;Python Objects&quot;, Fredrik Lundh,
<a class="reference external" href="http://www.effbot.org/zone/python-objects.htm">http://www.effbot.org/zone/python-objects.htm</a></li>
<li>&quot;How to think like a Pythonista&quot;, Mark Hammond,
<a class="reference external" href="http://python.net/crew/mwh/hacks/objectthink.html">http://python.net/crew/mwh/hacks/objectthink.html</a></li>
<li>&quot;Python main() functions&quot;, Guido van Rossum,
<a class="reference external" href="http://www.artima.com/weblogs/viewpost.jsp?thread=4829">http://www.artima.com/weblogs/viewpost.jsp?thread=4829</a></li>
<li>&quot;Python Idioms and Efficiency&quot;,
<a class="reference external" href="http://jaynes.colorado.edu/PythonIdioms.html">http://jaynes.colorado.edu/PythonIdioms.html</a></li>
<li>&quot;Python track: python idioms&quot;,
<a class="reference external" href="http://www.cs.caltech.edu/courses/cs11/material/python/misc/python_idioms.html">http://www.cs.caltech.edu/courses/cs11/material/python/misc/python_idioms.html</a></li>
<li>&quot;Be Pythonic&quot;, Shalabh Chaturvedi,
<a class="reference external" href="http://shalabh.infogami.com/Be_Pythonic2">http://shalabh.infogami.com/Be_Pythonic2</a></li>
<li>&quot;Python Is Not Java&quot;, Phillip J. Eby,
<a class="reference external" href="http://dirtsimple.org/2004/12/python-is-not-java.html">http://dirtsimple.org/2004/12/python-is-not-java.html</a></li>
<li>&quot;What is Pythonic?&quot;, Martijn Faassen,
<a class="reference external" href="http://faassen.n--tree.net/blog/view/weblog/2005/08/06/0">http://faassen.n--tree.net/blog/view/weblog/2005/08/06/0</a></li>
<li>&quot;Sorting Mini-HOWTO&quot;, Andrew Dalke,
<a class="reference external" href="http://wiki.python.org/moin/HowTo/Sorting">http://wiki.python.org/moin/HowTo/Sorting</a></li>
<li>&quot;Python Idioms&quot;, <a class="reference external" href="http://www.gungfu.de/facts/wiki/Main/PythonIdioms">http://www.gungfu.de/facts/wiki/Main/PythonIdioms</a></li>
<li>&quot;Python FAQs&quot;, <a class="reference external" href="http://www.python.org/doc/faq/">http://www.python.org/doc/faq/</a></li>
</ul>
<!-- Configuration for Emacs -->
<!-- Aternative mode: indented-text -->
<!-- Local Variables:
mode: rst
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 68
End: -->
</div>
</div>
<hr class="docutils" />
<div class="section" id="part-2-advanced-python">
<h1><a class="toc-backref" href="#id113">2&nbsp;&nbsp;&nbsp;Part 2 -- Advanced Python</a></h1>
<div class="section" id="introduction-python-201-slightly-advanced-python-topics">
<h2><a class="toc-backref" href="#id114">2.1&nbsp;&nbsp;&nbsp;Introduction -- Python 201 -- (Slightly) Advanced Python Topics</a></h2>
<p>This document is intended as notes for a course on (slightly) advanced Python
topics.</p>
</div>
<div class="section" id="regular-expressions">
<h2><a class="toc-backref" href="#id115">2.2&nbsp;&nbsp;&nbsp;Regular Expressions</a></h2>
<p>For more help on regular expressions, see:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.python.org/library/re.html">re - Regular expression operations
http://docs.python.org/library/re.html</a></li>
<li><a class="reference external" href="http://docs.python.org/howto/regex.html">Regular Expression HOWTO --
http://docs.python.org/howto/regex.html</a></li>
</ul>
<div class="section" id="defining-regular-expressions">
<h3><a class="toc-backref" href="#id116">2.2.1&nbsp;&nbsp;&nbsp;Defining regular expressions</a></h3>
<p>A regular expression pattern is a sequence of characters
that will match sequences of characters in a target.</p>
<p>The patterns or regular expressions can be defined as follows:</p>
<ul class="simple">
<li>Literal characters must match exactly. For example, &quot;a&quot; matches
&quot;a&quot;.</li>
<li>Concatenated patterns match concatenated targets. For example, &quot;ab&quot;
(&quot;a&quot; followed by &quot;b&quot;) matches &quot;ab&quot;.</li>
<li>Alternate patterns (separated by a vertical bar) match either of
the alternative patterns. For example, &quot;(aaa)|(bbb)&quot; will match
either &quot;aaa&quot; or &quot;bbb&quot;.</li>
<li>Repeating and optional items:<ul>
<li>&quot;abc*&quot; matches &quot;ab&quot; followed by zero or more occurances of &quot;c&quot;, for
example, &quot;ab&quot;, &quot;abc&quot;, &quot;abcc&quot;, etc.</li>
<li>&quot;abc+&quot; matches &quot;ab&quot; followed by one or more occurances of &quot;c&quot;, for
example, &quot;abc&quot;, &quot;abcc&quot;, etc, but not &quot;ab&quot;.</li>
<li>&quot;abc?&quot; matches &quot;ab&quot; followed by zero or one occurances of &quot;c&quot;, for
example, &quot;ab&quot; or &quot;abc&quot;.</li>
</ul>
</li>
<li>Sets of characters -- Characters and sequences of characters in
square brackets form a set; a set matches any character in the set
or range. For example, &quot;[abc]&quot; matches &quot;a&quot; or &quot;b&quot; or &quot;c&quot;. And, for
example, &quot;[_a-z0-9]&quot; matches an underscore or any lower-case letter
or any digit.</li>
<li>Groups -- Parentheses indicate a group with a pattern. For example,
&quot;ab(cd)*ef&quot; is a pattern that matches &quot;ab&quot; followed by any number of
occurances of &quot;cd&quot; followed by &quot;ef&quot;, for example, &quot;abef&quot;, &quot;abcdef&quot;,
&quot;abcdcdef&quot;, etc.</li>
<li>There are special names for some sets of characters, for example
&quot;\d&quot; (any digit), &quot;\w&quot; (any alphanumeric character), &quot;\W&quot; (any
non-alphanumeric character), etc.  More more information, see
Python Library Reference: <a class="reference external" href="http://docs.python.org/library/re.html#regular-expression-syntax">Regular Expression Syntax --
http://docs.python.org/library/re.html#regular-expression-syntax</a></li>
</ul>
<p>Because of the use of backslashes in patterns, you are usually better
off defining regular expressions with raw strings, e.g. <tt class="docutils literal">r&quot;abc&quot;</tt>.</p>
</div>
<div class="section" id="compiling-regular-expressions">
<h3><a class="toc-backref" href="#id117">2.2.2&nbsp;&nbsp;&nbsp;Compiling regular expressions</a></h3>
<p>When a regular expression is to be used more than once, you should
consider compiling it. For example:</p>
<pre class="literal-block">
import sys, re

pat = re.compile('aa[bc]*dd')

while 1:
    line = raw_input('Enter a line (&quot;q&quot; to quit):')
    if line == 'q':
        break
    if pat.search(line):
        print 'matched:', line
    else:
        print 'no match:', line
</pre>
<p>Comments:</p>
<ul class="simple">
<li>We import module re in order to use regular expresions.</li>
<li><tt class="docutils literal">re.compile()</tt> compiles a regular expression so that we can
reuse the compiled regular expression without compiling it
repeatedly.</li>
</ul>
</div>
<div class="section" id="using-regular-expressions">
<h3><a class="toc-backref" href="#id118">2.2.3&nbsp;&nbsp;&nbsp;Using regular expressions</a></h3>
<p>Use <tt class="docutils literal">match()</tt> to match at the beginning of a string (or not at
all).</p>
<p>Use <tt class="docutils literal">search()</tt> to search a string and match the first string from
the left.</p>
<p>Here are some examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; import re
&gt;&gt;&gt; pat = re.compile('aa[0-9]*bb')
&gt;&gt;&gt; x = pat.match('aa1234bbccddee')
&gt;&gt;&gt; x
&lt;_sre.SRE_Match object at 0x401e9608&gt;
&gt;&gt;&gt; x = pat.match('xxxxaa1234bbccddee')
&gt;&gt;&gt; x
&gt;&gt;&gt; type(x)
&lt;type 'NoneType'&gt;
&gt;&gt;&gt; x = pat.search('xxxxaa1234bbccddee')
&gt;&gt;&gt; x
&lt;_sre.SRE_Match object at 0x401e9608&gt;
</pre>
<p>Notes:</p>
<ul>
<li><p class="first">When a match or search is successful, it returns a match
object. When it fails, it returns None.</p>
</li>
<li><p class="first">You can also call the corresponding functions match and search in
the re module, e.g.:</p>
<pre class="literal-block">
&gt;&gt;&gt; x = re.search(pat, 'xxxxaa1234bbccddee')
&gt;&gt;&gt; x
&lt;_sre.SRE_Match object at 0x401e9560&gt;
</pre>
<p>For a list of functions in the re module, see
<a class="reference external" href="http://docs.python.org/library/re.html#module-contents">Module Contents --
http://docs.python.org/library/re.html#module-contents</a>.</p>
</li>
</ul>
</div>
<div class="section" id="using-match-objects-to-extract-a-value">
<h3><a class="toc-backref" href="#id119">2.2.4&nbsp;&nbsp;&nbsp;Using match objects to extract a value</a></h3>
<p>Match objects enable you to extract matched sub-strings after
performing a match.  A match object is returned by successful
match.  The part of the target available in the match object is the
portion matched by groups in the pattern, that is the portion of the
pattern inside parentheses.  For example:</p>
<pre class="literal-block">
In [69]: mo = re.search(r'height: (\d*) width: (\d*)', 'height: 123 width: 456')
In [70]: mo.groups()
Out[70]: ('123', '456')
</pre>
<p>Here is another example:</p>
<pre class="literal-block">
import sys, re

Targets = [
    'There are &lt;&lt;25&gt;&gt; sparrows.',
    'I see &lt;&lt;15&gt;&gt; finches.',
    'There is nothing here.',
    ]

def test():
    pat = re.compile('&lt;&lt;([0-9]*)&gt;&gt;')
    for line in Targets:
        mo = pat.search(line)
        if mo:
            value = mo.group(1)
            print 'value: %s' % value
        else:
            print 'no match'

test()
</pre>
<p>When we run the above, it prints out the following:</p>
<pre class="literal-block">
value: 25
value: 15
no match
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>In the regular expression, put parentheses around the portion of the
regular expression that will match what you want to extract. Each
pair of parentheses marks off a group.</li>
<li>After the search, check to determine if there was a successful match
by checking for a matching object. &quot;pat.search(line)&quot; returns None
if the search fails.</li>
<li>If you specify more than one group in your regular expression (more
that one pair of parentheses), then you can use &quot;value =
mo.group(N)&quot; to extract the value matched by the Nth group from the
matching object. &quot;value = mo.group(1)&quot; returns the first extracted
value; &quot;value = mo.group(2)&quot; returns the second; etc.  An argument
of 0 returns the string matched by the entire regular expression.</li>
</ul>
<p>In addition, you can:</p>
<ul>
<li><p class="first">Use &quot;values = mo.groups()&quot; to get a tuple containing the strings
matched by all groups.</p>
</li>
<li><p class="first">Use &quot;mo.expand()&quot; to interpolate the group values into a string. For
example, &quot;mo.expand(r'value1: \1 value2: \2')&quot;inserts the values of
the first and second group into a string.  If the first group
matched &quot;aaa&quot; and the second matched &quot;bbb&quot;, then this example would
produce &quot;value1: aaa value2: bbb&quot;.  For example:</p>
<pre class="literal-block">
In [76]: mo = re.search(r'h: (\d*) w: (\d*)', 'h: 123 w: 456')
In [77]: mo.expand(r'Height: \1  Width: \2')
Out[77]: 'Height: 123  Width: 456'
</pre>
</li>
</ul>
</div>
<div class="section" id="extracting-multiple-items">
<h3><a class="toc-backref" href="#id120">2.2.5&nbsp;&nbsp;&nbsp;Extracting multiple items</a></h3>
<p>You can extract multiple items with a single search. Here is an
example:</p>
<pre class="literal-block">
import sys, re

pat = re.compile('aa([0-9]*)bb([0-9]*)cc')

while 1:
    line = raw_input('Enter a line (&quot;q&quot; to quit):')
    if line == 'q':
        break
    mo = pat.search(line)
    if mo:
        value1, value2 = mo.group(1, 2)
        print 'value1: %s  value2: %s' % (value1, value2)
    else:
        print 'no match'
</pre>
<p>Comments:</p>
<ul class="simple">
<li>Use multiple parenthesized substrings in the regular expression to
indicate the portions (groups) to be extracted.</li>
<li>&quot;mo.group(1, 2)&quot; returns the values of the first and second group in
the string matched.</li>
<li>We could also have used &quot;mo.groups()&quot; to obtain a tuple that
contains both values.</li>
<li>Yet another alternative would have been to use the following: <tt class="docutils literal">print
mo.expand(r'value1: \1 value2: \2')</tt>.</li>
</ul>
</div>
<div class="section" id="replacing-multiple-items">
<h3><a class="toc-backref" href="#id121">2.2.6&nbsp;&nbsp;&nbsp;Replacing multiple items</a></h3>
<p>A simple way to perform multiple replacements using a regular
expression is to use the <tt class="docutils literal">re.subn()</tt> function.  Here is an
example:</p>
<pre class="literal-block">
In [81]: re.subn(r'\d+', '***', 'there are 203 birds sitting in 2 trees')
Out[81]: ('there are *** birds sitting in *** trees', 2)
</pre>
<p>For more complex replacements, use a function instead of a constant
replacement string:</p>
<pre class="literal-block">
import re

def repl_func(mo):
    s1 = mo.group(1)
    s2 = '*' * len(s1)
    return s2

def test():
    pat = r'(\d+)'
    in_str = 'there are 2034 birds in 21 trees'
    out_str, count = re.subn(pat, repl_func, in_str)
    print 'in:  &quot;%s&quot;' % in_str
    print 'out: &quot;%s&quot;' % out_str
    print 'count: %d' % count

test()
</pre>
<p>And when we run the above, it produces:</p>
<pre class="literal-block">
in:  &quot;there are 2034 birds in 21 trees&quot;
out: &quot;there are **** birds in ** trees&quot;
count: 2
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The replacement function receives one argument, a match object.</li>
<li>The <tt class="docutils literal">re.subn()</tt> function returns a tuple containing two values:
(1) the string after replacements and (2) the number of
replacements performed.</li>
</ul>
<p>Here is an even more complex example -- You can locate sub-strings
(slices) of a match and replace them:</p>
<pre class="literal-block">
import sys, re

pat = re.compile('aa([0-9]*)bb([0-9]*)cc')

while 1:
    line = raw_input('Enter a line (&quot;q&quot; to quit): ')
    if line == 'q':
        break
    mo = pat.search(line)
    if mo:
        value1, value2 = mo.group(1, 2)
        start1 = mo.start(1)
        end1 = mo.end(1)
        start2 = mo.start(2)
        end2 = mo.end(2)
        print 'value1: %s  start1: %d  end1: %d' % (value1, start1, end1)
        print 'value2: %s  start2: %d  end2: %d' % (value2, start2, end2)
        repl1 = raw_input('Enter replacement #1: ')
        repl2 = raw_input('Enter replacement #2: ')
        newline = (line[:start1] + repl1 + line[end1:start2] +
            repl2 + line[end2:])
        print 'newline: %s' % newline
    else:
        print 'no match'
</pre>
<p>Explanation:</p>
<ul>
<li><p class="first">Alternatively, use &quot;mo.span(1)&quot; instead of &quot;mo.start(1)&quot; and
&quot;mo.end(1)&quot; in order to get the start and end of a sub-match in a
single operation. &quot;mo.span(1)&quot;returns a tuple: (start, end).</p>
</li>
<li><p class="first">Put together a new string with string concatenation from pieces of
the original string and replacement values. You can use string
slices to get the sub-strings of the original string. In our case,
the following gets the start of the string, adds the first
replacement, adds the middle of the original string, adds the second
replacement, and finally, adds the last part of the original string:</p>
<pre class="literal-block">
newline = line[:start1] + repl1 + line[end1:start2] + repl2 + line[end2:]
</pre>
</li>
</ul>
<p>You can also use the sub function or method to do substitutions. Here
is an example:</p>
<pre class="literal-block">
import sys, re

pat = re.compile('[0-9]+')

print 'Replacing decimal digits.'
while 1:
    target = raw_input('Enter a target line (&quot;q&quot; to quit): ')
    if target == 'q':
        break
    repl = raw_input('Enter a replacement: ')
    result = pat.sub(repl, target)
    print 'result: %s' % result
</pre>
<p>Here is another example of the use of a function to insert
calculated replacements.</p>
<pre class="literal-block">
import sys, re, string

pat = re.compile('[a-m]+')

def replacer(mo):
    return string.upper(mo.group(0))

print 'Upper-casing a-m.'
while 1:
    target = raw_input('Enter a target line (&quot;q&quot; to quit): ')
    if target == 'q':
        break
    result = pat.sub(replacer, target)
    print 'result: %s' % result
</pre>
<p>Notes:</p>
<ul class="simple">
<li>If the replacement argument to sub is a function, that function must
take one argument, a match object, and must return the modified (or
replacement) value.  The matched sub-string will be replaced by the
value returned by this function.</li>
<li>In our case, the function replacer converts the matched value to
upper case.</li>
</ul>
<p>This is also a convenient use for a lambda instead of a named
function, for example:</p>
<pre class="literal-block">
import sys, re, string

pat = re.compile('[a-m]+')

print 'Upper-casing a-m.'
while 1:
    target = raw_input('Enter a target line (&quot;q&quot; to quit): ')
    if target == 'q':
        break
    result = pat.sub(
        lambda mo: string.upper(mo.group(0)),
        target)
    print 'result: %s' % result
</pre>
</div>
</div>
<div class="section" id="iterator-objects">
<h2><a class="toc-backref" href="#id122">2.3&nbsp;&nbsp;&nbsp;Iterator Objects</a></h2>
<p>Note 1: You will need a sufficiently recent version of Python in order
to use iterators and generators. I believe that they were introduced
in Python 2.2.</p>
<p>Note 2: The iterator protocol has changed slightly in Python version
3.0.</p>
<p>Goals for this section:</p>
<ul class="simple">
<li>Learn how to implement a generator function, that is, a function
which, when called, returns an iterator.</li>
<li>Learn how to implement a class containing a generator method, that
is, a method which, when called, returns an iterator.</li>
<li>Learn the iterator protocol, specifically what methods an iterator
must support and what those methods must do.</li>
<li>Learn how to implement an iterator class, that is, a class whose
instances are iterator objects.</li>
<li>Learn how to implement recursive iterator generators, that is, an
iterator generator which recursively produces iterator generators.</li>
<li>Learn that your implementation of an iterator object (an iterator
class) can &quot;refresh&quot; itself and learn at least one way to do this.</li>
</ul>
<p>Definitions:</p>
<ul class="simple">
<li>Iterator - And iterator is an object that satisfies (implements) the
iterator protocol.</li>
<li>Iterator protocol - An object implements the iterator protocol if
it implements both a <tt class="docutils literal">next()</tt> and an <tt class="docutils literal">__iter__()</tt> method which
satisfy these rules: (1) the <tt class="docutils literal">__iter__()</tt> method must return the
iterator; (2) the <tt class="docutils literal">next()</tt> method should return the next item to
be iterated over and when finished (there are no more items)
should raise the <tt class="docutils literal">StopIteration</tt> exception. The iterator
protocol is described at
<a class="reference external" href="http://docs.python.org/library/stdtypes.html#iterator-types">Iterator Types --
http://docs.python.org/library/stdtypes.html#iterator-types</a>.</li>
<li>Iterator class - A class that implements (satisfies) the iterator
protocol. In particular, the class implements <tt class="docutils literal">next()</tt> and
<tt class="docutils literal">__iter__()</tt> methods as described above and in
<a class="reference external" href="http://docs.python.org/library/stdtypes.html#iterator-types">Iterator Types --
http://docs.python.org/library/stdtypes.html#iterator-types</a>.</li>
<li>(Iterator) generator function - A function (or method) which, when
called, returns an iterator object, that is, an object that
satisfies the iterator protocol. A function containing a yield
statement automatically becomes a generator.</li>
<li>Generator expression - An expression which produces an iterator
object.  Generator expressions have a form similar to a list
comprehension, but are enclosed in parentheses rather than square
brackets. See example below.</li>
</ul>
<p>A few additional basic points:</p>
<ul class="simple">
<li>A function that contains a yield statement is a generator
function. When called, it returns an iterator, that is, an object
that provides <tt class="docutils literal">next()</tt> and <tt class="docutils literal">__iter__()</tt> methods.</li>
<li>The iterator protocol is described here:
<a class="reference external" href="http://docs.python.org/library/stdtypes.html#iterator-types">Python Standard Library: Iterator Types --
http://docs.python.org/library/stdtypes.html#iterator-types</a>.</li>
<li>A class that defines both a <tt class="docutils literal">next()</tt> method and a <tt class="docutils literal">__iter__()</tt>
method satisfies the iterator protocol. So, instances of such a
class will be iterators.</li>
<li>Python provides a variety of ways to produce (implement)
iterators. This section describes a few of those ways. You should
also look at the <tt class="docutils literal">iter()</tt> built-in function, which is described
in <a class="reference external" href="http://docs.python.org/library/functions.html#iter">The Python Standard Library: Built-in Functions: iter() --
http://docs.python.org/library/functions.html#iter</a>.</li>
<li>An iterator can be used in an iterator context, for example in a for
statement, in a list comprehension, and in a generator
expression. When an iterator is used in an iterator context, the
iterator produces its values.</li>
</ul>
<p>This section attempts to provide examples that illustrate the
generator/iterator pattern.</p>
<p>Why is this important?</p>
<ul class="simple">
<li>Once mastered, it is a simple, convenient, and powerful
programming pattern.</li>
<li>It has many and pervasive uses.</li>
<li>It helps to lexically separate the producer code from the consumer
code. Doing so makes it easier to locate problems and to modify or
fix code in a way that is localized and does not have unwanted
side-effects.</li>
<li>Implementing your own iterators (and generators) enables you to
define your own abstract sequences, that is, sequences whose
composition are defined by your computations rather than by their
presence in a container. In fact, your iterator can calculate or
retrieve values as each one is requested.</li>
</ul>
<p>Examples - The remainder of this section provides a set of examples
which implement and use iterators.</p>
<div class="section" id="example-a-generator-function">
<h3><a class="toc-backref" href="#id123">2.3.1&nbsp;&nbsp;&nbsp;Example - A generator function</a></h3>
<p>This function contains a yield statement. Therefore, when we call it, it
produces an iterator:</p>
<pre class="literal-block">
def generateItems(seq):
    for item in seq:
        yield 'item: %s' % item

anIter = generateItems([])
print 'dir(anIter):', dir(anIter)
anIter = generateItems([111,222,333])
for x in anIter:
    print x
anIter = generateItems(['aaa', 'bbb', 'ccc'])
print anIter.next()
print anIter.next()
print anIter.next()
print anIter.next()
</pre>
<p>Running this example produces the following output:</p>
<pre class="literal-block">
dir(anIter): ['__class__', '__delattr__', '__doc__', '__getattribute__',
'__hash__', '__init__', '__iter__', '__new__', '__reduce__',
'__reduce_ex__', '__repr__', '__setattr__', '__str__', 'gi_frame',
'gi_running', 'next']
item: 111
item: 222
item: 333
item: aaa
item: bbb
item: ccc
Traceback (most recent call last):
  File &quot;iterator_generator.py&quot;, line 14, in ?
    print anIter.next()
StopIteration
</pre>
<p>Notes and explanation:</p>
<ul class="simple">
<li>The value returned by the call to the generator (function) is an
iterator. It obeys the iterator protocol. That is, <tt class="docutils literal">dir(anIter)</tt>
shows that it has both <tt class="docutils literal">__iter__()</tt> and <tt class="docutils literal">next()</tt> methods.</li>
<li>Because this object is an iterator, we can use a for statement to
iterate over the values returned by the generator.</li>
<li>We can also get its values by repeatedly calling the <tt class="docutils literal">next()</tt>
method, until it raises the StopIteration exception. This ability
to call the next method enables us to pass the iterator object
around and get values at different locations in our code.</li>
<li>Once we have obtained all the values from an iterator, it is, in
effect, &quot;empty&quot; or &quot;exhausted&quot;. The iterator protocol, in fact,
specifies that once an iterator raises the StopIteration exception,
it should continue to do so. Another way to say this is that there
is no &quot;rewind&quot; operation. But, you can call the the generator
function again to get a &quot;fresh&quot; iterator.</li>
</ul>
<p>An alternative and perhaps simpler way to create an interator is to
use a generator expression.  This can be useful when you already
have a collection or iterator to work with.</p>
<p>Then following example implements a function that returns a
generator object.  The effect is to generate the objects in a
collection which excluding items in a separte collection:</p>
<pre class="literal-block">
DATA = [
    'lemon',
    'lime',
    'grape',
    'apple',
    'pear',
    'watermelon',
    'canteloupe',
    'honeydew',
    'orange',
    'grapefruit',
    ]

def make_producer(collection, excludes):
    gen = (item for item in collection if item not in excludes)
    return gen

def test():
    iter1 = make_producer(DATA, ('apple', 'orange', 'honeydew', ))
    print '%s' % iter1
    for fruit in iter1:
        print fruit

test()
</pre>
<p>When run, this example produces the following:</p>
<pre class="literal-block">
$ python workbook063.py
&lt;generator object &lt;genexpr&gt; at 0x7fb3d0f1bc80&gt;
lemon
lime
grape
pear
watermelon
canteloupe
grapefruit
</pre>
<p>Notes:</p>
<ul class="simple">
<li>A generator expression looks almost like a list comprehension, but
is surrounded by parentheses rather than square brackets.  For
more on list comprehensions see section
<a class="reference internal" href="#example-a-list-comprehension">Example - A list comprehension</a>.</li>
<li>The <tt class="docutils literal">make_producer</tt> function returns the object produced by the
generator expression.</li>
</ul>
</div>
<div class="section" id="example-a-class-containing-a-generator-method">
<h3><a class="toc-backref" href="#id124">2.3.2&nbsp;&nbsp;&nbsp;Example - A class containing a generator method</a></h3>
<p>Each time this method is called, it produces a (new) iterator
object. This method is analogous to the iterkeys and itervalues
methods in the dictionary built-in object:</p>
<pre class="literal-block">
#
# A class that provides an iterator generator method.
#
class Node:
    def __init__(self, name='&lt;noname&gt;', value='&lt;novalue&gt;', children=None):
        self.name = name
        self.value = value
        self.children = children
        if children is None:
            self.children = []
        else:
            self.children = children
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_value(self, value): self.value = value
    def get_value(self): return self.value
    def iterchildren(self):
        for child in self.children:
            yield child
    #
    # Print information on this node and walk over all children and
    #   grandchildren ...
    def walk(self, level=0):
        print '%sname: %s  value: %s' % (
            get_filler(level), self.get_name(), self.get_value(), )
        for child in self.iterchildren():
            child.walk(level + 1)

#
# An function that is the equivalent of the walk() method in
#   class Node.
#
def walk(node, level=0):
    print '%sname: %s  value: %s' % (
        get_filler(level), node.get_name(), node.get_value(), )
    for child in node.iterchildren():
        walk(child, level + 1)

def get_filler(level):
    return '    ' * level

def test():
    a7 = Node('gilbert', '777')
    a6 = Node('fred', '666')
    a5 = Node('ellie', '555')
    a4 = Node('daniel', '444')
    a3 = Node('carl', '333', [a4, a5])
    a2 = Node('bill', '222', [a6, a7])
    a1 = Node('alice', '111', [a2, a3])
    # Use the walk method to walk the entire tree.
    print 'Using the method:'
    a1.walk()
    print '=' * 30
    # Use the walk function to walk the entire tree.
    print 'Using the function:'
    walk(a1)

test()
</pre>
<p>Running this example produces the following output:</p>
<pre class="literal-block">
Using the method:
name: alice  value: 111
    name: bill  value: 222
        name: fred  value: 666
        name: gilbert  value: 777
    name: carl  value: 333
        name: daniel  value: 444
        name: ellie  value: 555
==============================
Using the function:
name: alice  value: 111
    name: bill  value: 222
        name: fred  value: 666
        name: gilbert  value: 777
    name: carl  value: 333
        name: daniel  value: 444
        name: ellie  value: 555
</pre>
<p>Notes and explanation:</p>
<ul class="simple">
<li>This class contains a method iterchildren which, when called,
returns an iterator.</li>
<li>The yield statement in the method iterchildren makes it into a
generator.</li>
<li>The yield statement returns one item each time it is reached. The
next time the iterator object is &quot;called&quot; it resumes immediately
after the yield statement.</li>
<li>A function may have any number of yield statements.</li>
<li>A for statement will iterate over all the items produced by an
iterator object.</li>
<li>This example shows two ways to use the generator, specifically: (1)
the walk method in the class Node and (2) the walk function. Both
call the generator iterchildren and both do pretty much the same
thing.</li>
</ul>
</div>
<div class="section" id="example-an-iterator-class">
<h3><a class="toc-backref" href="#id125">2.3.3&nbsp;&nbsp;&nbsp;Example - An iterator class</a></h3>
<p>This class implements the iterator protocol. Therefore, instances of
this class are iterators. The presence of the <tt class="docutils literal">next()</tt> and
<tt class="docutils literal">__iter__()</tt> methods means that this class implements the iterator
protocol and makes instances of this class iterators.</p>
<p>Note that when an iterator is &quot;exhausted&quot; it, normally, cannot be
reused to iterate over the sequence. However, in this example, we
provide a refresh method which enables us to &quot;rewind&quot; and reuse the
iterator instance:</p>
<pre class="literal-block">
#
# An iterator class that does *not* use ``yield``.
#   This iterator produces every other item in a sequence.
#
class IteratorExample:
    def __init__(self, seq):
        self.seq = seq
        self.idx = 0
    def next(self):
        self.idx += 1
        if self.idx &gt;= len(self.seq):
            raise StopIteration
        value = self.seq[self.idx]
        self.idx += 1
        return value
    def __iter__(self):
        return self
    def refresh(self):
        self.idx = 0

def test_iteratorexample():
    a = IteratorExample('edcba')
    for x in a:
        print x
    print '----------'
    a.refresh()
    for x in a:
        print x
    print '=' * 30
    a = IteratorExample('abcde')
    try:
        print a.next()
        print a.next()
        print a.next()
        print a.next()
        print a.next()
        print a.next()
    except StopIteration, e:
        print 'stopping', e

test_iteratorexample()
</pre>
<p>Running this example produces the following output:</p>
<pre class="literal-block">
d
b
----------
d
b
==============================
b
d
stopping
</pre>
<p>Notes and explanation:</p>
<ul class="simple">
<li>The next method must keep track of where it is and what item it
should produce next.</li>
<li><strong>Alert:</strong> The iterator protocol has changed slightly in Python
3.0.  In particular, the <tt class="docutils literal">next()</tt> method has been renamed to
<tt class="docutils literal">__next__()</tt>.  See:
<a class="reference external" href="http://docs.python.org/3.0/library/stdtypes.html#iterator-types">Python Standard Library: Iterator Types --
http://docs.python.org/3.0/library/stdtypes.html#iterator-types</a>.</li>
</ul>
</div>
<div class="section" id="example-an-iterator-class-that-uses-yield">
<h3><a class="toc-backref" href="#id126">2.3.4&nbsp;&nbsp;&nbsp;Example - An iterator class that uses yield</a></h3>
<p>There may be times when the next method is easier and more
straight-forward to implement using yield. If so, then this class
might serve as an model. If you do not feel the need to do this, then
you should ignore this example:</p>
<pre class="literal-block">
#
# An iterator class that uses ``yield``.
#   This iterator produces every other item in a sequence.
#
class YieldIteratorExample:
    def __init__(self, seq):
        self.seq = seq
        self.iterator = self._next()
        self.next = self.iterator.next
    def _next(self):
        flag = 0
        for x in self.seq:
            if flag:
                flag = 0
                yield x
            else:
                flag = 1
    def __iter__(self):
        return self.iterator
    def refresh(self):
        self.iterator = self._next()
        self.next = self.iterator.next

def test_yielditeratorexample():
    a = YieldIteratorExample('edcba')
    for x in a:
        print x
    print '----------'
    a.refresh()
    for x in a:
        print x
    print '=' * 30
    a = YieldIteratorExample('abcde')
    try:
        print a.next()
        print a.next()
        print a.next()
        print a.next()
        print a.next()
        print a.next()
    except StopIteration, e:
        print 'stopping', e

test_yielditeratorexample()
</pre>
<p>Running this example produces the following output:</p>
<pre class="literal-block">
d
b
----------
d
b
==============================
b
d
stopping
</pre>
<p>Notes and explanation:</p>
<ul>
<li><p class="first">Because the _next method uses yield, calling it (actually, calling
the iterator object it produces) in an iterator context causes it to
be &quot;resumed&quot; immediately after the yield statement. This reduces
bookkeeping a bit.</p>
</li>
<li><p class="first">However, with this style, we must explicitly produce an iterator. We
do this by calling the _next method, which contains a yield
statement, and is therefore a generator. The following code in our
constructor (<tt class="docutils literal">__init__</tt>) completes the set-up of our class as an
iterator class:</p>
<pre class="literal-block">
self.iterator = self._next()
self.next = self.iterator.next
</pre>
<p>Remember that we need both <tt class="docutils literal">__iter__()</tt> and <tt class="docutils literal">next()</tt> methods
in <tt class="docutils literal">YieldIteratorExample</tt> to satisfy the iterator protocol. The
<tt class="docutils literal">__iter__()</tt> method is already there and the above code in the
constructor creates the <tt class="docutils literal">next()</tt> method.</p>
</li>
</ul>
</div>
<div class="section" id="example-a-list-comprehension">
<h3><a class="toc-backref" href="#id127">2.3.5&nbsp;&nbsp;&nbsp;Example - A list comprehension</a></h3>
<p>A list comprehension looks a bit like an iterator, but it produces a
list.  See: <a class="reference external" href="http://docs.python.org/reference/expressions.html#list-displays">The Python Language Reference: List displays --
http://docs.python.org/reference/expressions.html#list-displays</a>
for more on list comprehensions.</p>
<p>Here is an example:</p>
<pre class="literal-block">
In [4]: def f(x):
   ...:     return x * 3
   ...:
In [5]: list1 = [11, 22, 33]
In [6]: list2 = [f(x) for x in list1]
In [7]: print list2
[33, 66, 99]
</pre>
</div>
<div class="section" id="example-a-generator-expression">
<h3><a class="toc-backref" href="#id128">2.3.6&nbsp;&nbsp;&nbsp;Example - A generator expression</a></h3>
<p>A generator expression looks quite similar to a list comprehension,
but is enclosed in parentheses rather than square brackets. Unlike a
list comprehension, a generator expression does not produce a list; it
produces an generator object.  A generator object is an iterator.</p>
<p>For more on generator expressions, see
<a class="reference external" href="http://docs.python.org/reference/expressions.html#generator-expressions">The Python Language Reference: Generator expressions --
http://docs.python.org/reference/expressions.html#generator-expressions</a>.</p>
<p>The following example uses a generator expression to produce an
iterator:</p>
<pre class="literal-block">
mylist = range(10)

def f(x):
    return x*3

genexpr = (f(x) for x in mylist)

for x in genexpr:
    print x
</pre>
<p>Notes and explanation:</p>
<ul class="simple">
<li>The generator expression (f(x) for x in mylist) produces an iterator
object.</li>
<li>Notice that we can use the iterator object later in our code, can
save it in a data structure, and can pass it to a function.</li>
</ul>
</div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id129">2.4&nbsp;&nbsp;&nbsp;Unit Tests</a></h2>
<p>Unit test and the Python unit test framework provide a convenient way
to define and run tests that ensure that a Python application produces
specified results.</p>
<p>This section, while it will not attempt to explain everything about
the unit test framework, will provide examples of several
straight-forward ways to construct and run tests.</p>
<p>Some assumptions:</p>
<ul class="simple">
<li>We are going to develop a software project incrementally. We will
not implement and release all at once. Therefore, each time we add
to our existing code base, we need a way to verify that our
additions (and fixes) have not caused new problems in old code.</li>
<li>Adding new code to existing code will cause problems.  We need to be
able to check/test for those problems at each step.</li>
<li>As we add code, we need to be able to add tests for that new code,
too.</li>
</ul>
<div class="section" id="defining-unit-tests">
<h3><a class="toc-backref" href="#id130">2.4.1&nbsp;&nbsp;&nbsp;Defining unit tests</a></h3>
<div class="section" id="create-a-test-class">
<h4><a class="toc-backref" href="#id131">2.4.1.1&nbsp;&nbsp;&nbsp;Create a test class.</a></h4>
<p>In the test class, implement a number of methods to perform your tests. Name
your test methods with the prefix &quot;test&quot;. Here is an example:</p>
<pre class="literal-block">
import unittest

class MyTest(unittest.TestCase):
    def test_one(self):
        # some test code
        pass
    def test_two(self):
        # some test code
        pass
</pre>
<p>Create a test harness. Here is an example:</p>
<pre class="literal-block">
import unittest

# make the test suite.
def suite():
    loader = unittest.TestLoader()
    testsuite = loader.loadTestsFromTestCase(MyTest)
    return testsuite

# Make the test suite; run the tests.
def test():
    testsuite = suite()
    runner = unittest.TextTestRunner(sys.stdout, verbosity=2)
    result = runner.run(testsuite)
</pre>
<p>Here is a more complete example:</p>
<pre class="literal-block">
import sys, StringIO, string
import unittest
import webserv_example_heavy_sub

# A comparison function for case-insenstive sorting.
def mycmpfunc(arg1, arg2):
    return cmp(string.lower(arg1), string.lower(arg2))

class XmlTest(unittest.TestCase):
    def test_import_export1(self):
        inFile = file('test1_in.xml', 'r')
        inContent = inFile.read()
        inFile.close()
        doc = webserv_example_heavy_sub.parseString(inContent)
        outFile = StringIO.StringIO()
        outFile.write('&lt;?xml version=&quot;1.0&quot; ?&gt;\n')
        doc.export(outFile, 0)
        outContent = outFile.getvalue()
        outFile.close()
        self.failUnless(inContent == outContent)

# make the test suite.
def suite():
    loader = unittest.TestLoader()
    # Change the test method prefix: test --&gt; trial.
    #loader.testMethodPrefix = 'trial'
    # Change the comparison function that determines the order of tests.
    #loader.sortTestMethodsUsing = mycmpfunc
    testsuite = loader.loadTestsFromTestCase(XmlTest)
    return testsuite

# Make the test suite; run the tests.
def test_main():
    testsuite = suite()
    runner = unittest.TextTestRunner(sys.stdout, verbosity=2)
    result = runner.run(testsuite)

if __name__ == &quot;__main__&quot;:
    test_main()
</pre>
<p>Running the above script produces the following output:</p>
<pre class="literal-block">
test_import_export (__main__.XmlTest) ... ok

----------------------------------------------------------------------
Ran 1 test in 0.035s

OK
</pre>
<p>A few notes on this example:</p>
<ul>
<li><p class="first">This example tests the ability to parse an xml document test1_in.xml
and export that document back to XML. The test succeeds if the input
XML document and the exported XML document are the same.</p>
</li>
<li><p class="first">The code which is being tested parses an XML document returned by a
request to Amazon Web services. You can learn more about Amazon Web
services at: <a class="reference external" href="http://www.amazon.com/webservices">http://www.amazon.com/webservices</a>.  This code was
generated from an XML Schema document by generateDS.py. So we are in
effect, testing generateDS.py. You can find generateDS.py at:
<a class="reference external" href="http://www.davekuhlman.org/#generateds-py">http://www.davekuhlman.org/#generateds-py</a>.</p>
</li>
<li><p class="first">Testing for success/failure and reporting failures -- Use the
methods listed at
<a class="reference external" href="http://www.python.org/doc/current/lib/testcase-objects.html">http://www.python.org/doc/current/lib/testcase-objects.html</a> to test
for and report success and failure. In our example, we used
&quot;self.failUnless(inContent == outContent)&quot; to ensure that the
content we parsed and the content that we exported were the same.</p>
</li>
<li><p class="first">Add additional tests by adding methods whose names have the prefix
&quot;test&quot;. If you prefer a different prefix for tests names, add
something like the following to the above script:</p>
<pre class="literal-block">
loader.testMethodPrefix = 'trial'
</pre>
</li>
<li><p class="first">By default, the tests are run in the order of their names sorted by
the cmp function. So, if needed, you can control the order of
execution of tests by selecting their names, for example, using
names like test_1_checkderef, test_2_checkcalc, etc. Or, you can
change the comparison function by adding something like the
following to the above script:</p>
<pre class="literal-block">
loader.sortTestMethodsUsing = mycmpfunc
</pre>
</li>
</ul>
<p>As a bit of motivation for creating and using unit tests, while
developing this example, I discovered several errors (or maybe
&quot;special features&quot;) in <tt class="docutils literal">generateDS.py</tt>.</p>
</div>
</div>
</div>
<div class="section" id="extending-and-embedding-python">
<h2><a class="toc-backref" href="#id132">2.5&nbsp;&nbsp;&nbsp;Extending and embedding Python</a></h2>
<div class="section" id="introduction-and-concepts">
<h3><a class="toc-backref" href="#id133">2.5.1&nbsp;&nbsp;&nbsp;Introduction and concepts</a></h3>
<p>Extending vs. embedding -- They are different but related:</p>
<ul class="simple">
<li>Extending Python means to implement an extension module or an
extension type. An extension module creates a new Python module
which is implemented in C/C++. From Python code, an extension module
appears to be just like a module implemented in Python code. An
extension type creates a new Python (built-in) type which is
implemented in C/C++. From Python code, an extension type appears to
be just like a built-in type.</li>
<li>Embedding Python, by contrast, is to put the Python interpreter
within an application (i.e. link it in) so that the application can
run Python scripts.  The scripts can be executed or triggered in a
variety of ways, e.g. they can be bound to keys on the keyboard or
to menu items, they can be triggered by external events,
etc. Usually, in order to make the embedded Python interpreter
useful, Python is also extended with functions from the embedding
application, so that the scripts can call functions that are
implemented by the embedding C/C++ application.</li>
</ul>
<p>Documentation -- The two important sources for information about
extending and embedding are the following:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.python.org/doc/current/ext/ext.html">Extending and Embedding the Python Interpreter --
http://www.python.org/doc/current/ext/ext.html</a></li>
<li><a class="reference external" href="http://www.python.org/doc/current/api/api.html">Python/C API Reference Manual --
http://www.python.org/doc/current/api/api.html</a></li>
</ul>
<p>Types of extensions:</p>
<ul class="simple">
<li>Extension modules -- From the Python side, it appears to be a Python
module.  Usually it exports functions.</li>
<li>Extension types -- Used to implement a new Python data type.</li>
<li>Extension classes -- From the Python side, it appears to be a class.</li>
</ul>
<p>Tools -- There are several tools that support the development of Python
extensions:</p>
<ul class="simple">
<li>SWIG -- Learn about SWIG at: <a class="reference external" href="http://www.swig.org">http://www.swig.org</a></li>
<li>Pyrex -- Learn about Pyrex at:
<a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/</a></li>
<li>There is also Cython, which seems to be an advanced version of, or
at least an alternative to Pyrex.  See:
<a class="reference external" href="http://www.cython.org/">Cython - C Extensions for Python --
http://www.cython.org/</a></li>
</ul>
</div>
<div class="section" id="extension-modules">
<h3><a class="toc-backref" href="#id134">2.5.2&nbsp;&nbsp;&nbsp;Extension modules</a></h3>
<p>Writing an extension module by hand -- What to do:</p>
<ul class="simple">
<li>Create the &quot;init&quot; function -- The name of this function must be
&quot;init&quot; followed by the name of the module. Every extension module
must have such a function.</li>
<li>Create the function table -- This table maps function names
(referenced from Python code) to function pointers (implemented in
C/C++).</li>
<li>Implement each wrapper function.</li>
</ul>
<p>Implementing a wrapper function -- What to do:</p>
<ol class="arabic">
<li><p class="first">Capture the arguments with PyArg_ParseTuple. The format string
specifies how arguments are to be converted and captured. See 1.7
Extracting Parameters in Extension Functions. Here are some of the
most commonly used types:</p>
<ul>
<li><p class="first">Use &quot;i&quot;, &quot;s&quot;, &quot;f&quot;, etc to convert and capture simple types such
as integers, strings, floats, etc.</p>
</li>
<li><p class="first">Use &quot;O&quot; to get a pointer to Python &quot;complex&quot; types such as lists,
tuples, dictionaries, etc.</p>
</li>
<li><p class="first">Use items in parentheses to capture and unpack sequences
(e.g. lists and tuples) of fixed length. Example:</p>
<pre class="literal-block">
if (!PyArg_ParseTuple(args, &quot;(ii)(ii)&quot;, &amp;x, &amp;y, &amp;width, &amp;height))
{
    return NULL;
} /* if */
</pre>
<p>A sample call might be:</p>
<pre class="literal-block">
lowerLeft = (x1, y1)
extent = (width1, height1)
scan(lowerLeft, extent)
</pre>
</li>
<li><p class="first">Use &quot;:aName&quot; (colon) at the end of the format string to provide a
function name for error messages. Example:</p>
<pre class="literal-block">
if (!PyArg_ParseTuple(args, &quot;O:setContentHandler&quot;, &amp;pythonInstance))
{
    return NULL;
} /* if */
</pre>
</li>
<li><p class="first">Use &quot;;an error message&quot; (semicolon) at the end of the format
string to provide a string that replaces the default error
message.</p>
</li>
<li><p class="first">Docs are available at:
<a class="reference external" href="http://www.python.org/doc/current/ext/parseTuple.html">http://www.python.org/doc/current/ext/parseTuple.html</a>.</p>
</li>
</ul>
</li>
<li><p class="first">Write the logic.</p>
</li>
<li><p class="first">Handle errors and exceptions -- You will need to understand how to
(1) clearing errors and exceptions and (2) Raise errors
(exceptions).</p>
<ul>
<li><p class="first">Many functions in the Python C API raise exceptions. You will
need to check for and clear these exceptions. Here is an example:</p>
<pre class="literal-block">
char * message;
int messageNo;

message = NULL;
messageNo = -1;
/* Is the argument a string?
*/
if (! PyArg_ParseTuple(args, &quot;s&quot;, &amp;message))
{
    /* It's not a string.  Clear the error.
    *  Then try to get a message number (an integer).
    */
    PyErr_Clear();
    if (! PyArg_ParseTuple(args, &quot;i&quot;, &amp;messageNo))
    {
        o
        o
        o
</pre>
</li>
<li><p class="first">You can also raise exceptions in your C code that can be caught
(in a &quot;try:except:&quot; block) back in the calling Python code. Here
is an example:</p>
<pre class="literal-block">
if (n == 0)
{
    PyErr_SetString(PyExc_ValueError, &quot;Value must not be zero&quot;);
    return NULL;
}
</pre>
<p>See Include/pyerrors.h in the Python source distribution for more
exception/error types.</p>
</li>
<li><p class="first">And, you can test whether a function in the Python C API that you
have called has raised an exception. For example:</p>
<pre class="literal-block">
if (PyErr_Occurred())
{
    /* An exception was raised.
    *  Do something about it.
    */
    o
    o
    o
</pre>
</li>
</ul>
<p>For more documentation on errors and exceptions, see:
<a class="reference external" href="http://www.python.org/doc/current/api/exceptionHandling.html">http://www.python.org/doc/current/api/exceptionHandling.html</a>.</p>
</li>
<li><p class="first">Create and return a value:</p>
<ul class="simple">
<li>For each built-in Python type there is a set of API functions to
create and manipulate it. See the &quot;Python/C API Reference Manual&quot;
for a description of these functions. For example, see:<ul>
<li><a class="reference external" href="http://www.python.org/doc/current/api/intObjects.html">http://www.python.org/doc/current/api/intObjects.html</a></li>
<li><a class="reference external" href="http://www.python.org/doc/current/api/stringObjects.html">http://www.python.org/doc/current/api/stringObjects.html</a></li>
<li><a class="reference external" href="http://www.python.org/doc/current/api/tupleObjects.html">http://www.python.org/doc/current/api/tupleObjects.html</a></li>
<li><a class="reference external" href="http://www.python.org/doc/current/api/listObjects.html">http://www.python.org/doc/current/api/listObjects.html</a></li>
<li><a class="reference external" href="http://www.python.org/doc/current/api/dictObjects.html">http://www.python.org/doc/current/api/dictObjects.html</a></li>
<li>Etc.</li>
</ul>
</li>
<li>The reference count -- You will need to follow Python's rules for
reference counting that Python uses to garbage collect
objects. You can learn about these rules at
<a class="reference external" href="http://www.python.org/doc/current/ext/refcounts.html">http://www.python.org/doc/current/ext/refcounts.html</a>. You will
not want Python to garbage collect objects that you create too
early or too late. With respect to Python objects created with
the above functions, these new objects are owned and may be
passed back to Python code. However, there are situations where
your C/C++ code will not automatically own a reference, for
example when you extract an object from a container (a list,
tuple, dictionary, etc). In these cases you should increment the
reference count with Py_INCREF.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="swig">
<h3><a class="toc-backref" href="#id135">2.5.3&nbsp;&nbsp;&nbsp;SWIG</a></h3>
<p>Note: Our discussion and examples are for SWIG version 1.3</p>
<p>SWIG will often enable you to generate wrappers for functions in an
existing C function library. SWIG does not understand everything in C
header files. But it does a fairly impressive job. You should try it
first before resorting to the hard work of writing wrappers by hand.</p>
<p>More information on SWIG is at <a class="reference external" href="http://www.swig.org">http://www.swig.org</a>.</p>
<p>Here are some steps that you can follow:</p>
<ol class="arabic">
<li><p class="first">Create an interface file -- Even when you are wrapping functions
defined in an existing header file, creating an interface file is a
good idea. Include your existing header file into it, then add
whatever else you need. Here is an extremely simple example of a
SWIG interface file:</p>
<pre class="literal-block">
%module MyLibrary

%{
#include &quot;MyLibrary.h&quot;
%}

%include &quot;MyLibrary.h&quot;
</pre>
<p>Comments:</p>
<ul>
<li><p class="first">The &quot;%{&quot; and &quot;%}&quot; brackets are directives to SWIG. They say: &quot;Add
the code between these brackets to the generated wrapper file
without processing it.</p>
</li>
<li><p class="first">The &quot;%include&quot; statement says: &quot;Copy the file into the interface
file here. In effect, you are asking SWIG to generate wrappers
for all the functions in this header file. If you want wrappers
for only some of the functions in a header file, then copy or
reproduce function declarations for the desired functions
here. An example:</p>
<pre class="literal-block">
%module MyLibrary

%{
#include &quot;MyLibrary.h&quot;
%}

int calcArea(int width, int height);
int calcVolume(int radius);
</pre>
<p>This example will generate wrappers for only two functions.</p>
</li>
<li><p class="first">You can find more information about the directives that are used
in SWIG interface files in the SWIG User Manual, in particular at:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.swig.org/Doc1.3/Preprocessor.html">http://www.swig.org/Doc1.3/Preprocessor.html</a></li>
<li><a class="reference external" href="http://www.swig.org/Doc1.3/Python.html">http://www.swig.org/Doc1.3/Python.html</a></li>
</ul>
</li>
</ul>
</li>
<li><p class="first">Generate the wrappers:</p>
<pre class="literal-block">
swig -python MyLibrary.i
</pre>
</li>
<li><p class="first">Compile and link the library. On Linux, you can use something like
the following:</p>
<pre class="literal-block">
gcc -c MyLibrary.c
gcc -c -I/usr/local/include/python2.3 MyLibrary_wrap.c
gcc -shared MyLibrary.o MyLibrary_wrap.o -o _MyLibrary.so
</pre>
<p>Note that we produce a shared library whose name is the module name
prefixed with an underscore. SWIG also generates a .py file,
without the leading underscore, which we will import from our
Python code and which, in turn, imports the shared library.</p>
</li>
<li><p class="first">Use the extension module in your python code:</p>
<pre class="literal-block">
Python 2.3b1 (#1, Apr 25 2003, 20:36:09)
[GCC 2.95.4 20011002 (Debian prerelease)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import MyLibrary
&gt;&gt;&gt; MyLibrary.calcArea(4.0, 5.0)
20.0
</pre>
</li>
</ol>
<p>Here is a makefile that will execute swig to generate wrappers, then
compile and link the extension.</p>
<blockquote>
<p>CFLAGS = -I/usr/local/include/python2.3</p>
<p>all: _MyLibrary.so</p>
<dl class="docutils">
<dt>_MyLibrary.so: MyLibrary.o MyLibrary_wrap.o</dt>
<dd>gcc -shared MyLibrary.o MyLibrary_wrap.o -o _MyLibrary.so</dd>
<dt>MyLibrary.o: MyLibrary.c</dt>
<dd>gcc -c MyLibrary.c -o MyLibrary.o</dd>
<dt>MyLibrary_wrap.o: MyLibrary_wrap.c</dt>
<dd>gcc -c ${CFLAGS} MyLibrary_wrap.c -o MyLibrary_wrap.o</dd>
<dt>MyLibrary_wrap.c: MyLibrary.i</dt>
<dd>swig -python MyLibrary.i</dd>
<dt>clean:</dt>
<dd><dl class="first last docutils">
<dt>rm -f MyLibrary.py MyLibrary.o MyLibrary_wrap.c </dt>
<dd>MyLibrary_wrap.o _MyLibrary.so</dd>
</dl>
</dd>
</dl>
</blockquote>
<p>Here is an example of running this makefile:</p>
<pre class="literal-block">
$ make -f MyLibrary_makefile clean
rm -f MyLibrary.py MyLibrary.o MyLibrary_wrap.c \
        MyLibrary_wrap.o _MyLibrary.so
$ make -f MyLibrary_makefile
gcc -c MyLibrary.c -o MyLibrary.o
swig -python MyLibrary.i
gcc -c -I/usr/local/include/python2.3 MyLibrary_wrap.c -o MyLibrary_wrap.o
gcc -shared MyLibrary.o MyLibrary_wrap.o -o _MyLibrary.so
</pre>
<p>And, here are C source files that can be used in our example.</p>
<p>MyLibrary.h:</p>
<pre class="literal-block">
/* MyLibrary.h
*/

float calcArea(float width, float height);
float calcVolume(float radius);

int getVersion();

int getMode();
</pre>
<p>MyLibrary.c:</p>
<pre class="literal-block">
/* MyLibrary.c
*/

float calcArea(float width, float height)
{
   return (width * height);
}

float calcVolume(float radius)
{
   return (3.14 * radius * radius);
}

int getVersion()
{
    return 123;
}

int getMode()
{
    return 1;
}
</pre>
</div>
<div class="section" id="pyrex">
<h3><a class="toc-backref" href="#id136">2.5.4&nbsp;&nbsp;&nbsp;Pyrex</a></h3>
<p>Pyrex is a useful tool for writing Python extensions. Because the
Pyrex language is similar to Python, writing extensions in Pyrex is
easier than doing so in C.  Cython appears to be the a newer version
of Pyrex.</p>
<p>More information is on Pyrex and Cython is at:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">Pyrex --
http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/</a></li>
<li><a class="reference external" href="http://www.cython.org/">Cython - C Extensions for Python --
http://www.cython.org/</a></li>
</ul>
<p>Here is a simple function definition in Pyrex:</p>
<pre class="literal-block">
# python_201_pyrex_string.pyx

import string

def formatString(object s1, object s2):
    s1 = string.strip(s1)
    s2 = string.strip(s2)
    s3 = '&lt;&lt;%s||%s&gt;&gt;' % (s1, s2)
    s4 = s3 * 4
    return s4
</pre>
<p>And, here is a make file:</p>
<pre class="literal-block">
CFLAGS = -DNDEBUG -O3 -Wall -Wstrict-prototypes -fPIC \
    -I/usr/local/include/python2.3

all: python_201_pyrex_string.so

python_201_pyrex_string.so: python_201_pyrex_string.o
    gcc -shared python_201_pyrex_string.o -o python_201_pyrex_string.so

python_201_pyrex_string.o: python_201_pyrex_string.c
    gcc -c ${CFLAGS} python_201_pyrex_string.c -o python_201_pyrex_string.o

python_201_pyrex_string.c: python_201_pyrex_string.pyx
    pyrexc python_201_pyrex_string.pyx

clean:
    rm -f python_201_pyrex_string.so python_201_pyrex_string.o \
            python_201_pyrex_string.c
</pre>
<p>Here is another example. In this one, one function in the .pyx file
calls another. Here is the implementation file:</p>
<pre class="literal-block">
# python_201_pyrex_primes.pyx

def showPrimes(int kmax):
    plist = primes(kmax)
    for p in plist:
        print 'prime: %d' % p

cdef primes(int kmax):
    cdef int n, k, i
    cdef int p[1000]
    result = []
    if kmax &gt; 1000:
        kmax = 1000
    k = 0
    n = 2
    while k &lt; kmax:
        i = 0
        while i &lt; k and n % p[i] &lt;&gt; 0:
            i = i + 1
        if i == k:
           p[k] = n
           k = k + 1
           result.append(n)
        n = n + 1
    return result
</pre>
<p>And, here is a make file:</p>
<blockquote>
<p>#CFLAGS = -DNDEBUG -g -O3 -Wall -Wstrict-prototypes -fPIC #   -I/usr/local/include/python2.3
CFLAGS = -DNDEBUG -I/usr/local/include/python2.3</p>
<p>all: python_201_pyrex_primes.so</p>
<dl class="docutils">
<dt>python_201_pyrex_primes.so: python_201_pyrex_primes.o</dt>
<dd>gcc -shared python_201_pyrex_primes.o -o python_201_pyrex_primes.so</dd>
<dt>python_201_pyrex_primes.o: python_201_pyrex_primes.c</dt>
<dd>gcc -c ${CFLAGS} python_201_pyrex_primes.c -o python_201_pyrex_primes.o</dd>
<dt>python_201_pyrex_primes.c: python_201_pyrex_primes.pyx</dt>
<dd>pyrexc python_201_pyrex_primes.pyx</dd>
<dt>clean:</dt>
<dd><dl class="first last docutils">
<dt>rm -f python_201_pyrex_primes.so python_201_pyrex_primes.o </dt>
<dd>python_201_pyrex_primes.c</dd>
</dl>
</dd>
</dl>
</blockquote>
<p>Here is the output from running the makefile:</p>
<pre class="literal-block">
$ make -f python_201_pyrex_makeprimes clean
rm -f python_201_pyrex_primes.so python_201_pyrex_primes.o \
        python_201_pyrex_primes.c
$ make -f python_201_pyrex_makeprimes
pyrexc python_201_pyrex_primes.pyx
gcc -c -DNDEBUG -I/usr/local/include/python2.3  python_201_pyrex_primes.c -o python_201_pyrex_primes.o
gcc -shared python_201_pyrex_primes.o -o python_201_pyrex_primes.so
</pre>
<p>Here is an interactive example of its use:</p>
<pre class="literal-block">
$ python
Python 2.3b1 (#1, Apr 25 2003, 20:36:09)
[GCC 2.95.4 20011002 (Debian prerelease)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import python_201_pyrex_primes
&gt;&gt;&gt; dir(python_201_pyrex_primes)
['__builtins__', '__doc__', '__file__', '__name__', 'showPrimes']
&gt;&gt;&gt; python_201_pyrex_primes.showPrimes(5)
prime: 2
prime: 3
prime: 5
prime: 7
prime: 11
</pre>
<p>This next example shows how to use Pyrex to implement a new extension
type, that is a new Python built-in type. Notice that the class is
declared with the cdef keyword, which tells Pyrex to generate the C
implementation of a type instead of a class.</p>
<p>Here is the implementation file:</p>
<pre class="literal-block">
# python_201_pyrex_clsprimes.pyx

&quot;&quot;&quot;An implementation of primes handling class
for a demonstration of Pyrex.
&quot;&quot;&quot;

cdef class Primes:
    &quot;&quot;&quot;A class containing functions for
    handling primes.
    &quot;&quot;&quot;

    def showPrimes(self, int kmax):
        &quot;&quot;&quot;Show a range of primes.
        Use the method primes() to generate the primes.
        &quot;&quot;&quot;
        plist = self.primes(kmax)
        for p in plist:
            print 'prime: %d' % p

    def primes(self, int kmax):
        &quot;&quot;&quot;Generate the primes in the range 0 - kmax.
        &quot;&quot;&quot;
        cdef int n, k, i
        cdef int p[1000]
        result = []
        if kmax &gt; 1000:
            kmax = 1000
        k = 0
        n = 2
        while k &lt; kmax:
            i = 0
            while i &lt; k and n % p[i] &lt;&gt; 0:
                i = i + 1
            if i == k:
               p[k] = n
               k = k + 1
               result.append(n)
            n = n + 1
        return result
</pre>
<p>And, here is a make file:</p>
<pre class="literal-block">
CFLAGS = -DNDEBUG -I/usr/local/include/python2.3

all: python_201_pyrex_clsprimes.so

python_201_pyrex_clsprimes.so: python_201_pyrex_clsprimes.o
    gcc -shared python_201_pyrex_clsprimes.o -o python_201_pyrex_clsprimes.so

python_201_pyrex_clsprimes.o: python_201_pyrex_clsprimes.c
    gcc -c ${CFLAGS} python_201_pyrex_clsprimes.c -o python_201_pyrex_clsprimes.o

python_201_pyrex_clsprimes.c: python_201_pyrex_clsprimes.pyx
    pyrexc python_201_pyrex_clsprimes.pyx

clean:
    rm -f python_201_pyrex_clsprimes.so python_201_pyrex_clsprimes.o \
            python_201_pyrex_clsprimes.c
</pre>
<p>Here is output from running the makefile:</p>
<pre class="literal-block">
$ make -f python_201_pyrex_makeclsprimes clean
rm -f python_201_pyrex_clsprimes.so python_201_pyrex_clsprimes.o \
        python_201_pyrex_clsprimes.c
$ make -f python_201_pyrex_makeclsprimes
pyrexc python_201_pyrex_clsprimes.pyx
gcc -c -DNDEBUG -I/usr/local/include/python2.3  python_201_pyrex_clsprimes.c -o python_201_pyrex_clsprimes.o
gcc -shared python_201_pyrex_clsprimes.o -o python_201_pyrex_clsprimes.so
</pre>
<p>And here is an interactive example of its use:</p>
<pre class="literal-block">
$ python
Python 2.3b1 (#1, Apr 25 2003, 20:36:09)
[GCC 2.95.4 20011002 (Debian prerelease)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import python_201_pyrex_clsprimes
&gt;&gt;&gt; dir(python_201_pyrex_clsprimes)
['Primes', '__builtins__', '__doc__', '__file__', '__name__']
&gt;&gt;&gt; primes = python_201_pyrex_clsprimes.Primes()
&gt;&gt;&gt; dir(primes)
['__class__', '__delattr__', '__doc__', '__getattribute__', '__hash__',
'__init__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__setattr__', '__str__', 'primes', 'showPrimes']
&gt;&gt;&gt; primes.showPrimes(4)
prime: 2
prime: 3
prime: 5
prime: 7
</pre>
<p>Documentation -- Also notice that Pyrex preserves the documentation
for the module, the class, and the methods in the class. You can show
this documentation with pydoc, as follows:</p>
<pre class="literal-block">
$ pydoc python_201_pyrex_clsprimes
</pre>
<p>Or, in Python interactive mode, use:</p>
<pre class="literal-block">
$ python
Python 2.3b1 (#1, Apr 25 2003, 20:36:09)
[GCC 2.95.4 20011002 (Debian prerelease)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import python_201_pyrex_clsprimes
&gt;&gt;&gt; help(python_201_pyrex_clsprimes)
</pre>
</div>
<div class="section" id="swig-vs-pyrex">
<h3><a class="toc-backref" href="#id137">2.5.5&nbsp;&nbsp;&nbsp;SWIG vs. Pyrex</a></h3>
<p>Choose SWIG when:</p>
<ul class="simple">
<li>You already have an existing C or C++ implementation of the code you
want to call from Python. In this case you want SWIG to generate the
wrappers.  But note that Cython promises to enable you to quickly
wrap and call functions implemented in C.</li>
<li>You want to write the implementation in C or C++ by hand. Perhaps,
because you think you can do so quickly, for example, or because you
believe that you can make it highly optimized. Then, you want to be
able to generate the Python (extension) wrappers for it quickly.</li>
</ul>
<p>Choose Pyrex when:</p>
<ul class="simple">
<li>You do not have a C/C++ implementation and you want an easier way to
write that C implementation. Writing Pyrex code, which is a lot like
Python, is easier than writing C or C++ code by hand).</li>
<li>You start to write the implementation in C, then find that it
requires lots of calls to the Python C API, and you want to avoid
having to learn how to do that.</li>
</ul>
</div>
<div class="section" id="cython">
<h3><a class="toc-backref" href="#id138">2.5.6&nbsp;&nbsp;&nbsp;Cython</a></h3>
<p>Here is a simple example that uses Cython to wrap a function
implemented in C.</p>
<p>First the C header file:</p>
<pre class="literal-block">
/* test_c_lib.h */

int calculate(int width, int height);
</pre>
<p>And, the C implementation file:</p>
<pre class="literal-block">
/* test_c_lib.c */

#include &quot;test_c_lib.h&quot;

int calculate(int width, int height)
{
    int result;
    result = width * height * 3;
    return result;
}
</pre>
<p>Here is a Cython file that calls our C function:</p>
<pre class="literal-block">
# test_c.pyx

# Declare the external C function.
cdef extern from &quot;test_c_lib.h&quot;:
    int calculate(int width, int height)

def test(w, h):
    # Call the external C function.
    result = calculate(w, h)
    print 'result from calculate: %d' % result
</pre>
<p>We can compile our code using this script (on Linux):</p>
<pre class="literal-block">
#!/bin/bash -x
cython test_c.pyx
gcc -c -fPIC -I/usr/local/include/python2.6  -o test_c.o test_c.c
gcc -c -fPIC -I/usr/local/include/python2.6  -o test_c_lib.o test_c_lib.c
gcc -shared -fPIC -I/usr/local/include/python2.6  -o test_c.so test_c.o test_c_lib.o
</pre>
<p>Here is a small Python file that uses the wrapper that we wrote in
Cython:</p>
<pre class="literal-block">
# run_test_c.py

import test_c

def test():
    test_c.test(4, 5)
    test_c.test(12, 15)

if __name__ == '__main__':
    test()
</pre>
<p>And, when we run it, we see the following:</p>
<pre class="literal-block">
$ python run_test_c.py
result from calculate: 60
result from calculate: 540
</pre>
</div>
<div class="section" id="extension-types">
<h3><a class="toc-backref" href="#id139">2.5.7&nbsp;&nbsp;&nbsp;Extension types</a></h3>
<p>The goal -- A new built-in data type for Python.</p>
<p>Existing examples -- Objects/listobject.c, Objects/stringobject.c,
Objects/dictobject.c, etc in the Python source code distribution.</p>
<p>In older versions of the Python source code distribution, a template
for the C code was provided in Objects/xxobject.c. Objects/xxobject.c
is no longer included in the Python source code distribution. However:</p>
<ul class="simple">
<li>The discussion and examples for creating extension types have been
expanded. See:
<a class="reference external" href="http://docs.python.org/extending/newtypes.html">Extending and Embedding the Python
Interpreter, 2. Defining New Types --
http://docs.python.org/extending/newtypes.html</a>.</li>
<li>In the Tools/framer directory of the Python source code distribution
there is an application that will generate a skeleton for an
extension type from a specification object written in Python. Run
Tools/framer/example.py to see it in action.</li>
</ul>
<p>And, you can use Pyrex to generate a new built-in type. To do so,
implement a Python/Pyrex class and declare the class with the Pyrex
keyword cdef. In fact, you may want to use Pyrex to generate a minimal
extension type, and then edit that generated code to insert and add
functionality by hand. See the Pyrex section for an example.</p>
<p>Pyrex also goes some way toward giving you access to (existing) C
structs and functions from Python.</p>
</div>
<div class="section" id="extension-classes">
<h3><a class="toc-backref" href="#id140">2.5.8&nbsp;&nbsp;&nbsp;Extension classes</a></h3>
<p>Extension classes the easy way -- SWIG shadow classes.</p>
<p>Start with an implementation of a C++ class and its header file.</p>
<p>Use the following SWIG flags:</p>
<pre class="literal-block">
swig -c++ -python mymodule.i
</pre>
<p>More information is available with the SWIG documentation at:
<a class="reference external" href="http://www.swig.org/Doc1.3/Python.html">http://www.swig.org/Doc1.3/Python.html</a>.</p>
<p>Extension classes the Pyrex way -- An alternatie is to use Pyrex to
compile a class definition that does not have the cdef keyword. Using
cdef on the class tells Pyrex to generate an extension type instead of
a class. You will have to determine whether you want an extension
class or an extension type.</p>
</div>
</div>
<div class="section" id="parsing">
<h2><a class="toc-backref" href="#id141">2.6&nbsp;&nbsp;&nbsp;Parsing</a></h2>
<p>Python is an excellent language for text analysis.</p>
<p>In some cases, simply splitting lines of text into words will be
enough. In these cases use string.split().</p>
<p>In other cases, regular expressions may be able to do the parsing you
need. If so, see the section on regular expressions in this document.</p>
<p>However, in some cases, more complex analysis of input text is
required. This section describes some of the ways that Python can help
you with this complex parsing and analysis.</p>
<div class="section" id="special-purpose-parsers">
<h3><a class="toc-backref" href="#id142">2.6.1&nbsp;&nbsp;&nbsp;Special purpose parsers</a></h3>
<p>There are a number of special purpose parsers which you will find in
the Python standard library:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.python.org/library/configparser.html">ConfigParser parser - Configuration file parser --
http://docs.python.org/library/configparser.html</a></li>
<li><a class="reference external" href="http://docs.python.org/library/getopt.html">getopt -- Parser for command line options --
http://docs.python.org/library/getopt.html</a></li>
<li><a class="reference external" href="http://docs.python.org/library/optparse.html">optparse -- More powerful command line option parser --
http://docs.python.org/library/optparse.html</a></li>
<li><a class="reference external" href="http://docs.python.org/library/urlparse.html">urlparse -- Parse URLs into components --
http://docs.python.org/library/urlparse.html</a></li>
<li><a class="reference external" href="http://docs.python.org/library/csv.html#module-csv">csv -- CSV (comma separated values) File Reading and Writing  --
http://docs.python.org/library/csv.html#module-csv</a></li>
<li><a class="reference external" href="http://docs.python.org/library/os.path.html">os.path - Common pathname manipulations --
http://docs.python.org/library/os.path.html</a></li>
</ul>
<p>XML parsers and XML tools -- There is lots of support for parsing
and processing XML in Python. Here are a few places to look for
support:</p>
<ul class="simple">
<li>The Python standard library --
<a class="reference external" href="http://docs.python.org/library/markup.html">Structured Markup Processing Tools --
http://docs.python.org/library/markup.html</a>.</li>
<li>In particular, you may be interested in
<a class="reference external" href="http://docs.python.org/library/xml.dom.minidom.html">xml.dom.minidom - Lightweight DOM implementation --
http://docs.python.org/library/xml.dom.minidom.html</a>.</li>
<li>ElementTree -- You can think of ElementTree as an enhanced DOM
(document object model).  Many find it easier to use than
minidom.  ElementTree is in the Python standard library, and
documentation is here:
<a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree Overview --
http://effbot.org/zone/element-index.htm</a>.</li>
<li>Lxml mimics the ElementTree API, but has additional capabilities.
Find out about Lxml at
<a class="reference external" href="http://codespeak.net/lxml/index.html">lxml --
http://codespeak.net/lxml/index.html</a> --
Note that lxml also has support for XPath and XSLT.</li>
<li><a class="reference external" href="http://www.davekuhlman.org">Dave's support for Python and XML --
http://www.davekuhlman.org</a></li>
</ul>
</div>
<div class="section" id="writing-a-recursive-descent-parser-by-hand">
<h3><a class="toc-backref" href="#id143">2.6.2&nbsp;&nbsp;&nbsp;Writing a recursive descent parser by hand</a></h3>
<p>For simple grammars, this is not so hard.</p>
<p>You will need to implement:</p>
<ul class="simple">
<li>A recognizer method or function for each production rule in your
grammar. Each recognizer method begins looking at the current token,
then consumes as many tokens as needed to recognize it's own
production rule. It calls the recognizer functions for any
non-terminals on its right-hand side.</li>
<li>A tokenizer -- Something that will enable each recognizer function
to get tokens, one by one. There are a variety of ways to do this,
e.g. (1) a function that produces a list of tokens from which
recognizers can pop tokens; (2) a generator whose next method
returns the next token; etc.</li>
</ul>
<p>As an example, we'll implement a recursive descent parser written in
Python for the following grammer:</p>
<pre class="literal-block">
Prog ::= Command | Command Prog
Command ::= Func_call
Func_call ::= Term '(' Func_call_list ')'
Func_call_list ::= Func_call | Func_call ',' Func_call_list
Term = &lt;word&gt;
</pre>
<p>Here is an implementation of a recursive descent parser for the
above grammar:</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;
A recursive descent parser example.

Usage:
    python rparser.py [options] &lt;inputfile&gt;
Options:
    -h, --help      Display this help message.
Example:
    python rparser.py myfile.txt

The grammar:
    Prog ::= Command | Command Prog
    Command ::= Func_call
    Func_call ::= Term '(' Func_call_list ')'
    Func_call_list ::= Func_call | Func_call ',' Func_call_list
    Term = &lt;word&gt;
&quot;&quot;&quot;

import sys
import string
import types
import getopt

#
# To use the IPython interactive shell to inspect your running
#   application, uncomment the following lines:
#
## from IPython.Shell import IPShellEmbed
## ipshell = IPShellEmbed((),
##     banner = '&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Into IPython &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;',
##     exit_msg = '&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Out of IPython &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;')
#
# Then add the following line at the point in your code where
#   you want to inspect run-time values:
#
#       ipshell('some message to identify where we are')
#
# For more information see: http://ipython.scipy.org/moin/
#

#
# Constants
#

# AST node types
NoneNodeType = 0
ProgNodeType = 1
CommandNodeType = 2
FuncCallNodeType = 3
FuncCallListNodeType = 4
TermNodeType = 5

# Token types
NoneTokType = 0
LParTokType = 1
RParTokType = 2
WordTokType = 3
CommaTokType = 4
EOFTokType = 5

# Dictionary to map node type values to node type names
NodeTypeDict = {
    NoneNodeType: 'NoneNodeType',
    ProgNodeType: 'ProgNodeType',
    CommandNodeType: 'CommandNodeType',
    FuncCallNodeType: 'FuncCallNodeType',
    FuncCallListNodeType: 'FuncCallListNodeType',
    TermNodeType: 'TermNodeType',
    }

#
# Representation of a node in the AST (abstract syntax tree).
#
class ASTNode:
    def __init__(self, nodeType, *args):
        self.nodeType = nodeType
        self.children = []
        for item in args:
            self.children.append(item)
    def show(self, level):
        self.showLevel(level)
        print 'Node -- Type %s' % NodeTypeDict[self.nodeType]
        level += 1
        for child in self.children:
            if isinstance(child, ASTNode):
                child.show(level)
            elif type(child) == types.ListType:
                for item in child:
                    item.show(level)
            else:
                self.showLevel(level)
                print 'Child:', child
    def showLevel(self, level):
        for idx in range(level):
            print '   ',

#
# The recursive descent parser class.
#   Contains the &quot;recognizer&quot; methods, which implement the grammar
#   rules (above), one recognizer method for each production rule.
#
class ProgParser:
    def __init__(self):
        pass

    def parseFile(self, infileName):
        self.infileName = infileName
        self.tokens = None
        self.tokenType = NoneTokType
        self.token = ''
        self.lineNo = -1
        self.infile = file(self.infileName, 'r')
        self.tokens = genTokens(self.infile)
        try:
            self.tokenType, self.token, self.lineNo = self.tokens.next()
        except StopIteration:
            raise RuntimeError, 'Empty file'
        result = self.prog_reco()
        self.infile.close()
        self.infile = None
        return result

    def parseStream(self, instream):
        self.tokens = genTokens(instream, '&lt;instream&gt;')
        try:
            self.tokenType, self.token, self.lineNo = self.tokens.next()
        except StopIteration:
            raise RuntimeError, 'Empty file'
        result = self.prog_reco()
        return result

    def prog_reco(self):
        commandList = []
        while 1:
            result = self.command_reco()
            if not result:
                break
            commandList.append(result)
        return ASTNode(ProgNodeType, commandList)

    def command_reco(self):
        if self.tokenType == EOFTokType:
            return None
        result = self.func_call_reco()
        return ASTNode(CommandNodeType, result)

    def func_call_reco(self):
        if self.tokenType == WordTokType:
            term = ASTNode(TermNodeType, self.token)
            self.tokenType, self.token, self.lineNo = self.tokens.next()
            if self.tokenType == LParTokType:
                self.tokenType, self.token, self.lineNo = self.tokens.next()
                result = self.func_call_list_reco()
                if result:
                    if self.tokenType == RParTokType:
                        self.tokenType, self.token, self.lineNo = \
                            self.tokens.next()
                        return ASTNode(FuncCallNodeType, term, result)
                    else:
                        raise ParseError(self.lineNo, 'missing right paren')
                else:
                    raise ParseError(self.lineNo, 'bad func call list')
            else:
                raise ParseError(self.lineNo, 'missing left paren')
        else:
            return None

    def func_call_list_reco(self):
        terms = []
        while 1:
            result = self.func_call_reco()
            if not result:
                break
            terms.append(result)
            if self.tokenType != CommaTokType:
                break
            self.tokenType, self.token, self.lineNo = self.tokens.next()
        return ASTNode(FuncCallListNodeType, terms)

#
# The parse error exception class.
#
class ParseError(Exception):
    def __init__(self, lineNo, msg):
        RuntimeError.__init__(self, msg)
        self.lineNo = lineNo
        self.msg = msg
    def getLineNo(self):
        return self.lineNo
    def getMsg(self):
        return self.msg

def is_word(token):
    for letter in token:
        if letter not in string.ascii_letters:
            return None
    return 1

#
# Generate the tokens.
# Usage:
#    gen = genTokens(infile)
#    tokType, tok, lineNo = gen.next()
#    ...
def genTokens(infile):
    lineNo = 0
    while 1:
        lineNo += 1
        try:
            line = infile.next()
        except:
            yield (EOFTokType, None, lineNo)
        toks = line.split()
        for tok in toks:
            if is_word(tok):
                tokType = WordTokType
            elif tok == '(':
                tokType = LParTokType
            elif tok == ')':
                tokType = RParTokType
            elif tok == ',':
                tokType = CommaTokType
            yield (tokType, tok, lineNo)

def test(infileName):
    parser = ProgParser()
    #ipshell('(test) #1\nCtrl-D to exit')
    result = None
    try:
        result = parser.parseFile(infileName)
    except ParseError, exp:
        sys.stderr.write('ParseError: (%d) %s\n' % \
            (exp.getLineNo(), exp.getMsg()))
    if result:
        result.show(0)

def usage():
    print __doc__
    sys.exit(1)

def main():
    args = sys.argv[1:]
    try:
        opts, args = getopt.getopt(args, 'h', ['help'])
    except:
        usage()
    relink = 1
    for opt, val in opts:
        if opt in ('-h', '--help'):
            usage()
    if len(args) != 1:
        usage()
    inputfile = args[0]
    test(inputfile)

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
</pre>
<p>Comments and explanation:</p>
<ul class="simple">
<li>The tokenizer is a Python generator. It returns a Python generator
that can produce &quot;(tokType, tok, lineNo)&quot; tuples. Our tokenizer is
so simple-minded that we have to separate all of our tokens with
whitespace. (A little later, we'll see how to use Plex to overcome
this limitation.)</li>
<li>The parser class (ProgParser) contains the recognizer methods that
implement the production rules. Each of these methods recognizes a
syntactic construct defined by a rule. In our example, these methods
have names that end with &quot;_reco&quot;.</li>
<li>We could have, alternatively, implemented our recognizers as global
functions, instead of as methods in a class. However, using a class
gives us a place to &quot;hang&quot; the variables that are needed across
methods and saves us from having to use (&quot;evil&quot;) global variables.</li>
<li>A recognizer method recognizes terminals (syntactic elements on
the right-hand side of the grammar rule for which there is no
grammar rule) by (1) checking the token type and the token value,
and then (2) calling the tokenizer to get the next token (because it
has consumed a token).</li>
<li>A recognizer method checks for and processes a non-terminal
(syntactic elements on the right-hand side for which there is a
grammar rule) by calling the recognizer method that implements that
non-terminal.</li>
<li>If a recognizer method finds a syntax error, it raises an exception
of class ParserError.</li>
<li>Since our example recursive descent parser creates an AST (an
abstract syntax tree), whenever a recognizer method successfully
recognizes a syntactic construct, it creates an instance of class
ASTNode to represent it and returns that instance to its caller. The
instance of ASTNode has a node type and contains child nodes which
were constructed by recognizer methods called by this one (i.e. that
represent non-terminals on the right-hand side of a grammar rule).</li>
<li>Each time a recognizer method &quot;consumes a token&quot;, it calls the
tokenizer to get the next token (and token type and line number).</li>
<li>The tokenizer returns a token type in addition to the token
value. It also returns a line number for error reporting.</li>
<li>The syntax tree is constructed from instances of class ASTNode.</li>
<li>The ASTNode class has a show method, which walks the AST and
produces output.  You can imagine that a similar method could do
code generation. And, you should consider the possibility of writing
analogous tree walk methods that perform tasks such as optimization,
annotation of the AST, etc.</li>
</ul>
<p>And, here is a sample of the data we can apply this parser to:</p>
<pre class="literal-block">
aaa ( )
bbb ( ccc ( ) )
ddd ( eee ( ) , fff ( ggg ( ) , hhh ( ) , iii ( ) ) )
</pre>
<p>And, if we run the parser on the this input data, we see:</p>
<pre class="literal-block">
$ python workbook045.py workbook045.data
Node -- Type ProgNodeType
    Node -- Type CommandNodeType
        Node -- Type FuncCallNodeType
            Node -- Type TermNodeType
                Child: aaa
            Node -- Type FuncCallListNodeType
    Node -- Type CommandNodeType
        Node -- Type FuncCallNodeType
            Node -- Type TermNodeType
                Child: bbb
            Node -- Type FuncCallListNodeType
                Node -- Type FuncCallNodeType
                    Node -- Type TermNodeType
                        Child: ccc
                    Node -- Type FuncCallListNodeType
    Node -- Type CommandNodeType
        Node -- Type FuncCallNodeType
            Node -- Type TermNodeType
                Child: ddd
            Node -- Type FuncCallListNodeType
                Node -- Type FuncCallNodeType
                    Node -- Type TermNodeType
                        Child: eee
                    Node -- Type FuncCallListNodeType
                Node -- Type FuncCallNodeType
                    Node -- Type TermNodeType
                        Child: fff
                    Node -- Type FuncCallListNodeType
                        Node -- Type FuncCallNodeType
                            Node -- Type TermNodeType
                                Child: ggg
                            Node -- Type FuncCallListNodeType
                        Node -- Type FuncCallNodeType
                            Node -- Type TermNodeType
                                Child: hhh
                            Node -- Type FuncCallListNodeType
                        Node -- Type FuncCallNodeType
                            Node -- Type TermNodeType
                                Child: iii
                            Node -- Type FuncCallListNodeType
</pre>
</div>
<div class="section" id="creating-a-lexer-tokenizer-with-plex">
<h3><a class="toc-backref" href="#id144">2.6.3&nbsp;&nbsp;&nbsp;Creating a lexer/tokenizer with Plex</a></h3>
<p>Lexical analysis -- The tokenizer in our recursive descent parser
example was (for demonstration purposes) overly simple. You can always
write more complex tokenizers by hand. However, for more complex (and
real) tokenizers, you may want to use a tool to build your tokenizer.</p>
<p>In this section we'll describe Plex and use it to produce a tokenizer
for our recursive descent parser.</p>
<p>You can obtain Plex at
<a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/Plex/">http://www.cosc.canterbury.ac.nz/~greg/python/Plex/</a>.</p>
<p>In order to use it, you may want to add Plex-1.1.4/Plex to your PYTHONPATH.</p>
<p>Here is a simple example from the Plex tutorial:</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;
Sample Plex lexer

Usage:
    python plex_example.py inputfile
&quot;&quot;&quot;

import sys
import Plex

def count_lines(scanner, text):
    scanner.line_count += 1
    print '-' * 60

def test(infileName):
    letter = Plex.Range(&quot;AZaz&quot;)
    digit =  Plex.Range(&quot;09&quot;)
    name = letter +  Plex.Rep(letter | digit)
    number =  Plex.Rep1(digit)
    space =  Plex.Any(&quot; \t&quot;)
    endline = Plex.Str('\n')
    #comment =  Plex.Str('&quot;') +  Plex.Rep( Plex.AnyBut('&quot;')) +  Plex.Str('&quot;')
    resword =  Plex.Str(&quot;if&quot;, &quot;then&quot;, &quot;else&quot;, &quot;end&quot;)
    lexicon =  Plex.Lexicon([
        (endline,               count_lines),
        (resword,               'keyword'),
        (name,                  'ident'),
        (number,                'int'),
        ( Plex.Any(&quot;+-*/=&lt;&gt;&quot;),  'operator'),
        (space,                 Plex.IGNORE),
        #(comment,               'comment'),
        (Plex.Str('('),         'lpar'),
        (Plex.Str(')'),         'rpar'),
        # comments surrounded by (* and *)
        (Plex.Str(&quot;(*&quot;),        Plex.Begin('comment')),
        Plex.State('comment', [
            (Plex.Str(&quot;*)&quot;), Plex.Begin('')),
            (Plex.AnyChar,   Plex.IGNORE),
            ]),
    ])
    infile = open(infileName, &quot;r&quot;)
    scanner =  Plex.Scanner(lexicon, infile, infileName)
    scanner.line_count = 0
    while True:
        token = scanner.read()
        if token[0] is None:
            break
        position = scanner.position()
        posstr = ('(%d, %d)' % (position[1], position[2], )).ljust(10)
        tokstr = '&quot;%s&quot;' % token[1]
        tokstr = tokstr.ljust(20)
        print '%s tok: %s tokType: %s' % (posstr, tokstr, token[0],)
    print 'line_count: %d' % scanner.line_count


def usage():
    print __doc__
    sys.exit(1)

def main():
    args = sys.argv[1:]
    if len(args) != 1:
        usage()
    infileName = args[0]
    test(infileName)

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
</pre>
<p>Here is a bit of data on which we can use the above lexer:</p>
<pre class="literal-block">
mass = (height * (* some comment *) width * depth) / density
totalmass = totalmass + mass
</pre>
<p>And, when we apply the above test program to this data, here is what
we see:</p>
<pre class="literal-block">
$ python plex_example.py plex_example.data
(1, 0)     tok: &quot;mass&quot;               tokType: ident
(1, 5)     tok: &quot;=&quot;                  tokType: operator
(1, 7)     tok: &quot;(&quot;                  tokType: lpar
(1, 8)     tok: &quot;height&quot;             tokType: ident
(1, 15)    tok: &quot;*&quot;                  tokType: operator
(1, 36)    tok: &quot;width&quot;              tokType: ident
(1, 42)    tok: &quot;*&quot;                  tokType: operator
(1, 44)    tok: &quot;depth&quot;              tokType: ident
(1, 49)    tok: &quot;)&quot;                  tokType: rpar
(1, 51)    tok: &quot;/&quot;                  tokType: operator
(1, 53)    tok: &quot;density&quot;            tokType: ident
------------------------------------------------------------
(2, 0)     tok: &quot;totalmass&quot;          tokType: ident
(2, 10)    tok: &quot;=&quot;                  tokType: operator
(2, 12)    tok: &quot;totalmass&quot;          tokType: ident
(2, 22)    tok: &quot;+&quot;                  tokType: operator
(2, 24)    tok: &quot;mass&quot;               tokType: ident
------------------------------------------------------------
line_count: 2
</pre>
<p>Comments and explanation:</p>
<ul class="simple">
<li>Create a lexicon from scanning patterns.</li>
<li>See the Plex tutorial and reference (and below) for more information
on how to construct the patterns that match various tokens.</li>
<li>Create a scanner with a lexicon, an input file, and an input file
name.</li>
<li>The call &quot;scanner.read()&quot; gets the next token. It returns a tuple
containing (1) the token value and (2) the token type.</li>
<li>The call &quot;scanner.position()&quot; gets the position of the current
token. It returns a tuple containing (1) the input file name, (2)
the line number, and (3) the column number.</li>
<li>We can execute a method when a given token is found by specifying
the function as the token action.  In our example, the function is
count_lines.  Maintaining a line count is actually unneeded, since
the position gives us this information.  However, notice how we
are able to maintain a value (in our case <tt class="docutils literal">line_count</tt>) as an
attribute of the scanner.</li>
</ul>
<p>And, here are some comments on constructing the patterns used in a
lexicon:</p>
<ul class="simple">
<li><tt class="docutils literal">Plex.Range</tt> constructs a pattern that matches any character in
the range.</li>
<li><tt class="docutils literal">Plex.Rep</tt> constructs a pattern that matches a sequence of zero
or more items.</li>
<li><tt class="docutils literal">Plex.Rep1</tt> constructs a pattern that matches a sequence of one
or more items.</li>
<li><tt class="docutils literal">pat1 + pat2</tt> constructs a pattern that matches a sequence
containing <tt class="docutils literal">pat1</tt> followed by <tt class="docutils literal">pat2</tt>.</li>
<li><tt class="docutils literal">pat1 | pat2</tt> constructs a pattern that matches either <tt class="docutils literal">pat1</tt>
or <tt class="docutils literal">pat2</tt>.</li>
<li><tt class="docutils literal">Plex.Any</tt> constructs a pattern that matches any one character
in its argument.</li>
</ul>
<p>Now let's revisit our recursive descent parser, this time with a
tokenizer built with Plex. The tokenizer is trivial, but will serve as
an example of how to hook it into a parser:</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;
A recursive descent parser example using Plex.
This example uses Plex to implement a tokenizer.

Usage:
    python python_201_rparser_plex.py [options] &lt;inputfile&gt;
Options:
    -h, --help      Display this help message.
Example:
    python python_201_rparser_plex.py myfile.txt

The grammar:

    Prog ::= Command | Command Prog
    Command ::= Func_call
    Func_call ::= Term '(' Func_call_list ')'
    Func_call_list ::= Func_call | Func_call ',' Func_call_list
    Term = &lt;word&gt;

&quot;&quot;&quot;

import sys, string, types
import getopt
import Plex

## from IPython.Shell import IPShellEmbed
## ipshell = IPShellEmbed((),
##     banner = '&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Into IPython &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;',
##     exit_msg = '&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Out of IPython &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;')

#
# Constants
#

# AST node types
NoneNodeType =         0
ProgNodeType =         1
CommandNodeType =      2
FuncCallNodeType =     3
FuncCallListNodeType = 4
TermNodeType =         5

# Token types
NoneTokType =  0
LParTokType =  1
RParTokType =  2
WordTokType =  3
CommaTokType = 4
EOFTokType =   5

# Dictionary to map node type values to node type names
NodeTypeDict = {
    NoneNodeType:         'NoneNodeType',
    ProgNodeType:         'ProgNodeType',
    CommandNodeType:      'CommandNodeType',
    FuncCallNodeType:     'FuncCallNodeType',
    FuncCallListNodeType: 'FuncCallListNodeType',
    TermNodeType:         'TermNodeType',
    }

#
# Representation of a node in the AST (abstract syntax tree).
#
class ASTNode:
    def __init__(self, nodeType, *args):
        self.nodeType = nodeType
        self.children = []
        for item in args:
            self.children.append(item)
    def show(self, level):
        self.showLevel(level)
        print 'Node -- Type %s' % NodeTypeDict[self.nodeType]
        level += 1
        for child in self.children:
            if isinstance(child, ASTNode):
                child.show(level)
            elif type(child) == types.ListType:
                for item in child:
                    item.show(level)
            else:
                self.showLevel(level)
                print 'Child:', child
    def showLevel(self, level):
        for idx in range(level):
            print '   ',

#
# The recursive descent parser class.
#   Contains the &quot;recognizer&quot; methods, which implement the grammar
#   rules (above), one recognizer method for each production rule.
#
class ProgParser:
    def __init__(self):
        self.tokens = None
        self.tokenType = NoneTokType
        self.token = ''
        self.lineNo = -1
        self.infile = None
        self.tokens = None

    def parseFile(self, infileName):
        self.tokens = None
        self.tokenType = NoneTokType
        self.token = ''
        self.lineNo = -1
        self.infile = file(infileName, 'r')
        self.tokens = genTokens(self.infile, infileName)
        try:
            self.tokenType, self.token, self.lineNo = self.tokens.next()
        except StopIteration:
            raise RuntimeError, 'Empty file'
        result = self.prog_reco()
        self.infile.close()
        self.infile = None
        return result

    def parseStream(self, instream):
        self.tokens = None
        self.tokenType = NoneTokType
        self.token = ''
        self.lineNo = -1
        self.tokens = genTokens(self.instream, '&lt;stream&gt;')
        try:
            self.tokenType, self.token, self.lineNo = self.tokens.next()
        except StopIteration:
            raise RuntimeError, 'Empty stream'
        result = self.prog_reco()
        self.infile.close()
        self.infile = None
        return result

    def prog_reco(self):
        commandList = []
        while 1:
            result = self.command_reco()
            if not result:
                break
            commandList.append(result)
        return ASTNode(ProgNodeType, commandList)

    def command_reco(self):
        if self.tokenType == EOFTokType:
            return None
        result = self.func_call_reco()
        return ASTNode(CommandNodeType, result)

    def func_call_reco(self):
        if self.tokenType == WordTokType:
            term = ASTNode(TermNodeType, self.token)
            self.tokenType, self.token, self.lineNo = self.tokens.next()
            if self.tokenType == LParTokType:
                self.tokenType, self.token, self.lineNo = self.tokens.next()
                result = self.func_call_list_reco()
                if result:
                    if self.tokenType == RParTokType:
                        self.tokenType, self.token, self.lineNo = \
                            self.tokens.next()
                        return ASTNode(FuncCallNodeType, term, result)
                    else:
                        raise ParseError(self.lineNo, 'missing right paren')
                else:
                    raise ParseError(self.lineNo, 'bad func call list')
            else:
                raise ParseError(self.lineNo, 'missing left paren')
        else:
            return None

    def func_call_list_reco(self):
        terms = []
        while 1:
            result = self.func_call_reco()
            if not result:
                break
            terms.append(result)
            if self.tokenType != CommaTokType:
                break
            self.tokenType, self.token, self.lineNo = self.tokens.next()
        return ASTNode(FuncCallListNodeType, terms)

#
# The parse error exception class.
#
class ParseError(Exception):
    def __init__(self, lineNo, msg):
        RuntimeError.__init__(self, msg)
        self.lineNo = lineNo
        self.msg = msg
    def getLineNo(self):
        return self.lineNo
    def getMsg(self):
        return self.msg

#
# Generate the tokens.
# Usage - example
#    gen = genTokens(infile)
#    tokType, tok, lineNo = gen.next()
#    ...
def genTokens(infile, infileName):
    letter = Plex.Range(&quot;AZaz&quot;)
    digit =  Plex.Range(&quot;09&quot;)
    name = letter +  Plex.Rep(letter | digit)
    lpar = Plex.Str('(')
    rpar = Plex.Str(')')
    comma = Plex.Str(',')
    comment = Plex.Str(&quot;#&quot;) + Plex.Rep(Plex.AnyBut(&quot;\n&quot;))
    space = Plex.Any(&quot; \t\n&quot;)
    lexicon = Plex.Lexicon([
        (name,      'word'),
        (lpar,      'lpar'),
        (rpar,      'rpar'),
        (comma,     'comma'),
        (comment,   Plex.IGNORE),
        (space,     Plex.IGNORE),
    ])
    scanner = Plex.Scanner(lexicon, infile, infileName)
    while 1:
        tokenType, token = scanner.read()
        name, lineNo, columnNo = scanner.position()
        if tokenType == None:
            tokType = EOFTokType
            token = None
        elif tokenType == 'word':
            tokType = WordTokType
        elif tokenType == 'lpar':
            tokType = LParTokType
        elif tokenType == 'rpar':
            tokType = RParTokType
        elif tokenType == 'comma':
            tokType = CommaTokType
        else:
            tokType = NoneTokType
        tok = token
        yield (tokType, tok, lineNo)

def test(infileName):
    parser = ProgParser()
    #ipshell('(test) #1\nCtrl-D to exit')
    result = None
    try:
        result = parser.parseFile(infileName)
    except ParseError, exp:
        sys.stderr.write('ParseError: (%d) %s\n' % \
            (exp.getLineNo(), exp.getMsg()))
    if result:
        result.show(0)

def usage():
    print __doc__
    sys.exit(-1)

def main():
    args = sys.argv[1:]
    try:
        opts, args = getopt.getopt(args, 'h', ['help'])
    except:
        usage()
    for opt, val in opts:
        if opt in ('-h', '--help'):
            usage()
    if len(args) != 1:
        usage()
    infileName = args[0]
    test(infileName)

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
</pre>
<p>And, here is a sample of the data we can apply this parser to:</p>
<pre class="literal-block">
# Test for recursive descent parser and Plex.
# Command #1
aaa()
# Command #2
bbb (ccc())    # An end of line comment.
# Command #3
ddd(eee(), fff(ggg(), hhh(), iii()))
# End of test
</pre>
<p>And, when we run our parser, it produces the following:</p>
<pre class="literal-block">
$ python plex_recusive.py plex_recusive.data
Node -- Type ProgNodeType
    Node -- Type CommandNodeType
        Node -- Type FuncCallNodeType
            Node -- Type TermNodeType
                Child: aaa
            Node -- Type FuncCallListNodeType
    Node -- Type CommandNodeType
        Node -- Type FuncCallNodeType
            Node -- Type TermNodeType
                Child: bbb
            Node -- Type FuncCallListNodeType
                Node -- Type FuncCallNodeType
                    Node -- Type TermNodeType
                        Child: ccc
                    Node -- Type FuncCallListNodeType
    Node -- Type CommandNodeType
        Node -- Type FuncCallNodeType
            Node -- Type TermNodeType
                Child: ddd
            Node -- Type FuncCallListNodeType
                Node -- Type FuncCallNodeType
                    Node -- Type TermNodeType
                        Child: eee
                    Node -- Type FuncCallListNodeType
                Node -- Type FuncCallNodeType
                    Node -- Type TermNodeType
                        Child: fff
                    Node -- Type FuncCallListNodeType
                        Node -- Type FuncCallNodeType
                            Node -- Type TermNodeType
                                Child: ggg
                            Node -- Type FuncCallListNodeType
                        Node -- Type FuncCallNodeType
                            Node -- Type TermNodeType
                                Child: hhh
                            Node -- Type FuncCallListNodeType
                        Node -- Type FuncCallNodeType
                            Node -- Type TermNodeType
                                Child: iii
                            Node -- Type FuncCallListNodeType
</pre>
<p>Comments:</p>
<ul class="simple">
<li>We can now put comments in our input, and they will be
ignored. Comments begin with a &quot;#&quot; and continue to the end of
line. See the definition of comment in function genTokens.</li>
<li>This tokenizer does not require us to separate tokens with
whitespace as did the simple tokenizer in the earlier version of our
recursive descent parser.</li>
<li>The changes we made over the earlier version were to:<ol class="arabic">
<li>Import Plex.</li>
<li>Replace the definition of the tokenizer function genTokens.</li>
<li>Change the call to genTokens so that the call passes in the file
name, which is needed to create the scanner.</li>
</ol>
</li>
<li>Our new version of genTokens does the following:<ol class="arabic">
<li>Create patterns for scanning.</li>
<li>Create a lexicon (an instance of Plex.Lexicon), which uses the
patterns.</li>
<li>Create a scanner (an instance of Plex.Scanner), which uses the
lexicon.</li>
<li>Execute a loop that reads tokens (from the scanner) and &quot;yields&quot;
each one.</li>
</ol>
</li>
</ul>
</div>
<div class="section" id="a-survey-of-existing-tools">
<h3><a class="toc-backref" href="#id145">2.6.4&nbsp;&nbsp;&nbsp;A survey of existing tools</a></h3>
<p>For complex parsing tasks, you may want to consider the following
tools:</p>
<ul class="simple">
<li><a class="reference external" href="http://gadfly.sourceforge.net/kwParsing.html">kwParsing -- A parser generator in Python --
http://gadfly.sourceforge.net/kwParsing.html</a></li>
<li><a class="reference external" href="http://systems.cs.uchicago.edu/ply/">PLY -- Python Lex-Yacc --
http://systems.cs.uchicago.edu/ply/</a></li>
<li><a class="reference external" href="http://starship.python.net/crew/scott/PyLR.html">PyLR -- Fast LR parsing in python --
http://starship.python.net/crew/scott/PyLR.html</a></li>
<li><a class="reference external" href="http://theory.stanford.edu/~amitp/Yapps/">Yapps -- The Yapps Parser Generator System --
http://theory.stanford.edu/~amitp/Yapps/</a></li>
</ul>
<p>And, for lexical analysis, you may also want to look here:</p>
<ul class="simple">
<li><a class="reference external" href="http://effbot.org/zone/xml-scanner.htm">Using Regular Expressions for Lexical Analysis --
http://effbot.org/zone/xml-scanner.htm</a></li>
<li><a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/Plex/">Plex --
http://www.cosc.canterbury.ac.nz/~greg/python/Plex/.</a></li>
</ul>
<p>In the sections below, we give examples and notes about the use of
PLY and pyparsing.</p>
</div>
<div class="section" id="creating-a-parser-with-ply">
<h3><a class="toc-backref" href="#id146">2.6.5&nbsp;&nbsp;&nbsp;Creating a parser with PLY</a></h3>
<p>In this section we will show how to implement our parser example with
PLY.</p>
<p>First down-load PLY. It is available here:
<a class="reference external" href="http://www.dabeaz.com/ply/">PLY (Python Lex-Yacc) --
http://www.dabeaz.com/ply/</a></p>
<p>Then add the PLY directory to your PYTHONPATH.</p>
<p>Learn how to construct lexers and parsers with PLY by reading
<tt class="docutils literal">doc/ply.html</tt> in the distribution of PLY and by looking at the
examples in the distribution.</p>
<p>For those of you who want a more complex example, see A Python
Parser for the RELAX NG Compact Syntax, which is implemented with
PLY.</p>
<p>Now, here is our example parser. Comments and explanations are
below:</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;
A parser example.
This example uses PLY to implement a lexer and parser.

The grammar:

    Prog ::= Command*
    Command ::= Func_call
    Func_call ::= Term '(' Func_call_list ')'
    Func_call_list ::= Func_call*
    Term = &lt;word&gt;

Here is a sample &quot;program&quot; to use as input:

    # Test for recursive descent parser and Plex.
    # Command #1
    aaa()
    # Command #2
    bbb (ccc())    # An end of line comment.
    # Command #3
    ddd(eee(), fff(ggg(), hhh(), iii()))
    # End of test
&quot;&quot;&quot;

import sys
import types
import getopt
import ply.lex as lex
import ply.yacc as yacc

#
# Globals
#

startlinepos = 0

#
# Constants
#

# AST node types
NoneNodeType =         0
ProgNodeType =         1
CommandNodeType =      2
CommandListNodeType =  3
FuncCallNodeType =     4
FuncCallListNodeType = 5
TermNodeType =         6

# Dictionary to map node type values to node type names
NodeTypeDict = {
    NoneNodeType:         'NoneNodeType',
    ProgNodeType:         'ProgNodeType',
    CommandNodeType:      'CommandNodeType',
    CommandListNodeType:  'CommandListNodeType',
    FuncCallNodeType:     'FuncCallNodeType',
    FuncCallListNodeType: 'FuncCallListNodeType',
    TermNodeType:         'TermNodeType',
    }

#
# Representation of a node in the AST (abstract syntax tree).
#
class ASTNode:
    def __init__(self, nodeType, *args):
        self.nodeType = nodeType
        self.children = []
        for item in args:
            self.children.append(item)
    def append(self, item):
        self.children.append(item)
    def show(self, level):
        self.showLevel(level)
        print 'Node -- Type: %s' % NodeTypeDict[self.nodeType]
        level += 1
        for child in self.children:
            if isinstance(child, ASTNode):
                child.show(level)
            elif type(child) == types.ListType:
                for item in child:
                    item.show(level)
            else:
                self.showLevel(level)
                print 'Value:', child
    def showLevel(self, level):
        for idx in range(level):
            print '   ',

#
# Exception classes
#
class LexerError(Exception):
    def __init__(self, msg, lineno, columnno):
        self.msg = msg
        self.lineno = lineno
        self.columnno = columnno
    def show(self):
        sys.stderr.write('Lexer error (%d, %d) %s\n' % \
            (self.lineno, self.columnno, self.msg))

class ParserError(Exception):
    def __init__(self, msg, lineno, columnno):
        self.msg = msg
        self.lineno = lineno
        self.columnno = columnno
    def show(self):
        sys.stderr.write('Parser error (%d, %d) %s\n' % \
            (self.lineno, self.columnno, self.msg))

#
# Lexer specification
#
tokens = (
    'NAME',
    'LPAR','RPAR',
    'COMMA',
    )

# Tokens

t_LPAR =   r'\('
t_RPAR =   r'\)'
t_COMMA =  r'\,'
t_NAME =   r'[a-zA-Z_][a-zA-Z0-9_]*'

# Ignore whitespace
t_ignore = ' \t'

# Ignore comments ('#' to end of line)
def t_COMMENT(t):
    r'\#[^\n]*'
    pass

def t_newline(t):
    r'\n+'
    global startlinepos
    startlinepos = t.lexer.lexpos - 1
    t.lineno += t.value.count(&quot;\n&quot;)

def t_error(t):
    global startlinepos
    msg = &quot;Illegal character '%s'&quot; % (t.value[0])
    columnno = t.lexer.lexpos - startlinepos
    raise LexerError(msg, t.lineno, columnno)

#
# Parser specification
#
def p_prog(t):
    'prog : command_list'
    t[0] = ASTNode(ProgNodeType, t[1])

def p_command_list_1(t):
    'command_list : command'
    t[0] = ASTNode(CommandListNodeType, t[1])

def p_command_list_2(t):
    'command_list : command_list command'
    t[1].append(t[2])
    t[0] = t[1]

def p_command(t):
    'command : func_call'
    t[0] = ASTNode(CommandNodeType, t[1])

def p_func_call_1(t):
    'func_call : term LPAR RPAR'
    t[0] = ASTNode(FuncCallNodeType, t[1])

def p_func_call_2(t):
    'func_call : term LPAR func_call_list RPAR'
    t[0] = ASTNode(FuncCallNodeType, t[1],  t[3])

def p_func_call_list_1(t):
    'func_call_list : func_call'
    t[0] = ASTNode(FuncCallListNodeType, t[1])

def p_func_call_list_2(t):
    'func_call_list : func_call_list COMMA func_call'
    t[1].append(t[3])
    t[0] = t[1]

def p_term(t):
    'term : NAME'
    t[0] = ASTNode(TermNodeType, t[1])

def p_error(t):
    global startlinepos
    msg = &quot;Syntax error at '%s'&quot; % t.value
    columnno = t.lexer.lexpos - startlinepos
    raise ParserError(msg, t.lineno, columnno)

#
# Parse the input and display the AST (abstract syntax tree)
#
def parse(infileName):
    startlinepos = 0
    # Build the lexer
    lex.lex(debug=1)
    # Build the parser
    yacc.yacc()
    # Read the input
    infile = file(infileName, 'r')
    content = infile.read()
    infile.close()
    try:
        # Do the parse
        result = yacc.parse(content)
        # Display the AST
        result.show(0)
    except LexerError, exp:
        exp.show()
    except ParserError, exp:
        exp.show()

USAGE_TEXT = __doc__

def usage():
    print USAGE_TEXT
    sys.exit(-1)

def main():
    args = sys.argv[1:]
    try:
        opts, args = getopt.getopt(args, 'h', ['help'])
    except:
        usage()
    relink = 1
    for opt, val in opts:
        if opt in ('-h', '--help'):
            usage()
    if len(args) != 1:
        usage()
    infileName = args[0]
    parse(infileName)

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
</pre>
<p>Applying this parser to the following input:</p>
<pre class="literal-block">
# Test for recursive descent parser and Plex.
# Command #1
aaa()
# Command #2
bbb (ccc())    # An end of line comment.
# Command #3
ddd(eee(), fff(ggg(), hhh(), iii()))
# End of test
</pre>
<p>produces the following output:</p>
<pre class="literal-block">
Node -- Type: ProgNodeType
    Node -- Type: CommandListNodeType
        Node -- Type: CommandNodeType
            Node -- Type: FuncCallNodeType
                Node -- Type: TermNodeType
                    Value: aaa
        Node -- Type: CommandNodeType
            Node -- Type: FuncCallNodeType
                Node -- Type: TermNodeType
                    Value: bbb
                Node -- Type: FuncCallListNodeType
                    Node -- Type: FuncCallNodeType
                        Node -- Type: TermNodeType
                            Value: ccc
        Node -- Type: CommandNodeType
            Node -- Type: FuncCallNodeType
                Node -- Type: TermNodeType
                    Value: ddd
                Node -- Type: FuncCallListNodeType
                    Node -- Type: FuncCallNodeType
                        Node -- Type: TermNodeType
                            Value: eee
                    Node -- Type: FuncCallNodeType
                        Node -- Type: TermNodeType
                            Value: fff
                        Node -- Type: FuncCallListNodeType
                            Node -- Type: FuncCallNodeType
                                Node -- Type: TermNodeType
                                    Value: ggg
                            Node -- Type: FuncCallNodeType
                                Node -- Type: TermNodeType
                                    Value: hhh
                            Node -- Type: FuncCallNodeType
                                Node -- Type: TermNodeType
                                    Value: iii
</pre>
<p>Comments and explanation:</p>
<ul class="simple">
<li>Creating the syntax tree -- Basically, each rule (1) recognizes a
non-terminal, (2) creates a node (possibly using the values from the
right-hand side of the rule), and (3) returns the node by setting
the value of t[0]. A deviation from this is the processing of
sequences, discussed below.</li>
<li>Sequences -- p_command_list_1 and p_command_list_1 show how to
handle sequences of items. In this case:<ul>
<li>p_command_list_1 recognizes a command and creates an instance of
ASTNode with type CommandListNodeType and adds the command to it
as a child, and</li>
<li>p_command_list_2 recognizes an additional command and adds it (as
a child) to the instance of ASTNode that represents the list.</li>
</ul>
</li>
<li>Distinguishing between different forms of the same rule -- In order
to process alternatives to the same production rule differently, we
use different functions with different implementations. For example,
we use:<ul>
<li>p_func_call_1 to recognize and process &quot;func_call : term LPAR
RPAR&quot; (a function call without arguments), and</li>
<li>p_func_call_2 to recognize and process &quot;func_call : term LPAR
func_call_list RPAR&quot; (a function call with arguments).</li>
</ul>
</li>
<li>Reporting errors -- Our parser reports the first error and
quits. We've done this by raising an exception when we find an
error. We implement two exception classes: LexerError and
ParserError. Implementing more than one exception class enables us
to distinguish between different classes of errors (note the
multiple except: clauses on the try: statement in function
parse). And, we use an instance of the exception class as a
container in order to &quot;bubble up&quot; information about the error
(e.g. a message, a line number, and a column number).</li>
</ul>
</div>
<div class="section" id="creating-a-parser-with-pyparsing">
<h3><a class="toc-backref" href="#id147">2.6.6&nbsp;&nbsp;&nbsp;Creating a parser with pyparsing</a></h3>
<p>pyparsing is a relatively new parsing package for Python. It was
implemented and is supported by Paul McGuire and it shows promise. It
appears especially easy to use and seems especially appropriate in
particular for quick parsing tasks, although it has features that make
some complex parsing tasks easy. It follows a very natural Python
style for constructing parsers.</p>
<p>Good documentation comes with the pyparsing distribution. See file
HowToUseParsing.html. So, I won't try to repeat that here. What
follows is an attempt to provide several quick examples to help you
solve simple parsing tasks as quickly as possible.</p>
<p>You will also want to look at the samples in the examples directory,
which are very helpful. My examples below are fairly simple. You can
see more of the ability of pyparsing to handle complex tasks in the
examples.</p>
<p>Where to get it - You can find pyparsing at:
<a class="reference external" href="http://pyparsing.wikispaces.com/">Pyparsing Wiki Home --
http://pyparsing.wikispaces.com/</a></p>
<p>How to install it - Put the pyparsing module somewhere on your
PYTHONPATH.</p>
<p>And now, here are a few examples.</p>
<div class="section" id="parsing-comma-delimited-lines">
<h4><a class="toc-backref" href="#id148">2.6.6.1&nbsp;&nbsp;&nbsp;Parsing comma-delimited lines</a></h4>
<p><strong>Note:</strong> This example is for demonstration purposes only.  If you
really to need to parse comma delimited fields, you can probably do
so much more easily with the <tt class="docutils literal">CSV</tt> (comma separated values) module
in the Python standard library.</p>
<p>Here is a simple grammar for lines containing fields separated by
commas:</p>
<pre class="literal-block">
import sys
from pyparsing import alphanums, ZeroOrMore, Word

fieldDef = Word(alphanums)
lineDef = fieldDef + ZeroOrMore(&quot;,&quot; + fieldDef)

def test():
    args = sys.argv[1:]
    if len(args) != 1:
        print 'usage: python pyparsing_test1.py &lt;datafile.txt&gt;'
        sys.exit(-1)
    infilename = sys.argv[1]
    infile = file(infilename, 'r')
    for line in infile:
        fields = lineDef.parseString(line)
        print fields

test()
</pre>
<p>Here is some sample data:</p>
<pre class="literal-block">
abcd,defg
11111,22222,33333
</pre>
<p>And, when we run our parser on this data file, here is what we see:</p>
<pre class="literal-block">
$ python comma_parser.py sample1.data
['abcd', ',', 'defg']
['11111', ',', '22222', ',', '33333']
</pre>
<p>Notes and explanation:</p>
<ul>
<li><p class="first">Note how the grammar is constructed from normal Python calls to
function and object/class constructors. I've constructed the parser
in-line because my example is simple, but constructing the parser
in a function or even a module might make sense for more complex
grammars. pyparsing makes it easy to use these these different
styles.</p>
</li>
<li><p class="first">Use &quot;+&quot; to specify a sequence. In our example, a <tt class="docutils literal">lineDef</tt> is a
<tt class="docutils literal">fieldDef</tt> followed by ....</p>
</li>
<li><p class="first">Use <tt class="docutils literal">ZeroOrMore</tt> to specify repetition. In our example, a
<tt class="docutils literal">lineDef</tt> is a <tt class="docutils literal">fieldDef</tt> followed by zero or more occurances
of comma and <tt class="docutils literal">fieldDef</tt>. There is also <tt class="docutils literal">OneOrMore</tt> when you
want to require at least one occurance.</p>
</li>
<li><p class="first">Parsing comma delimited text happens so frequently that pyparsing
provides a shortcut. Replace:</p>
<pre class="literal-block">
lineDef = fieldDef + ZeroOrMore(&quot;,&quot; + fieldDef)
</pre>
<p>with:</p>
<pre class="literal-block">
lineDef = delimitedList(fieldDef)
</pre>
<p>And note that delimitedList takes an optional argument <tt class="docutils literal">delim</tt>
used to specify the delimiter. The default is a comma.</p>
</li>
</ul>
</div>
<div class="section" id="parsing-functors">
<h4><a class="toc-backref" href="#id149">2.6.6.2&nbsp;&nbsp;&nbsp;Parsing functors</a></h4>
<p>This example parses expressions of the form <tt class="docutils literal">func(arg1, arg2,
arg3)</tt>:</p>
<pre class="literal-block">
from pyparsing import Word, alphas, alphanums, nums, ZeroOrMore, Literal

lparen = Literal(&quot;(&quot;)
rparen = Literal(&quot;)&quot;)
identifier = Word(alphas, alphanums + &quot;_&quot;)
integer  = Word( nums )
functor = identifier
arg = identifier | integer
args = arg + ZeroOrMore(&quot;,&quot; + arg)
expression = functor + lparen + args + rparen

def test():
    content = raw_input(&quot;Enter an expression: &quot;)
    parsedContent = expression.parseString(content)
    print parsedContent

test()
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>Use Literal to specify a fixed string that is to be matched
exactly. In our example, a lparen is a <tt class="docutils literal">(</tt>.</li>
<li>Word takes an optional second argument. With a single (string)
argument, it matches any contiguous word made up of characters in
the string. With two (string) arguments it matches a word whose
first character is in the first string and whose remaining
characters are in the second string. So, our definition of
identifier matches a word whose first character is an alpha and
whose remaining characters are alpha-numerics or underscore. As
another example, you can think of Word(&quot;0123456789&quot;) as analogous to
a regexp containing the pattern &quot;[0-9]+&quot;.</li>
<li>Use a vertical bar for alternation. In our example, an arg can be
either an identifier or an integer.</li>
</ul>
</div>
<div class="section" id="parsing-names-phone-numbers-etc">
<h4><a class="toc-backref" href="#id150">2.6.6.3&nbsp;&nbsp;&nbsp;Parsing names, phone numbers, etc.</a></h4>
<p>This example parses expressions having the following form:</p>
<pre class="literal-block">
Input format:
[name]         [phone]       [city, state zip]
Last, first    111-222-3333  city, ca 99999
</pre>
<p>Here is the parser:</p>
<pre class="literal-block">
import sys
from pyparsing import alphas, nums, ZeroOrMore, Word, Group, Suppress, Combine

lastname = Word(alphas)
firstname = Word(alphas)
city = Group(Word(alphas) + ZeroOrMore(Word(alphas)))
state = Word(alphas, exact=2)
zip = Word(nums, exact=5)

name = Group(lastname + Suppress(&quot;,&quot;) + firstname)
phone = Combine(Word(nums, exact=3) + &quot;-&quot; + Word(nums, exact=3) + &quot;-&quot; + Word(nums, exact=4))
location = Group(city + Suppress(&quot;,&quot;) + state + zip)

record = name + phone + location

def test():
    args = sys.argv[1:]
    if len(args) != 1:
        print 'usage: python pyparsing_test3.py &lt;datafile.txt&gt;'
        sys.exit(-1)
    infilename = sys.argv[1]
    infile = file(infilename, 'r')
    for line in infile:
        line = line.strip()
        if line and line[0] != &quot;#&quot;:
            fields = record.parseString(line)
            print fields

test()
</pre>
<p>And, here is some sample input:</p>
<pre class="literal-block">
Jabberer, Jerry          111-222-3333   Bakersfield, CA 95111
Kackler, Kerry           111-222-3334   Fresno, CA 95112
Louderdale, Larry        111-222-3335   Los Angeles, CA 94001
</pre>
<p>Here is output from parsing the above input:</p>
<pre class="literal-block">
[['Jabberer', 'Jerry'], '111-222-3333', [['Bakersfield'], 'CA', '95111']]
[['Kackler', 'Kerry'], '111-222-3334', [['Fresno'], 'CA', '95112']]
[['Louderdale', 'Larry'], '111-222-3335', [['Los', 'Angeles'], 'CA', '94001']]
</pre>
<p>Comments:</p>
<ul class="simple">
<li>We use the <tt class="docutils literal">len=n</tt> argument to the Word constructor to restict the
parser to accepting a specific number of characters, for example in
the zip code and phone number. Word also accepts <tt class="docutils literal">min=n'' and
``max=n</tt> to enable you to restrict the length of a word to within a
range.</li>
<li>We use Group to group the parsed results into sub-lists, for example
in the definition of city and name. Group enables us to organize the
parse results into simple parse trees.</li>
<li>We use Combine to join parsed results back into a single string. For
example, in the phone number, we can require dashes and yet join the
results back into a single string.</li>
<li>We use Suppress to remove unneeded sub-elements from parsed
results. For example, we do not need the comma between last and
first name.</li>
</ul>
</div>
<div class="section" id="a-more-complex-example">
<h4><a class="toc-backref" href="#id151">2.6.6.4&nbsp;&nbsp;&nbsp;A more complex example</a></h4>
<p>This example (thanks to Paul McGuire) parses a more complex structure
and produces a dictionary.</p>
<p>Here is the code:</p>
<pre class="literal-block">
from pyparsing import Literal, Word, Group, Dict, ZeroOrMore, alphas, nums,\
    delimitedList
import pprint

testData = &quot;&quot;&quot;
+-------+------+------+------+------+------+------+------+------+
|       |  A1  |  B1  |  C1  |  D1  |  A2  |  B2  |  C2  |  D2  |
+=======+======+======+======+======+======+======+======+======+
| min   |   7  |  43  |   7  |  15  |  82  |  98  |   1  |  37  |
| max   |  11  |  52  |  10  |  17  |  85  | 112  |   4  |  39  |
| ave   |   9  |  47  |   8  |  16  |  84  | 106  |   3  |  38  |
| sdev  |   1  |   3  |   1  |   1  |   1  |   3  |   1  |   1  |
+-------+------+------+------+------+------+------+------+------+
&quot;&quot;&quot;

# Define grammar for datatable
heading = (Literal(
&quot;+-------+------+------+------+------+------+------+------+------+&quot;) +
&quot;|       |  A1  |  B1  |  C1  |  D1  |  A2  |  B2  |  C2  |  D2  |&quot; +
&quot;+=======+======+======+======+======+======+======+======+======+&quot;).suppress()

vert = Literal(&quot;|&quot;).suppress()
number = Word(nums)
rowData = Group( vert + Word(alphas) + vert + delimitedList(number,&quot;|&quot;) +
vert )
trailing = Literal(
&quot;+-------+------+------+------+------+------+------+------+------+&quot;).suppress()

datatable = heading + Dict( ZeroOrMore(rowData) ) + trailing

def main():
    # Now parse data and print results
    data = datatable.parseString(testData)
    print &quot;data:&quot;, data
    print &quot;data.asList():&quot;,
    pprint.pprint(data.asList())
    print &quot;data keys:&quot;, data.keys()
    print &quot;data['min']:&quot;, data['min']
    print &quot;data.max:&quot;, data.max

if __name__ == '__main__':
    main()
</pre>
<p>When we run this, it produces the following:</p>
<pre class="literal-block">
data: [['min', '7', '43', '7', '15', '82', '98', '1', '37'],
 ['max', '11', '52', '10', '17', '85', '112', '4', '39'],
 ['ave', '9', '47', '8', '16', '84', '106', '3', '38'],
 ['sdev', '1', '3', '1', '1', '1', '3', '1', '1']]
data.asList():[['min', '7', '43', '7', '15', '82', '98', '1', '37'],
 ['max', '11', '52', '10', '17', '85', '112', '4', '39'],
 ['ave', '9', '47', '8', '16', '84', '106', '3', '38'],
 ['sdev', '1', '3', '1', '1', '1', '3', '1', '1']]
data keys: ['ave', 'min', 'sdev', 'max']
data['min']: ['7', '43', '7', '15', '82', '98', '1', '37']
data.max: ['11', '52', '10', '17', '85', '112', '4', '39']
</pre>
<p>Notes:</p>
<ul class="simple">
<li>Note the use of Dict to create a dictionary. The print statements
show how to get at the items in the dictionary.</li>
<li>Note how we can also get the parse results as a list by using method
asList.</li>
<li>Again, we use suppress to remove unneeded items from the parse
results.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="gui-applications">
<h2><a class="toc-backref" href="#id152">2.7&nbsp;&nbsp;&nbsp;GUI Applications</a></h2>
<div class="section" id="introduction">
<h3><a class="toc-backref" href="#id153">2.7.1&nbsp;&nbsp;&nbsp;Introduction</a></h3>
<p>This section will help you to put a GUI (graphical user interface) in
your Python program.</p>
<p>We will use a particular GUI library: PyGTK. We've chosen this because
it is reasonably light-weight and our goal is to embed light-weight
GUI interfaces in an (possibly) existing application.</p>
<p>For simpler GUI needs, consider EasyGUI, which is also described
below.</p>
<p>For more heavy-weight GUI needs (for example, complete GUI
applications), you may want to explore WxPython. See the WxPython home
page at: <a class="reference external" href="http://www.wxpython.org/">http://www.wxpython.org/</a></p>
</div>
<div class="section" id="pygtk">
<h3><a class="toc-backref" href="#id154">2.7.2&nbsp;&nbsp;&nbsp;PyGtk</a></h3>
<p>Information about PyGTK is here:
<a class="reference external" href="http://www.pygtk.org//">The PyGTK home page --
http://www.pygtk.org//</a>.</p>
<div class="section" id="a-simple-message-dialog-box">
<h4><a class="toc-backref" href="#id155">2.7.2.1&nbsp;&nbsp;&nbsp;A simple message dialog box</a></h4>
<p>In this section we explain how to pop up a simple dialog box from your
Python application.</p>
<p>To do this, do the following:</p>
<ol class="arabic simple">
<li>Import gtk into your Python module.</li>
<li>Define the dialog and its behavior.</li>
<li>Create an instance of the dialog.</li>
<li>Run the event loop.</li>
</ol>
<p>Here is a sample that displays a message box:</p>
<pre class="literal-block">
#!/usr/bin/env python

import sys
import getopt
import gtk

class MessageBox(gtk.Dialog):
    def __init__(self, message=&quot;&quot;, buttons=(), pixmap=None,
            modal= True):
        gtk.Dialog.__init__(self)
        self.connect(&quot;destroy&quot;, self.quit)
        self.connect(&quot;delete_event&quot;, self.quit)
        if modal:
            self.set_modal(True)
        hbox = gtk.HBox(spacing=5)
        hbox.set_border_width(5)
        self.vbox.pack_start(hbox)
        hbox.show()
        if pixmap:
            self.realize()
            pixmap = Pixmap(self, pixmap)
            hbox.pack_start(pixmap, expand=False)
            pixmap.show()
        label = gtk.Label(message)
        hbox.pack_start(label)
        label.show()
        for text in buttons:
            b = gtk.Button(text)
            b.set_flags(gtk.CAN_DEFAULT)
            b.set_data(&quot;user_data&quot;, text)
            b.connect(&quot;clicked&quot;, self.click)
            self.action_area.pack_start(b)
            b.show()
        self.ret = None
    def quit(self, *args):
        self.hide()
        self.destroy()
        gtk.main_quit()
    def click(self, button):
        self.ret = button.get_data(&quot;user_data&quot;)
        self.quit()

# create a message box, and return which button was pressed
def message_box(title=&quot;Message Box&quot;, message=&quot;&quot;, buttons=(), pixmap=None,
        modal= True):
    win = MessageBox(message, buttons, pixmap=pixmap, modal=modal)
    win.set_title(title)
    win.show()
    gtk.main()
    return win.ret

def test():
    result = message_box(title='Test #1',
        message='Here is your message',
        buttons=('Ok', 'Cancel'))
    print 'result:', result

USAGE_TEXT = &quot;&quot;&quot;
Usage:
    python simple_dialog.py [options]
Options:
    -h, --help      Display this help message.
Example:
    python simple_dialog.py
&quot;&quot;&quot;

def usage():
    print USAGE_TEXT
    sys.exit(-1)

def main():
    args = sys.argv[1:]
    try:
        opts, args = getopt.getopt(args, 'h', ['help'])
    except:
        usage()
    relink = 1
    for opt, val in opts:
        if opt in ('-h', '--help'):
            usage()
    if len(args) != 0:
        usage()
    test()

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
</pre>
<p>Some explanation:</p>
<ul class="simple">
<li>First, we import gtk</li>
<li>Next we define a class MessageBox that implements a message
box. Here are a few important things to know about that class:<ul>
<li>It is a subclass of gtk.Dialog.</li>
<li>It creates a label and packs it into the dialog's client area. Note
that a Dialog is a Window that contains a vbox at the top of and an
action_area at the bottom of its client area. The intension is for
us to pack miscellaneous widgets into the vbox and to put buttons
such as &quot;Ok&quot;, &quot;Cancel&quot;, etc into the action_area.</li>
<li>It creates one button for each button label passed to its
constructor. The buttons are all connected to the click method.</li>
<li>The click method saves the value of the user_data for the button
that was clicked. In our example, this value will be either &quot;Ok&quot; or
&quot;Cancel&quot;.</li>
</ul>
</li>
<li>And, we define a function (message_box) that (1) creates an instance
of the MessageBox class, (2) sets its title, (3) shows it, (4)
starts its event loop so that it can get and process events from the
user, and (5) returns the result to the caller (in this case &quot;Ok&quot; or
&quot;Cancel&quot;).</li>
<li>Our testing function (test) calls function message_box and prints
the result.</li>
<li>This looks like quite a bit of code, until you notice that the class
MessageBox and the function message_box could be put it a utility
module and reused.</li>
</ul>
</div>
<div class="section" id="a-simple-text-input-dialog-box">
<h4><a class="toc-backref" href="#id156">2.7.2.2&nbsp;&nbsp;&nbsp;A simple text input dialog box</a></h4>
<p>And, here is an example that displays an text input dialog:</p>
<pre class="literal-block">
#!/usr/bin/env python

import sys
import getopt
import gtk

class EntryDialog( gtk.Dialog):
    def __init__(self, message=&quot;&quot;, default_text='', modal=True):
        gtk.Dialog.__init__(self)
        self.connect(&quot;destroy&quot;, self.quit)
        self.connect(&quot;delete_event&quot;, self.quit)
        if modal:
            self.set_modal(True)
        box = gtk.VBox(spacing=10)
        box.set_border_width(10)
        self.vbox.pack_start(box)
        box.show()
        if message:
            label = gtk.Label(message)
            box.pack_start(label)
            label.show()
        self.entry = gtk.Entry()
        self.entry.set_text(default_text)
        box.pack_start(self.entry)
        self.entry.show()
        self.entry.grab_focus()
        button = gtk.Button(&quot;OK&quot;)
        button.connect(&quot;clicked&quot;, self.click)
        button.set_flags(gtk.CAN_DEFAULT)
        self.action_area.pack_start(button)
        button.show()
        button.grab_default()
        button = gtk.Button(&quot;Cancel&quot;)
        button.connect(&quot;clicked&quot;, self.quit)
        button.set_flags(gtk.CAN_DEFAULT)
        self.action_area.pack_start(button)
        button.show()
        self.ret = None
    def quit(self, w=None, event=None):
        self.hide()
        self.destroy()
        gtk.main_quit()
    def click(self, button):
        self.ret = self.entry.get_text()
        self.quit()

def input_box(title=&quot;Input Box&quot;, message=&quot;&quot;, default_text='',
        modal=True):
    win = EntryDialog(message, default_text, modal=modal)
    win.set_title(title)
    win.show()
    gtk.main()
    return win.ret

def test():
    result = input_box(title='Test #2',
        message='Enter a valuexxx:',
        default_text='a default value')
    if result is None:
        print 'Canceled'
    else:
        print 'result: &quot;%s&quot;' % result

USAGE_TEXT = &quot;&quot;&quot;
Usage:
    python simple_dialog.py [options]
Options:
    -h, --help      Display this help message.
Example:
    python simple_dialog.py
&quot;&quot;&quot;

def usage():
    print USAGE_TEXT
    sys.exit(-1)

def main():
    args = sys.argv[1:]
    try:
        opts, args = getopt.getopt(args, 'h', ['help'])
    except:
        usage()
    relink = 1
    for opt, val in opts:
        if opt in ('-h', '--help'):
            usage()
    if len(args) != 0:
        usage()
    test()

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
</pre>
<p>Most of the explanation for the message box example is relevant to
this example, too. Here are some differences:</p>
<ul class="simple">
<li>Our EntryDialog class constructor creates instance of gtk.Entry,
sets its default value, and packs it into the client area.</li>
<li>The constructor also automatically creates two buttons: &quot;OK&quot; and
&quot;Cancel&quot;. The &quot;OK&quot; button is connect to the click method, which
saves the value of the entry field.  The &quot;Cancel&quot; button is connect
to the quit method, which does not save the value.</li>
<li>And, if class EntryDialog and function input_box look usable and
useful, add them to your utility gui module.</li>
</ul>
</div>
<div class="section" id="a-file-selection-dialog-box">
<h4><a class="toc-backref" href="#id157">2.7.2.3&nbsp;&nbsp;&nbsp;A file selection dialog box</a></h4>
<p>This example shows a file selection dialog box:</p>
<pre class="literal-block">
#!/usr/bin/env python

import sys
import getopt
import gtk

class FileChooser(gtk.FileSelection):
    def __init__(self, modal=True, multiple=True):
        gtk.FileSelection.__init__(self)
        self.multiple = multiple
        self.connect(&quot;destroy&quot;, self.quit)
        self.connect(&quot;delete_event&quot;, self.quit)
        if modal:
            self.set_modal(True)
        self.cancel_button.connect('clicked', self.quit)
        self.ok_button.connect('clicked', self.ok_cb)
        if multiple:
            self.set_select_multiple(True)
        self.ret = None
    def quit(self, *args):
        self.hide()
        self.destroy()
        gtk.main_quit()
    def ok_cb(self, b):
        if self.multiple:
            self.ret = self.get_selections()
        else:
            self.ret = self.get_filename()
        self.quit()

def file_sel_box(title=&quot;Browse&quot;, modal=False, multiple=True):
    win = FileChooser(modal=modal, multiple=multiple)
    win.set_title(title)
    win.show()
    gtk.main()
    return win.ret

def file_open_box(modal=True):
    return file_sel_box(&quot;Open&quot;, modal=modal, multiple=True)
def file_save_box(modal=True):
    return file_sel_box(&quot;Save As&quot;, modal=modal, multiple=False)

def test():
    result = file_open_box()
    print 'open result:', result
    result = file_save_box()
    print 'save result:', result

USAGE_TEXT = &quot;&quot;&quot;
Usage:
    python simple_dialog.py [options]
Options:
    -h, --help      Display this help message.
Example:
    python simple_dialog.py
&quot;&quot;&quot;

def usage():
    print USAGE_TEXT
    sys.exit(-1)

def main():
    args = sys.argv[1:]
    try:
        opts, args = getopt.getopt(args, 'h', ['help'])
    except:
        usage()
    relink = 1
    for opt, val in opts:
        if opt in ('-h', '--help'):
            usage()
    if len(args) != 0:
        usage()
    test()

if __name__ == '__main__':
    main()
    #import pdb
    #pdb.run('main()')
</pre>
<p>A little guidance:</p>
<ul class="simple">
<li>There is a pre-defined file selection dialog. We sub-class it.</li>
<li>This example displays the file selection dialog twice: once with a
title &quot;Open&quot; and once with a title &quot;Save As&quot;.</li>
<li>Note how we can control whether the dialog allows multiple file
selections. And, if we select the multiple selection mode, then we
use get_selections instead of get_filename in order to get the
selected file names.</li>
<li>The dialog contains buttons that enable the user to (1) create a new
folder, (2) delete a file, and (3) rename a file. If you do not want
the user to perform these operations, then call
hide_fileop_buttons. This call is commented out in our sample code.</li>
</ul>
<p>Note that there are also predefined dialogs for font selection
(FontSelectionDialog) and color selection (ColorSelectionDialog)</p>
</div>
</div>
<div class="section" id="easygui">
<h3><a class="toc-backref" href="#id158">2.7.3&nbsp;&nbsp;&nbsp;EasyGUI</a></h3>
<p>If your GUI needs are minimalist (maybe a pop-up dialog or two) and
your application is imperative rather than event driven, then you
may want to consider EasyGUI. As the name suggests, it is extremely
easy to use.</p>
<p>How to know when you might be able to use EasyGUI:</p>
<ul class="simple">
<li>Your application does not need to run in a window containing menus
and a menu bar.</li>
<li>Your GUI needs amount to little more than displaying a dialog now
and then to get responses from the user.</li>
<li>You do <em>not</em> want to write an event driven application, that is,
one in which your code sits and waits for the the user to initiate
operation, for example, with menu items.</li>
</ul>
<p>EasyGUI plus documentation and examples are available at
<a class="reference external" href="http://easygui.sourceforge.net/">EasyGUI home page at SourceForge --
http://easygui.sourceforge.net/</a></p>
<p>EasyGUI provides functions for a variety of commonly needed dialog
boxes, including:</p>
<ul class="simple">
<li>A message box displays a message.</li>
<li>A yes/no message box displays &quot;Yes&quot; and &quot;No&quot; buttons.</li>
<li>A continue/cancel message box displays &quot;Continue&quot; and &quot;Cancel&quot;
buttons.</li>
<li>A choice box displays a selection list.</li>
<li>An enter box allows entry of a line of text.</li>
<li>An integer box allows entry of an interger.</li>
<li>A multiple entry box allows entry into multiple fields.</li>
<li>Code and text boxes support the display of text in monospaced or
porportional fonts.</li>
<li>File and directory boxes enable the user to select a file or a
directory.</li>
</ul>
<p>See the documentation at the EasyGUI Web site for more features.</p>
<p>For a demonstration of EasyGUI's capabilities, run the
<tt class="docutils literal">easygui.py</tt> as a Python script:</p>
<pre class="literal-block">
$ python easygui.py
</pre>
<div class="section" id="a-simple-easygui-example">
<h4><a class="toc-backref" href="#id159">2.7.3.1&nbsp;&nbsp;&nbsp;A simple EasyGUI example</a></h4>
<p>Here is a simple example that prompts the user for an entry, then
shows the response in a message box:</p>
<pre class="literal-block">
import easygui

def testeasygui():
    response = easygui.enterbox(msg='Enter your name:', title='Name Entry')
    easygui.msgbox(msg=response, title='Your Response')

testeasygui()
</pre>
</div>
<div class="section" id="an-easygui-file-open-dialog-example">
<h4><a class="toc-backref" href="#id160">2.7.3.2&nbsp;&nbsp;&nbsp;An EasyGUI file open dialog example</a></h4>
<p>This example presents a dialog to allow the user to select a file:</p>
<pre class="literal-block">
import easygui

def test():
    response = easygui.fileopenbox(msg='Select a file')
    print 'file name: %s' % response

test()
</pre>
</div>
</div>
</div>
<div class="section" id="guidance-on-packages-and-modules">
<h2><a class="toc-backref" href="#id161">2.8&nbsp;&nbsp;&nbsp;Guidance on Packages and Modules</a></h2>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id162">2.8.1&nbsp;&nbsp;&nbsp;Introduction</a></h3>
<p>Python has an excellent range of implementation organization
structures. These range from statements and control structures (at a
low level) through functions, methods, and classes (at an intermediate
level) and modules and packages at an upper level.</p>
<p>This section provides some guidance with the use of packages. In
particular:</p>
<ul class="simple">
<li>How to construct and implement them.</li>
<li>How to use them.</li>
<li>How to distribute and install them.</li>
</ul>
</div>
<div class="section" id="implementing-packages">
<h3><a class="toc-backref" href="#id163">2.8.2&nbsp;&nbsp;&nbsp;Implementing Packages</a></h3>
<p>A Python package is a collection of Python modules in a disk
directory.</p>
<p>In order to be able to import individual modules from a directory, the
directory must contain a file named __init__.py. (Note that
requirement does not apply to directories that are listed in
PYTHONPATH.) The __init__.py serves several purposes:</p>
<ul class="simple">
<li>The presence of the file __init__.py in a directory marks the
directory as a Python package, which enables importing modules from
the directory.</li>
<li>The first time an application imports any module from the
directory/package, the code in the module __init__ is evaluated.</li>
<li>If the package itself is imported (as opposed to an individual
module within the directory/package), then it is the __init__ that
is imported (and evaluated).</li>
</ul>
</div>
<div class="section" id="using-packages">
<h3><a class="toc-backref" href="#id164">2.8.3&nbsp;&nbsp;&nbsp;Using Packages</a></h3>
<p>One simple way to enable the user to import and use a package is to
instruct the use to import individual modules from the package.</p>
<p>A second, slightly more advanced way to enable the user to import the
package is to expose those features of the package in the __init__
module. Suppose that module mod1 contains functions fun1a and fun1b
and suppose that module mod2 contains functions fun2a and fun2b. Then
file <tt class="docutils literal">__init__.py</tt> might contain the following:</p>
<pre class="literal-block">
from mod1 import fun1a, fun1b
from mod2 import fun2a, fun2b
</pre>
<p>Then, if the following is evaluated in the user's code:</p>
<pre class="literal-block">
import testpackages
</pre>
<p>Then <tt class="docutils literal">testpackages</tt> will contain <tt class="docutils literal">fun1a</tt>, <tt class="docutils literal">fun1b</tt>, <tt class="docutils literal">fun2a</tt>,
and <tt class="docutils literal">fun2b</tt>.</p>
<p>For example, here is an interactive session that demostrates importing
the package:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import testpackages
&gt;&gt;&gt; print dir(testpackages)
[`__builtins__', `__doc__', `__file__', `__name__', `__path__',
`fun1a', `fun1b', `fun2a', `fun2b', `mod1', `mod2']
</pre>
</blockquote>
</div>
<div class="section" id="distributing-and-installing-packages">
<h3><a class="toc-backref" href="#id165">2.8.4&nbsp;&nbsp;&nbsp;Distributing and Installing Packages</a></h3>
<p>Distutils (Python Distribution Utilities) has special support for
distrubuting and installing packages.  Learn more here:
<a class="reference external" href="http://docs.python.org/distutils/index.html">Distributing Python Modules --
http://docs.python.org/distutils/index.html</a>.</p>
<p>As our example, imagine that we have a directory containing the
following:</p>
<pre class="literal-block">
Testpackages
Testpackages/README
Testpackages/MANIFEST.in
Testpackages/setup.py
Testpackages/testpackages/__init__.py
Testpackages/testpackages/mod1.py
Testpackages/testpackages/mod2.py
</pre>
<p>Notice the sub-directory Testpackages/testpackages containing the file
<tt class="docutils literal">__init__.py</tt>.  This is the Python package that we will install.</p>
<p>We'll describe how to configure the above files so that they can be
packaged as a single distribution file and so that the Python package
they contain can be installed as a package by Distutils.</p>
<p>The <tt class="docutils literal">MANIFEST.in</tt> file lists the files that we want included in our
distribution.  Here is the contents of our MANIFEST.in file:</p>
<pre class="literal-block">
include README MANIFEST MANIFEST.in
include setup.py
include testpackages/*.py
</pre>
<p>The <tt class="docutils literal">setup.py</tt> file describes to Distutils (1) how to package the
distribution file and (2) how to install the distribution. Here is the
contents of our sample setup.py:</p>
<pre class="literal-block">
#!/usr/bin/env python

from distutils.core import setup                    # [1]

long_description = 'Tests for installing and distributing Python packages'

setup(name = 'testpackages',                        # [2]
    version = '1.0a',
    description = 'Tests for Python packages',
    maintainer = 'Dave Kuhlman',
    maintainer_email = 'dkuhlman (at) davekuhlman (dot) org
    url = 'http://www.davekuhlman.org
    long_description = long_description,
    packages = ['testpackages']                     # [3]
    )
</pre>
<p>Explanation:</p>
<ol class="arabic simple">
<li>We import the necessary component from Distutils.</li>
<li>We describe the package and its developer/maintainer.</li>
<li>We specify the directory that is to be installed as a package. When
the user installs our distribution, this directory and all the
modules in it will be installed as a package.</li>
</ol>
<p>Now, to create a distribution file, we run the following:</p>
<pre class="literal-block">
python setup.py sdist --formats=gztar
</pre>
<p>which will create a file <tt class="docutils literal"><span class="pre">testpackages-1.0a.tar.gz</span></tt> under the
directory <tt class="docutils literal">dist</tt>.</p>
<p>Then, you can give this distribution file to a potential user, who
can install it by doing the following:</p>
<pre class="literal-block">
$ tar xvzf testpackages-1.0a.tar.gz
$ cd testpackages-1.0a
$ python setup.py build
$ python setup.py install        # as root
</pre>
</div>
</div>
<div class="section" id="end-matter">
<h2><a class="toc-backref" href="#id166">2.9&nbsp;&nbsp;&nbsp;End Matter</a></h2>
<div class="section" id="acknowledgements-and-thanks">
<h3><a class="toc-backref" href="#id167">2.9.1&nbsp;&nbsp;&nbsp;Acknowledgements and Thanks</a></h3>
<ul class="simple">
<li>Thanks to the implementors of Python for producing an exceptionally
usable and enjoyable programming language.</li>
<li>Thanks to Dave Beazley and others for <tt class="docutils literal">SWIG</tt> and <tt class="docutils literal">PLY</tt>.</li>
<li>Thanks to Greg Ewing for <tt class="docutils literal">Pyrex</tt> and <tt class="docutils literal">Plex</tt>.</li>
<li>Thanks to James Henstridge for <tt class="docutils literal">PyGTK</tt>.</li>
</ul>
</div>
<div class="section" id="see-also">
<h3><a class="toc-backref" href="#id168">2.9.2&nbsp;&nbsp;&nbsp;See Also</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://www.python.org">The main Python Web Site --
http://www.python.org</a>
for more information on Python.</li>
<li><a class="reference external" href="http://www.python.org/doc/">Python Documentation --
http://www.python.org/doc/</a>
for lots of documentation on Python</li>
<li><a class="reference external" href="http://www.davekuhlman.org/">Dave's Web Site --
http://www.davekuhlman.org/</a>
for more software and information on using Python for XML and the Web.</li>
<li><a class="reference external" href="http://www.swig.org">The SWIG home page --
http://www.swig.org</a>
for more information on SWIG (Simplified Wrapper and Interface Generator).</li>
<li><a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">The Pyrex home page --
http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/</a>
for more information on Pyrex.</li>
<li><a class="reference external" href="http://www.dabeaz.com/ply/">PLY (Python Lex-Yacc) home page --
http://www.dabeaz.com/ply/</a>
for more information on PLY.</li>
<li><a class="reference external" href="http://www.cosc.canterbury.ac.nz/greg.ewing/python/Plex/">The Plex home page --
http://www.cosc.canterbury.ac.nz/greg.ewing/python/Plex/</a>
for more information on Plex.</li>
<li><a class="reference external" href="http://docs.python.org/distutils/index.html">Distributing Python Modules --
http://docs.python.org/distutils/index.html</a>
for information on the Python Distribution Utilities (<tt class="docutils literal">Distutils</tt>).</li>
</ul>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="part-3-python-workbook">
<h1><a class="toc-backref" href="#id169">3&nbsp;&nbsp;&nbsp;Part 3 -- Python Workbook</a></h1>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id170">3.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>This document takes a workbook and exercise-with-solutions approach
to Python training.  It is hoped that those who feel a need for
less explanation and more practical exercises will find this
useful.</p>
<p>A few notes about the exercises:</p>
<ul class="simple">
<li>I've tried to include solutions for most of the exercises.
Hopefully, you will be able to copy and paste these solutions
into your text editor, then extend and experiment with them.</li>
<li>I use two interactive Python interpreters (although they are the
same Python underneath).  When you see this prompt <tt class="docutils literal">&gt;&gt;&gt;</tt>,
it's the standard Python interpreter.  And, when you see this
prompt <tt class="docutils literal">In [1]:</tt>, it's <a class="reference external" href="http://ipython.scipy.org/moin/">IPython -
http://ipython.scipy.org/moin/</a>.</li>
</ul>
<p>The latest version of this document is at my Web site (URL above).</p>
<p>If you have comments or suggestions, please send them my way.</p>
</div>
<div class="section" id="lexical-structures">
<h2><a class="toc-backref" href="#id171">3.2&nbsp;&nbsp;&nbsp;Lexical Structures</a></h2>
<div class="section" id="variables-and-names">
<h3><a class="toc-backref" href="#id172">3.2.1&nbsp;&nbsp;&nbsp;Variables and names</a></h3>
<p>A name is any combination of letters, digits, and the underscore,
but the first character must be a letter or an underscore.  Names
may be of any length.</p>
<p>Case is significant.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Which of the following are valid names?<ol class="arabic">
<li><tt class="docutils literal">total</tt></li>
<li><tt class="docutils literal">total_of_all_vegetables</tt></li>
<li><tt class="docutils literal"><span class="pre">big-title-1</span></tt></li>
<li><tt class="docutils literal">_inner_func</tt></li>
<li><tt class="docutils literal">1bigtitle</tt></li>
<li><tt class="docutils literal">bigtitle1</tt></li>
</ol>
</li>
<li>Which or the following pairs are the same name:<ol class="arabic">
<li><tt class="docutils literal">the_last_item</tt> and <tt class="docutils literal">the_last_item</tt></li>
<li><tt class="docutils literal">the_last_item</tt> and <tt class="docutils literal">The_Last_Item</tt></li>
<li><tt class="docutils literal">itemi</tt> and <tt class="docutils literal">itemj</tt></li>
<li><tt class="docutils literal">item1</tt> and <tt class="docutils literal">iteml</tt></li>
</ol>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic simple">
<li>Items 1, 2, 4, and 6 are valid.  Item 3 is not a single name, but
is three items separated by the minus operator.  Item 5 is not
valid because it begins with a digit.</li>
<li>Python names are case-sensitive, which means:<ol class="arabic">
<li><tt class="docutils literal">the_last_item</tt> and <tt class="docutils literal">the_last_item</tt> are the same.</li>
<li><tt class="docutils literal">the_last_item</tt> and <tt class="docutils literal">The_Last_Item</tt> are different -- The
second name has an upper-case characters.</li>
<li><tt class="docutils literal">itemi</tt> and <tt class="docutils literal">itemj</tt> are different.</li>
<li><tt class="docutils literal">item1</tt> and <tt class="docutils literal">iteml</tt> are different -- This one may be
difficult to see, depending on the font you are viewing.  One
name ends with the digit one; the other ends with the alpha
character &quot;el&quot;.  And this example provides a good reason to
use &quot;1&quot; and &quot;l&quot; judiciously in names.</li>
</ol>
</li>
</ol>
<p>The following are keywords in Python and should <strong>not</strong> be used as
variable names:</p>
<pre class="literal-block">
and       del       from      not       while
as        elif      global    or        with
assert    else      if        pass      yield
break     except    import    print
class     exec      in        raise
continue  finally   is        return
def       for       lambda    try
</pre>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Which of the following are valid names in Python?<ol class="arabic">
<li>_global</li>
<li>global</li>
<li>file</li>
</ol>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic simple">
<li>Do <em>not</em> use keywords for variable names:<ol class="arabic">
<li>Valid</li>
<li>Not a valid name.  &quot;global&quot; is a keyword.</li>
<li>Valid, however, &quot;file&quot; is the name of a built-in type, as
you will learn later, so you are advised not to redefine it.
Here are a few of the names of built-in types: &quot;file&quot;,
&quot;int&quot;, &quot;str&quot;, &quot;float&quot;, &quot;list&quot;, &quot;dict&quot;, etc.  See
<a class="reference external" href="http://docs.python.org/lib/types.html">Built-in Types --
http://docs.python.org/lib/types.html</a>
for more built-in types..</li>
</ol>
</li>
</ol>
<p>The following are operators in Python and will separate names:</p>
<pre class="literal-block">
+       -       *       **      /       //      %
&lt;&lt;      &gt;&gt;      &amp;       |       ^       ~
&lt;       &gt;       &lt;=      &gt;=      ==      !=      &lt;&gt;

and     or      is      not     in

Also:   ()      []      . (dot)
</pre>
<p>But, note that the Python style guide suggests that you place blanks
around binary operators.  One exception to this rule is function
arguments and parameters for functions: it is suggested that you
<em>not</em> put blanks around the equal sign (<tt class="docutils literal">=</tt>) used to specify
keyword arguments and default parameters.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Which of the following are single names and which are names
separated by operators?<ol class="arabic">
<li><tt class="docutils literal">fruit_collection</tt></li>
<li><tt class="docutils literal"><span class="pre">fruit-collection</span></tt></li>
</ol>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic simple">
<li>Do not use a dash, or other operator, in the middle of a name:<ol class="arabic">
<li><tt class="docutils literal">fruit_collection</tt> is a single name</li>
<li><tt class="docutils literal"><span class="pre">fruit-collection</span></tt> is two names separated by a dash.</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="line-structure">
<h3><a class="toc-backref" href="#id173">3.2.2&nbsp;&nbsp;&nbsp;Line structure</a></h3>
<p>In Python, normally we write one statement per line.  In fact,
Python assumes this.  Therefore:</p>
<ul class="simple">
<li>Statement separators are not normally needed.</li>
<li>But, if we want more than one statement on a line, we use a
statement separator, specifically a semi-colon.</li>
<li>And, if we want to extend a statement to a second or third line
and so on, we sometimes need to do a bit extra.</li>
</ul>
<p>Extending a Python statement to a subsequent line -- Follow these
two rules:</p>
<ol class="arabic simple">
<li>If there is an open context, nothing special need be done to
extend a statement across multiple lines.  An open context is an
open parenthesis, an open square bracket, or an open curly
bracket.</li>
<li>We can always extend a statement on a following line by placing a
back slash as the last character of the line.</li>
</ol>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Extend the following statement to a second line using
parentheses:</p>
<pre class="literal-block">
total_count = tree_count + vegetable_count + fruit_count
</pre>
</li>
<li><p class="first">Extend the following statement to a second line using
the backslash line continuation character:</p>
<pre class="literal-block">
total_count = tree_count + vegetable_count + fruit_count
</pre>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Parentheses create an open context that tells Python that a
statement extends to the next line:</p>
<pre class="literal-block">
total_count = (tree_count +
    vegetable_count + fruit_count)
</pre>
</li>
<li><p class="first">A backslash as the last character on line tells Python that the
current statement extends to the next line:</p>
<pre class="literal-block">
total_count = tree_count + \
    vegetable_count + fruit_count
</pre>
</li>
</ol>
<p>For extending a line on a subsequent line, which is better,
parentheses or a backslash?  Here is a quote:</p>
<blockquote>
<p>&quot;The preferred way of wrapping long lines is by using Python's
implied line continuation inside parentheses, brackets and braces.
If necessary, you can add an extra pair of parentheses around an
expression, but sometimes using a backslash looks better.&quot;</p>
<blockquote>
-- <a class="reference external" href="http://www.python.org/dev/peps/pep-0008/">PEP 8: Style Guide for Python Code -- http://www.python.org/dev/peps/pep-0008/</a></blockquote>
</blockquote>
</div>
<div class="section" id="indentation-and-program-structure">
<h3><a class="toc-backref" href="#id174">3.2.3&nbsp;&nbsp;&nbsp;Indentation and program structure</a></h3>
<p>Python uses indentation to indicate program structure.  That is to
say, in order to nest a block of code inside a compound statement,
you indent that nested code.  This is different from many
programming languages which use some sort of begin and end markers,
for example curly brackets.</p>
<p>The standard coding practice for Python is to use four spaces per
indentation level and to <strong>not</strong> use hard tabs.  (See the <a class="reference external" href="http://www.python.org/dev/peps/pep-0008/">Style
Guide for Python Code</a>.) Because of this, you will want to use a
text editor that you can configure so that it will use four spaces
for indentation.  See here for a list of Python-friendly text
editors: <a class="reference external" href="http://wiki.python.org/moin/PythonEditors">PythonEditors</a>.</p>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Given the following, nest the <tt class="docutils literal">print</tt> statement inside the
<tt class="docutils literal">if</tt> statement:</p>
<pre class="literal-block">
if x &gt; 0:

print x
</pre>
</li>
<li><p class="first">Nest these two lines:</p>
<pre class="literal-block">
z = x + y
print z
</pre>
<p>inside the following function definition statement:</p>
<pre class="literal-block">
def show_sum(x, y):
</pre>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Indentation indicates that one statement is nested inside another
statement:</p>
<pre class="literal-block">
if x &gt; 0:
    print x
</pre>
</li>
<li><p class="first">Indentation indicates that a block of statements is nested inside
another statement:</p>
<pre class="literal-block">
def show_sum(x, y):
    z = x + y
    print z
</pre>
</li>
</ol>
</div>
</div>
<div class="section" id="execution-model">
<h2><a class="toc-backref" href="#id175">3.3&nbsp;&nbsp;&nbsp;Execution Model</a></h2>
<p>Here are a few rules:</p>
<ol class="arabic simple">
<li>Python evaluates Python code from the top of a module down to the
bottom of a module.</li>
<li>Binding statements at top level create names (and bind values to
those names) as Python evaluates code.  Further more, a name is
not created until it is bound to a value/object.</li>
<li>A nested reference to a name (for example, inside a function
definition or in the nested block of an <tt class="docutils literal">if</tt> statement) is not
used until that nested code is evaluated.</li>
</ol>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Will the following code produce an error?</p>
<pre class="literal-block">
show_version()
def show_version():
    print 'Version 1.0a'
</pre>
</li>
<li><p class="first">Will the following code produce an error?</p>
<pre class="literal-block">
def test():
    show_version()

def show_version():
    print 'Version 1.0a'

test()
</pre>
</li>
<li><p class="first">Will the following code produce an error?  Assume that
<tt class="docutils literal">show_config</tt> is not defined:</p>
<pre class="literal-block">
x = 3
if x &gt; 5:
    show_config()
</pre>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Answer: Yes, it generates an error.  The name <tt class="docutils literal">show_version</tt>
would not be created and bound to a value until the <tt class="docutils literal">def</tt>
function definition statement binds a function object to it.
That is done after the attempt to use (call) that object.</p>
</li>
<li><p class="first">Answer: No.  The function <tt class="docutils literal">test()</tt> does call the function
<tt class="docutils literal">show_version()</tt>, but since <tt class="docutils literal">test()</tt> is not called until
after <tt class="docutils literal">show_version()</tt> is defined, that is OK.</p>
</li>
<li><p class="first">Answer: No. It's bad code, but in this case will <em>not</em> generate an
error.  Since x is less than 5, the body of the if statement is
not evaluated.</p>
<p>N.B.  This example shows why it is important during testing that
every line of code in your Python program be evaluated.  Here is
good Pythonic advice: &quot;If it's not tested, it's broken.&quot;</p>
</li>
</ol>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id176">3.4&nbsp;&nbsp;&nbsp;Built-in Data Types</a></h2>
<p>Each of the subsections in this section on built-in data types will
have a similar structure:</p>
<ol class="arabic simple">
<li>A brief description of the data type and its uses.</li>
<li>Representation and construction -- How to represent an instance
of the data type.  How to code a literal representation that
creates and defines an instance.  How to create an instance of
the built-in type.</li>
<li>Operators that are applicable to the data type.</li>
<li>Methods implemented and supported by the data type.</li>
</ol>
<div class="section" id="numbers">
<h3><a class="toc-backref" href="#id177">3.4.1&nbsp;&nbsp;&nbsp;Numbers</a></h3>
<p>The numbers you will use most commonly are likely to be integers and
floats.  Python also has long integers and complex numbers.</p>
<p>A few facts about numbers (in Python):</p>
<ul>
<li><p class="first">Python will convert to using a long integer automatically when
needed.  You do not need to worry about exceeding the size of a
(standard) integer.</p>
</li>
<li><p class="first">The size of the largest integer in your version of Python is in
<tt class="docutils literal">sys.maxint</tt>.  To learn what it is, do:</p>
<pre class="literal-block">
&gt;&gt;&gt; import sys
&gt;&gt;&gt; print sys.maxint
9223372036854775807
</pre>
<p>The above show the maximum size of an integer on a 64-bit version
of Python.</p>
</li>
<li><p class="first">You can convert from integer to float by using the <tt class="docutils literal">float</tt>
constructor.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; x = 25
&gt;&gt;&gt; y = float(x)
&gt;&gt;&gt; print y
25.0
</pre>
</li>
<li><p class="first">Python does &quot;mixed arithmetic&quot;.  You can add, multiply, and
divide integers and floats.  When you do, Python &quot;promotes&quot; the
result to a float.</p>
</li>
</ul>
<div class="section" id="literal-representations-of-numbers">
<h4><a class="toc-backref" href="#id178">3.4.1.1&nbsp;&nbsp;&nbsp;Literal representations of numbers</a></h4>
<p>An integer is constructed with a series of digits or the integer
constructor (<tt class="docutils literal">int(x)</tt>).  Be aware
that a sequence of digits beginning with zero represents an octal value.
Examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; x1 = 1234
&gt;&gt;&gt; x2 = int('1234')
&gt;&gt;&gt; x3 = -25
&gt;&gt;&gt; x1
1234
&gt;&gt;&gt; x2
1234
&gt;&gt;&gt; x3
-25
</pre>
<p>A float is constructed either with digits and a dot (example,
12.345) or with engineering/scientific notation or with the float
constructor (<tt class="docutils literal">float(x)</tt>).  Examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; x1 = 2.0e3
&gt;&gt;&gt; x1 = 1.234
&gt;&gt;&gt; x2 = -1.234
&gt;&gt;&gt; x3 = float('1.234')
&gt;&gt;&gt; x4 = 2.0e3
&gt;&gt;&gt; x5 = 2.0e-3
&gt;&gt;&gt; print x1, x2, x3, x4, x5
1.234 -1.234 1.234 2000.0 0.002
</pre>
<p>Exercises:</p>
<p>Construct these numeric values:</p>
<ol class="arabic simple">
<li>Integer zero</li>
<li>Floating point zero</li>
<li>Integer one hundred and one</li>
<li>Floating point one thousand</li>
<li>Floating point one thousand using scientific notation</li>
<li>Create a positive integer, a negative integer, and zero.  Assign
them to variables</li>
<li>Write several arithmetic expressions.  Bind the values to
variables.  Use a variety of operators, e.g. <tt class="docutils literal">+</tt>, <tt class="docutils literal">-</tt>, <tt class="docutils literal">/</tt>,
<tt class="docutils literal">*</tt>, etc.  Use parentheses to control operator scope.</li>
<li>Create several floats and assign them to variables.</li>
<li>Write several arithmetic expressions containing your float
variables.</li>
<li>Write several expressions using mixed arithmetic (integers and
floats).  Obtain a float as a result of division of one integer by
another; do so by explicitly converting one integer to a float.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal">0</tt></p>
</li>
<li><p class="first"><tt class="docutils literal">0.0</tt>, <tt class="docutils literal">0.</tt>, or <tt class="docutils literal">.0</tt></p>
</li>
<li><p class="first"><tt class="docutils literal">101</tt></p>
</li>
<li><p class="first"><tt class="docutils literal">1000.0</tt></p>
</li>
<li><p class="first"><tt class="docutils literal">1e3</tt> or <tt class="docutils literal">1.0e3</tt></p>
</li>
<li><p class="first">Asigning integer values to variables:</p>
<pre class="literal-block">
In [7]: value1 = 23
In [8]: value2 = -14
In [9]: value3 = 0
In [10]: value1
Out[10]: 23
In [11]: value2
Out[11]: -14
In [12]: value3
Out[12]: 0
</pre>
</li>
<li><p class="first">Assigning expression values to variables:</p>
<pre class="literal-block">
value1 = 4 * (3 + 5)
value2 = (value1 / 3.0) - 2
</pre>
</li>
<li><p class="first">Assigning floats to variables:</p>
<pre class="literal-block">
value1 = 0.01
value2 = -3.0
value3 = 3e-4
</pre>
</li>
<li><p class="first">Assigning expressions containing varialbes:</p>
<pre class="literal-block">
value4 = value1 * (value2 - value3)
value4 = value1 + value2 + value3 - value4
</pre>
</li>
<li><p class="first">Mixed arithmetic:</p>
<pre class="literal-block">
x = 5
y = 8
z = float(x) / y
</pre>
</li>
</ol>
<p>You can also construct integers and floats using the class.
Calling a class (using parentheses after a class name, for example)
produces an instance of the class.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Construct an integer from the string &quot;123&quot;.</li>
<li>Construct a float from the integer 123.</li>
<li>Construct an integer from the float 12.345.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Use the <tt class="docutils literal">int</tt> data type to construct an integer instance from a
string:</p>
<pre class="literal-block">
int(&quot;123&quot;)
</pre>
</li>
<li><p class="first">Use the <tt class="docutils literal">float</tt> data type to construct a float instance from an
integer:</p>
<pre class="literal-block">
float(123)
</pre>
</li>
<li><p class="first">Use the <tt class="docutils literal">int</tt> data type to construct an integer instance from a
float:</p>
<pre class="literal-block">
int(12.345)    # --&gt; 12
</pre>
<p>Notice that the result is truncated to the integer part.</p>
</li>
</ol>
</div>
<div class="section" id="operators-for-numbers">
<h4><a class="toc-backref" href="#id179">3.4.1.2&nbsp;&nbsp;&nbsp;Operators for numbers</a></h4>
<p>You can use most of the familiar operators with numbers, for
example:</p>
<pre class="literal-block">
+       -       *       **      /       //      %
&lt;&lt;      &gt;&gt;      &amp;       |       ^       ~
&lt;       &gt;       &lt;=      &gt;=      ==      !=      &lt;&gt;
</pre>
<p>Look here for an explanation of these operators when applied to
numbers:
<a class="reference external" href="http://docs.python.org/lib/typesnumeric.html">Numeric Types -- int, float, long, complex --
http://docs.python.org/lib/typesnumeric.html</a>.</p>
<p>Some operators take precedence over others.  The table in the Web
page just referenced above also shows that order of priority.</p>
<p>Here is a bit of that table:</p>
<pre class="literal-block">
All numeric types (except complex) support the following operations,
sorted by ascending priority (operations in the same box have the same
priority; all numeric operations have a higher priority than comparison
operations):

Operation      Result
---------      ------
x + y          sum of x and y
x - y          difference of x and y
x * y          product of x and y
x / y          quotient of x and y
x // y         (floored) quotient of x and y
x % y          remainder of x / y
-x             x negated
+x             x unchanged
abs(x)         absolute value or magnitude of x
int(x)         x converted to integer
long(x)        x converted to long integer
float(x)       x converted to floating point
complex(re,im) a complex number with real part re, imaginary part
               im. im defaults to zero.
c.conjugate()  conjugate of the complex number c
divmod(x, y)   the pair (x // y, x % y)
pow(x, y)      x to the power y
x ** y         x to the power y
</pre>
<p>Notice also that the same operator may perform a different function
depending on the data type of the value to which it is applied.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Add the numbers 3, 4, and 5.</li>
<li>Add 2 to the result of multiplying 3 by 4.</li>
<li>Add 2 plus 3 and multiply the result by 4.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Arithmetic expressions are follow standard infix algebraic
syntax:</p>
<pre class="literal-block">
3 + 4 + 5
</pre>
</li>
<li><p class="first">Use another infix expression:</p>
<pre class="literal-block">
2 + 3 * 4
</pre>
<p>Or:</p>
<pre class="literal-block">
2 + (3 * 4)
</pre>
<p>But, in this case the parentheses are not necessary because the
<tt class="docutils literal">*</tt> operator binds more tightly than the <tt class="docutils literal">+</tt> operator.</p>
</li>
<li><p class="first">Use parentheses to control order of evaluation:</p>
<pre class="literal-block">
(2 + 3) * 4
</pre>
<p>Note that the <tt class="docutils literal">*</tt> operator has precedence over (binds tighter
than) the <tt class="docutils literal">+</tt> operator, so the parentheses are needed.</p>
</li>
</ol>
<p>Python does mixed arithemetic.  When you apply an operation to an
integer and a float, it promotes the result to the &quot;higher&quot; data
type, a float.</p>
<p>If you need to perform an operation on several integers, but want
use a floating point operation, first convert one of the integers
to a float using <tt class="docutils literal">float(x)</tt>, which effectively creates an instance
of class <tt class="docutils literal">float</tt>.</p>
<p>Try the following at your Python interactive prompt:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">1.0 + 2</tt></li>
<li><tt class="docutils literal">2 / 3</tt> -- Notice that the result is truncated.</li>
<li><tt class="docutils literal">float(2) / 3</tt> -- Notice that the result is <em>not</em> truncated.</li>
</ol>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Given the following assignments:</p>
<pre class="literal-block">
x = 20
y = 50
</pre>
<p>Divide <tt class="docutils literal">x</tt> by <tt class="docutils literal">y</tt> giving a float result.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Promote one of the integers to float <em>before</em> performing the
division:</p>
<pre class="literal-block">
z = float(x) / y
</pre>
</li>
</ol>
</div>
<div class="section" id="methods-on-numbers">
<h4><a class="toc-backref" href="#id180">3.4.1.3&nbsp;&nbsp;&nbsp;Methods on numbers</a></h4>
<p>Most of the methods implemented by the data types (classes) <tt class="docutils literal">int</tt>
and <tt class="docutils literal">float</tt> are special methods that are called through the use of
operators.  Special methods often have names that begin and end with
a double underscore.  To see a list of the special names and a bit
of an indication of when each is called, do any of the following at
the Python interactive prompt:</p>
<pre class="literal-block">
&gt;&gt;&gt; help(int)
&gt;&gt;&gt; help(32)
&gt;&gt;&gt; help(float)
&gt;&gt;&gt; help(1.23)
&gt;&gt;&gt; dir(1)
&gt;&gt;&gt; dir(1.2)
</pre>
</div>
</div>
<div class="section" id="lists">
<h3><a class="toc-backref" href="#id181">3.4.2&nbsp;&nbsp;&nbsp;Lists</a></h3>
<p>Lists are a container data type that acts as a dynamic array.  That
is to say, a list is a sequence that can be indexed into and that
can grow and shrink.</p>
<p>A tuple is an index-able container, like a
list, except that a tuple is immutable.</p>
<p>A few characteristics of lists and tuples:</p>
<ul class="simple">
<li>A list has a (current) length -- Get the length of a list with
<tt class="docutils literal">len(mylist)</tt>.</li>
<li>A list has an order -- The items in a list are ordered, and you
can think of that order as going from left to right.</li>
<li>A list is heterogeneous -- You can insert different <em>types</em> of
objects into the same list.</li>
<li>Lists are mutable, but tuples are <em>not</em>.  Thus, the following are
true of lists, but <em>not</em> of tuples:<ul>
<li>You can extended or add to a list.</li>
<li>You can shrink a list by deleting items from it.</li>
<li>You can insert items into the middle of a list or at the
beginning of a list.  You can add items to the end of a list.</li>
<li>You can change which item is at a given position in a list.</li>
</ul>
</li>
</ul>
<div class="section" id="literal-representation-of-lists">
<h4><a class="toc-backref" href="#id182">3.4.2.1&nbsp;&nbsp;&nbsp;Literal representation of lists</a></h4>
<p>The literal representation of a list is square brackets containing zero
or more items separated by commas.</p>
<p>Examples:</p>
<ol class="arabic">
<li><p class="first">Try these at the Python interactive prompt:</p>
<pre class="literal-block">
&gt;&gt;&gt; [11, 22, 33]
&gt;&gt;&gt; ['aa', 'bb', 'cc', ]
&gt;&gt;&gt; [100, 'apple', 200, 'banana', ]    # The last comma is
&gt;&gt;&gt; optional.
</pre>
</li>
<li><p class="first">A list can contain lists.  In fact a list can contain any kind of
object:</p>
<pre class="literal-block">
&gt;&gt;&gt; [1, [2, 3], 4, [5, 6, 7, ], 8]
</pre>
</li>
<li><p class="first">Lists are heterogenous, that is, different kinds of objects can
be in the same list.  Here is a list that contains a number, a
string, and another list:</p>
<pre class="literal-block">
&gt;&gt;&gt; [123, 'abc', [456, 789]]
</pre>
</li>
</ol>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Create (define) the following tuples and lists using a literal:<ol class="arabic">
<li>A tuple of integers</li>
<li>A tuple of strings</li>
<li>A list of integers</li>
<li>A list of strings</li>
<li>A list of tuples or tuple of lists</li>
<li>A list of integers and strings and tuples</li>
<li>A tuple containing exactly one item</li>
<li>An empty tuple</li>
</ol>
</li>
<li>Do each of the following:<ol class="arabic">
<li>Print the length of a list.</li>
<li>Print each item in the list -- Iterate over the items in one of
your lists.  Print each item.</li>
<li>Append an item to a list.</li>
<li>Insert an item at the beginning of a list.  Insert an item in
the middle of a list.</li>
<li>Add two lists together.  Do so by using both the extend
method and the plus (+) operator.  What is the difference
between extending a list and adding two lists?</li>
<li>Retrieve the 2nd item from one of your tuples or lists.</li>
<li>Retrieve the 2nd, 3rd, and 4th items (a slice) from one of your
tuples or lists.</li>
<li>Retrieve the last (right-most) item in one of your lists.</li>
<li>Replace an item in a list with a new item.</li>
<li>Pop one item off the end of your list.</li>
<li>Delete an item from a list.</li>
<li>Do the following list manipulations:<ol class="arabic">
<li>Write a function that takes two arguments, a list and an
item, and that appends the item to the list.</li>
<li>Create an empty list,</li>
<li>Call your function several times to append items to the list.</li>
<li>Then, print out each item in the list.</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can define list literals at the Python or IPython interactive
prompt:</p>
<ol class="arabic">
<li><p class="first">Create a tuple using commas, optionally with parentheses:</p>
<pre class="literal-block">
In [1]: a1 = (11, 22, 33, )
In [2]: a1
Out[2]: (11, 22, 33)
</pre>
</li>
<li><p class="first">Quoted characters separated by commas create a tuple of
strings:</p>
<pre class="literal-block">
In [3]: a2 = ('aaa', 'bbb', 'ccc')
In [4]: a2
Out[4]: ('aaa', 'bbb', 'ccc')
</pre>
</li>
<li><p class="first">Items separated by commas inside square brackets create a
list:</p>
<pre class="literal-block">
In [26]: a3 = [100, 200, 300, ]
In [27]: a3
Out[27]: [100, 200, 300]
</pre>
</li>
<li><p class="first">Strings separated by commas inside square brackets create a
list of strings:</p>
<pre class="literal-block">
In [5]: a3 = ['basil', 'parsley', 'coriander']
In [6]: a3
Out[6]: ['basil', 'parsley', 'coriander']
In [7]:
</pre>
</li>
<li><p class="first">A tuple or a list can contain tuples and lists:</p>
<pre class="literal-block">
In [8]: a5 = [(11, 22), (33, 44), (55,)]
In [9]: a5
Out[9]: [(11, 22), (33, 44), (55,)]
</pre>
</li>
<li><p class="first">A list or tuple can contain items of different types:</p>
<pre class="literal-block">
In [10]: a6 = [101, 102, 'abc', &quot;def&quot;, (201, 202), ('ghi', 'jkl')]
In [11]: a6
Out[11]: [101, 102, 'abc', 'def', (201, 202), ('ghi', 'jkl')]
</pre>
</li>
<li><p class="first">In order to create a tuple containing exactly one item, we
must use a comma:</p>
<pre class="literal-block">
In [13]: a7 = (6,)
In [14]: a7
Out[14]: (6,)
</pre>
</li>
<li><p class="first">In order to create an empty tuple, use the tuple class/type
to create an instance of a empty tuple:</p>
<pre class="literal-block">
In [21]: a = tuple()
In [22]: a
Out[22]: ()
In [23]: type(a)
Out[23]: &lt;type 'tuple'&gt;
</pre>
</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="operators-on-lists">
<h4><a class="toc-backref" href="#id183">3.4.2.2&nbsp;&nbsp;&nbsp;Operators on lists</a></h4>
<p>There are several operators that are applicable to lists.  Here is
how to find out about them:</p>
<ul class="simple">
<li>Do <tt class="docutils literal"><span class="pre">dir([])</span></tt> or <tt class="docutils literal">dir(any_list_instance)</tt>.  Some of the items
with special names (leading and training double underscores) will
give you clues about operators implemented by the list type.</li>
<li>Do <tt class="docutils literal"><span class="pre">help([])</span></tt> or <tt class="docutils literal">help(list)</tt> at the Python interactive
prompt.</li>
<li>Do <tt class="docutils literal">help(any_list_instance.some_method)</tt>, where <tt class="docutils literal">some_method</tt>
is one of the items listed using <tt class="docutils literal">dir(any_list_instance)</tt>.</li>
<li>See <a class="reference external" href="http://docs.python.org/lib/typesseq.html">Sequence Types -- str, unicode, list, tuple, buffer, xrange --
http://docs.python.org/lib/typesseq.html</a></li>
</ul>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Concatenate (add) two lists together.</li>
<li>Create a single list that contains the items in an initial list
repeated 3 times.</li>
<li>Compare two lists.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The plus operator, applied to two lists produces a new list that
is a concatenation of two lists:</p>
<pre class="literal-block">
&gt;&gt;&gt; [11, 22] + ['aa', 'bb']
</pre>
</li>
<li><p class="first">Multiplying a list by an integer <tt class="docutils literal">n</tt> creates a new list that repeats
the original list <tt class="docutils literal">n</tt> times:</p>
<pre class="literal-block">
&gt;&gt;&gt; [11, 'abc', 4.5] * 3
</pre>
</li>
<li><p class="first">The comparison operators can be used to compare lists:</p>
<pre class="literal-block">
&gt;&gt;&gt; [11, 22] == [11, 22]
&gt;&gt;&gt; [11, 22] &lt; [11, 33]
</pre>
</li>
</ol>
</div>
<div class="section" id="methods-on-lists">
<h4><a class="toc-backref" href="#id184">3.4.2.3&nbsp;&nbsp;&nbsp;Methods on lists</a></h4>
<p>Again, use <tt class="docutils literal">dir()</tt> and <tt class="docutils literal">help()</tt> to learn about the methods
supported by lists.</p>
<p>Examples:</p>
<ol class="arabic simple">
<li>Create two (small) lists.  Extend the first list with the items in the
second.</li>
<li>Append several individual items to the end of a list.</li>
<li>(a) Insert a item at the beginning of a list.  (b) Insert an item
somewhere in the middle of a list.</li>
<li>Pop an item off the end of a list.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">extend</tt> method adds elements from another list, or other
iterable:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = [11, 22, 33, 44, ]
&gt;&gt;&gt; b = [55, 66]
&gt;&gt;&gt; a.extend(b)
&gt;&gt;&gt; a
[11, 22, 33, 44, 55, 66]
</pre>
</li>
<li><p class="first">Use the <tt class="docutils literal">append</tt> method on a list to add/append an item to the
end of a list:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = ['aa', 11]
&gt;&gt;&gt; a.append('bb')
&gt;&gt;&gt; a.append(22)
&gt;&gt;&gt; a
['aa', 11, 'bb', 22]
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">insert</tt> method on a list enables us to insert items at a
given position in a list:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = [11, 22, 33, 44, ]
&gt;&gt;&gt; a.insert(0, 'aa')
&gt;&gt;&gt; a
['aa', 11, 22, 33, 44]
&gt;&gt;&gt; a.insert(2, 'bb')
&gt;&gt;&gt; a
['aa', 11, 'bb', 22, 33, 44]
</pre>
<p>But, note that we use <tt class="docutils literal">append</tt> to add items at the end of a
list.</p>
</li>
<li><p class="first">The <tt class="docutils literal">pop</tt> method on a list returns the &quot;right-most&quot; item from
a list and removes that item from the list:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = [11, 22, 33, 44, ]
&gt;&gt;&gt;
&gt;&gt;&gt; b = a.pop()
&gt;&gt;&gt; a
[11, 22, 33]
&gt;&gt;&gt; b
44
&gt;&gt;&gt; b = a.pop()
&gt;&gt;&gt; a
[11, 22]
&gt;&gt;&gt; b
33
</pre>
<p>Note that the <tt class="docutils literal">append</tt> and <tt class="docutils literal">pop</tt> methods taken together can
be used to implement a stack, that is a LIFO (last in first out)
data structure.</p>
</li>
</ol>
</div>
<div class="section" id="list-comprehensions">
<h4><a class="toc-backref" href="#id185">3.4.2.4&nbsp;&nbsp;&nbsp;List comprehensions</a></h4>
<p>A list comprehension is a convenient way to produce a list from an
iterable (a sequence or other object that can be iterated over).</p>
<p>In its simplest form, a list comprehension resembles the header
line of a <tt class="docutils literal">for</tt> statement inside square brackets.  However, in a
list comprehension, the <tt class="docutils literal">for</tt> statement header is prefixed with
an expression and surrounded by square brackets.  Here is a
template:</p>
<pre class="literal-block">
[expr(x) for x in iterable]
</pre>
<p>where:</p>
<ul class="simple">
<li><tt class="docutils literal">expr(x)</tt> is an expression, usually, but not always, containing <tt class="docutils literal">x</tt>.</li>
<li><tt class="docutils literal">iterable</tt> is some iterable.  An iterable may be a sequence (for
example, a list, a string, a tuple) or an unordered collection or
an iterator (something over which we can iterate or apply a
<tt class="docutils literal">for</tt> statement to).</li>
</ul>
<p>Here is an example:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = [11, 22, 33, 44]
&gt;&gt;&gt; b = [x * 2 for x in a]
&gt;&gt;&gt; b
[22, 44, 66, 88]
</pre>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Given the following list of strings:</p>
<pre class="literal-block">
names = ['alice', 'bertrand', 'charlene']
</pre>
<p>produce the following lists: (1) a list of all upper case names;
(2) a list of capitalized (first letter upper case);</p>
</li>
<li><p class="first">Given the following function which calculates the factorial of a
number:</p>
<pre class="literal-block">
def t(n):
    if n &lt;= 1:
        return n
    else:
        return n * t(n - 1)
</pre>
<p>and the following list of numbers:</p>
<pre class="literal-block">
numbers = [2, 3, 4, 5]
</pre>
<p>create a list of the factorials of each of the numbers in the
list.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">For our expression in a list comprehension, use the <tt class="docutils literal">upper</tt>
and <tt class="docutils literal">capitalize</tt> methods:</p>
<pre class="literal-block">
&gt;&gt;&gt; names = ['alice', 'bertrand', 'charlene']
&gt;&gt;&gt; [name.upper() for name in names]
['ALICE', 'BERTRAND', 'CHARLENE']
&gt;&gt;&gt; [name.capitalize() for name in names]
['Alice', 'Bertrand', 'Charlene']
</pre>
</li>
<li><p class="first">The expression in our list comprehension calls the factorial
function:</p>
<pre class="literal-block">
def t(n):
    if n &lt;= 1:
        return n
    else:
        return n * t(n - 1)

def test():
    numbers = [2, 3, 4, 5]
    factorials = [t(n) for n in numbers]
    print 'factorials:', factorials

if __name__ == '__main__':
    test()
</pre>
</li>
</ol>
<p>A list comprehension can also contain an <tt class="docutils literal">if</tt> clause.  Here is a
template:</p>
<pre class="literal-block">
[expr(x) for x in iterable if pred(x)]
</pre>
<p>where:</p>
<ul class="simple">
<li><tt class="docutils literal">pred(x)</tt> is an expression that evaluates to a true/false value.
Values that count as false are numeric zero, <tt class="docutils literal">False</tt>, <tt class="docutils literal">None</tt>,
and any empty collection.  All other values count as true.</li>
</ul>
<p>Only values for which the if clause evaluates to true are included
in creating the resulting list.</p>
<p>Examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = [11, 22, 33, 44]
&gt;&gt;&gt; b = [x * 3 for x in a if x % 2 == 0]
&gt;&gt;&gt; b
[66, 132]
</pre>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Given two lists, generate a list of all the strings in the first
list that are not in the second list.  Here are two sample lists:</p>
<pre class="literal-block">
names1 = ['alice', 'bertrand', 'charlene', 'daniel']
names2 = ['bertrand', 'charlene']
</pre>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The if clause of our list comprehension checks for containment
in the list names2:</p>
<pre class="literal-block">
def test():
    names1 = ['alice', 'bertrand', 'charlene', 'daniel']
    names2 = ['bertrand', 'charlene']
    names3 = [name for name in names1 if name not in names2]
    print 'names3:', names3

if __name__ == '__main__':
    test()
</pre>
<p>When run, this script prints out the following:</p>
<pre class="literal-block">
names3: ['alice', 'daniel']
</pre>
</li>
</ol>
</div>
</div>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id186">3.4.3&nbsp;&nbsp;&nbsp;Strings</a></h3>
<p>A string is an ordered sequence of characters.  Here are a few
characteristics of strings:</p>
<ul class="simple">
<li>A string has a length.  Get the length with the <tt class="docutils literal">len()</tt> built-in
function.</li>
<li>A string is indexable.  Get a single character at a position in a
string with the square bracket operator, for example
<tt class="docutils literal">mystring[5]</tt>.</li>
<li>You can retrieve a slice (sub-string) of a string with a slice
operation, for example <tt class="docutils literal">mystring[5:8]</tt>.</li>
</ul>
<p>Create strings with single quotes or double quotes.  You can put
single quotes inside double quotes and you can put double quotes
inside single quotes.  You can also escape characters with a
backslash.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Create a string containing a single quote.</li>
<li>Create a string containing a double quote.</li>
<li>Create a string containing both a single quote a double quote.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Create a string with double quotes to include single quotes
inside the string:</p>
<pre class="literal-block">
&gt;&gt;&gt; str1 = &quot;that is jerry's ball&quot;
</pre>
</li>
<li><p class="first">Create a string enclosed with single quotes in order to include
double quotes inside the string:</p>
<pre class="literal-block">
&gt;&gt;&gt; str1 = 'say &quot;goodbye&quot;, bullwinkle'
</pre>
</li>
<li><p class="first">Take your choice.  Escape either the single quotes or the double
quotes with a backslash:</p>
<pre class="literal-block">
&gt;&gt;&gt; str1 = 'say &quot;hello&quot; to jerry\'s mom'
&gt;&gt;&gt; str2 = &quot;say \&quot;hello\&quot; to jerry's mom&quot;
&gt;&gt;&gt; str1
'say &quot;hello&quot; to jerry\'s mom'
&gt;&gt;&gt; str2
'say &quot;hello&quot; to jerry\'s mom'
</pre>
</li>
</ol>
<p>Triple quotes enable you to create a string that spans multiple
lines.  Use three single quotes or three double quotes to create a
single quoted string.</p>
<p>Examples:</p>
<ol class="arabic simple">
<li>Create a triple quoted string that contains single and double
quotes.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Use triple single quotes or triple double quotes to create
multi-line strings:</p>
<pre class="literal-block">
String1 = '''This string extends
across several lines.  And, so it has
end-of-line characters in it.
'''

String2 = &quot;&quot;&quot;
This string begins and ends with an end-of-line
character.  It can have both 'single'
quotes and &quot;double&quot; quotes in it.
&quot;&quot;&quot;

def test():
    print String1
    print String2

if __name__ == '__main__':
    test()
</pre>
</li>
</ol>
<div class="section" id="characters">
<h4><a class="toc-backref" href="#id187">3.4.3.1&nbsp;&nbsp;&nbsp;Characters</a></h4>
<p>Python does not have a distinct character type.  In Python, a
character is a string of length 1.   You can use the <tt class="docutils literal">ord()</tt> and
<tt class="docutils literal">chr()</tt> built-in functions to convert from character to integer and
back.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Create a character &quot;a&quot;.</li>
<li>Create a character, then obtain its integer representation.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The character &quot;a&quot; is a plain string of length 1:</p>
<pre class="literal-block">
&gt;&gt;&gt; x = 'a'
</pre>
</li>
<li><p class="first">The integer equivalent of the letter &quot;A&quot;:</p>
<pre class="literal-block">
&gt;&gt;&gt; x = &quot;A&quot;
&gt;&gt;&gt; ord(x)
65
</pre>
</li>
</ol>
</div>
<div class="section" id="operators-on-strings">
<h4><a class="toc-backref" href="#id188">3.4.3.2&nbsp;&nbsp;&nbsp;Operators on strings</a></h4>
<p>You can concatenate strings with the &quot;+&quot; operator.</p>
<p>You can create multiple concatenated copies of a string with the &quot;*&quot;
operator.</p>
<p>And, augmented assignment (<tt class="docutils literal">+=</tt> and <tt class="docutils literal">*=</tt>) also work.</p>
<p>Examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; 'cat' + ' and ' + 'dog'
'cat and dog'
&gt;&gt;&gt; '#' * 40
'########################################'
&gt;&gt;&gt;
&gt;&gt;&gt; s1 = 'flower'
&gt;&gt;&gt; s1 += 's'
&gt;&gt;&gt; s1
'flowers'
</pre>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Given these strings:</p>
<pre class="literal-block">
&gt;&gt;&gt; s1 = 'abcd'
&gt;&gt;&gt; s2 = 'efgh'
</pre>
<p>create a new string composed of the first string followed by
(concatenated with) the
second.</p>
</li>
<li><p class="first">Create a single string containing 5 copies of the string 'abc'.</p>
</li>
<li><p class="first">Use the multiplication operator to create a &quot;line&quot; of 50 dashes.</p>
</li>
<li><p class="first">Here are the components of a path to a file on the file system:
&quot;home&quot;, &quot;myusername&quot;, &quot;Workdir&quot;, &quot;notes.txt&quot;.  Concatenate these
together separating them with the path separator to form a
complete path to that file.  (Note that if you use the backslash
to separate components of the path, you will need to use a double
backslash, because the backslash is the escape character in
strings.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The plus (<tt class="docutils literal">+</tt>) operator applied to a string can be used to
concatenate strings:</p>
<pre class="literal-block">
&gt;&gt;&gt; s3 = s1 + s2
&gt;&gt;&gt; s3
'abcdefgh'
</pre>
</li>
<li><p class="first">The multiplication operator (<tt class="docutils literal">*</tt>) applied to a string creates
a new string that concatenates a string with itself some number
of times:</p>
<pre class="literal-block">
&gt;&gt;&gt; s1 = 'abc' * 5
&gt;&gt;&gt; s1
'abcabcabcabcabc'
</pre>
</li>
<li><p class="first">The multiplication operator (<tt class="docutils literal">*</tt>) applied to a string can be
used to create a &quot;horizontal divider line&quot;:</p>
<pre class="literal-block">
&gt;&gt;&gt; s1 = '-' * 50
&gt;&gt;&gt; print s1
--------------------------------------------------
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">sep</tt> member of the <tt class="docutils literal">os</tt> module gives us a platform
independent way to construct paths:</p>
<pre class="literal-block">
&gt;&gt;&gt; import os
&gt;&gt;&gt;
&gt;&gt;&gt; a = [&quot;home&quot;, &quot;myusername&quot;, &quot;Workdir&quot;, &quot;notes.txt&quot;]
&gt;&gt;&gt; path = a[0] + os.sep + a[1] + os.sep + a[2] + os.sep + a[3]
&gt;&gt;&gt; path
'home/myusername/Workdir/notes.txt'
</pre>
<p>And, a more concise solution:</p>
<pre class="literal-block">
&gt;&gt;&gt; import os
&gt;&gt;&gt; a = [&quot;home&quot;, &quot;myusername&quot;, &quot;Workdir&quot;, &quot;notes.txt&quot;]
&gt;&gt;&gt; os.sep.join(a)
'home/myusername/Workdir/notes.txt'
</pre>
<p>Notes:</p>
<ul class="simple">
<li>Note that importing the <tt class="docutils literal">os</tt> module and then using <tt class="docutils literal">os.sep</tt>
from that module gives us a platform independent solution.</li>
<li>If you do decide to code the path separator character
explicitly and if you are on MS Windows where the path
separator is the backslash, then you will need to use a double
backslash, because that character is the escape character.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="methods-on-strings">
<h4><a class="toc-backref" href="#id189">3.4.3.3&nbsp;&nbsp;&nbsp;Methods on strings</a></h4>
<p>String support a variety of operations.  You can obtain a list of
these methods by using the <tt class="docutils literal">dir()</tt> built-in function on any
string:</p>
<pre class="literal-block">
&gt;&gt;&gt; dir(&quot;&quot;)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__',
'__eq__', '__ge__', '__getattribute__', '__getitem__',
'__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__',
'__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__',
'__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__',
'__rmul__', '__setattr__', '__str__', 'capitalize', 'center',
'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find',
'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace',
'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip',
'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition',
'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',
'swapcase', 'title', 'translate', 'upper', 'zfill']
</pre>
<p>And, you can get help on any specific method by using the <tt class="docutils literal">help()</tt>
built-in function.  Here is an example:</p>
<pre class="literal-block">
&gt;&gt;&gt; help(&quot;&quot;.strip)
Help on built-in function strip:

strip(...)
    S.strip([chars]) -&gt; string or unicode

    Return a copy of the string S with leading and trailing
    whitespace removed.
    If chars is given and not None, remove characters in chars instead.
    If chars is unicode, S will be converted to unicode before stripping
</pre>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Strip all the whitespace characters off the right end of a
string.</li>
<li>Center a short string within a longer string, that is, pad a
short string with blank characters on both right and left to center
it.</li>
<li>Convert a string to all upper case.</li>
<li>Split a string into a list of &quot;words&quot;.</li>
<li>(a) Join the strings in a list of strings to form a single
string.  (b) Ditto, but put a newline character between each
original string.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">rstrip()</tt> method strips whitespace off the right side of a
string:</p>
<pre class="literal-block">
&gt;&gt;&gt; s1 = 'some text   \n'
&gt;&gt;&gt; s1
'some text   \n'
&gt;&gt;&gt; s2 = s1.rstrip()
&gt;&gt;&gt; s2
'some text'
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">center(n)</tt> method centers a string within a padded string
of width n:</p>
<pre class="literal-block">
&gt;&gt;&gt; s1 = 'Dave'
&gt;&gt;&gt; s2 = s1.center(20)
&gt;&gt;&gt; s2
'        Dave        '
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">upper()</tt> method produces a new string that converts all
alpha characters in the original to upper case:</p>
<pre class="literal-block">
&gt;&gt;&gt; s1 = 'Banana'
&gt;&gt;&gt; s1
'Banana'
&gt;&gt;&gt; s2 = s1.upper()
&gt;&gt;&gt; s2
'BANANA'
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">split(sep)</tt> method produces a list of strings that are
separated by <tt class="docutils literal">sep</tt> in the original string.  If <tt class="docutils literal">sep</tt> is
omitted, whitespace is treated as the separator:</p>
<pre class="literal-block">
&gt;&gt;&gt; s1 = &quot;&quot;&quot;how does it feel
... to be on your own
... no directions known
... like a rolling stone
... &quot;&quot;&quot;
&gt;&gt;&gt; words = s1.split()
&gt;&gt;&gt; words
['how', 'does', 'it', 'feel', 'to', 'be', 'on', 'your', 'own', 'no',
'directions', 'known', 'like', 'a', 'rolling', 'stone']
</pre>
<p>Note that the <tt class="docutils literal">split()</tt> function in the <tt class="docutils literal">re</tt> (regular
expression) module is useful when the separator is more complex
than whitespace or a single character.</p>
</li>
<li><p class="first">The <tt class="docutils literal">join()</tt> method concatenates strings from a list of strings
to form a single string:</p>
<pre class="literal-block">
&gt;&gt;&gt; lines = []
&gt;&gt;&gt; lines.append('how does it feel')
&gt;&gt;&gt; lines.append('to be on your own')
&gt;&gt;&gt; lines.append('no directions known')
&gt;&gt;&gt; lines.append('like a rolling stone')
&gt;&gt;&gt; lines
['how does it feel', 'to be on your own', 'no directions known',
 'like a rolling stone']
&gt;&gt;&gt; s1 = ''.join(lines)
&gt;&gt;&gt; s2 = ' '.join(lines)
&gt;&gt;&gt; s3 = '\n'.join(lines)
&gt;&gt;&gt; s1
'how does it feelto be on your ownno directions knownlike a rolling stone'
&gt;&gt;&gt; s2
'how does it feel to be on your own no directions known like a rolling stone'
&gt;&gt;&gt; s3
'how does it feel\nto be on your own\nno directions known\nlike a rolling stone'
&gt;&gt;&gt; print s3
how does it feel
to be on your own
no directions known
like a rolling stone
</pre>
</li>
</ol>
</div>
<div class="section" id="raw-strings">
<h4><a class="toc-backref" href="#id190">3.4.3.4&nbsp;&nbsp;&nbsp;Raw strings</a></h4>
<p>Raw strings give us a convenient way to include the backslash
character in a string without escaping (with an additional
backslash).  Raw strings look like plain literal strings, but are
prefixed with an &quot;r&quot; or &quot;R&quot;.  See <a class="reference external" href="http://docs.python.org/reference/lexical_analysis.html#string-literals">String literals
http://docs.python.org/reference/lexical_analysis.html#string-literals</a></p>
<p>Excercises:</p>
<ol class="arabic simple">
<li>Create a string that contains a backslash character using both
plain literal string and a raw string.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We use an &quot;r&quot; prefix to define a raw string:</p>
<pre class="literal-block">
&gt;&gt;&gt; print 'abc \\ def'
abc \ def
&gt;&gt;&gt; print r'abc \ def'
abc \ def
</pre>
</li>
</ol>
</div>
<div class="section" id="id13">
<h4><a class="toc-backref" href="#id191">3.4.3.5&nbsp;&nbsp;&nbsp;Unicode strings</a></h4>
<p>Unicode strings give us a consistent way to process character data
from a variety of character encodings.</p>
<p>Excercises:</p>
<ol class="arabic simple">
<li>Create several unicode strings.  Use both the unicode prefix
character (&quot;u&quot;) and the unicode type (<tt class="docutils literal">unicode(some_string)</tt>).</li>
<li>Convert a string (possibly from another non-ascii encoding) to
unicode.</li>
<li>Convert a unicode string to another encoding, for example, utf-8.</li>
<li>Test a string to determine if it is unicode.</li>
<li>Create a string that contains a unicode character, that is, a
character outside the ascii character set.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can represent unicode string with either the &quot;u&quot; prefix or
with a call to the unicode type:</p>
<pre class="literal-block">
def exercise1():
    a = u'abcd'
    print a
    b = unicode('efgh')
    print b
</pre>
</li>
<li><p class="first">We convert a string from another character encoding into unicode
with the <tt class="docutils literal">decode()</tt> string method:</p>
<pre class="literal-block">
import sys

def exercise2():
    a = 'abcd'.decode('utf-8')
    print a
    b = 'abcd'.decode(sys.getdefaultencoding())
    print b
</pre>
</li>
<li><p class="first">We can convert a unicode string to another character encoding
with the <tt class="docutils literal">encode()</tt> string method:</p>
<pre class="literal-block">
import sys

def exercise3():
    a = u'abcd'
    print a.encode('utf-8')
    print a.encode(sys.getdefaultencoding())
</pre>
</li>
<li><p class="first">Here are two ways to check the type of a string:</p>
<pre class="literal-block">
import types

def exercise4():
    a = u'abcd'
    print type(a) is types.UnicodeType
    print type(a) is type(u'')
</pre>
</li>
<li><p class="first">We can encode unicode characters in a string in several ways, for
example, (1) by defining a utf-8 string and converting it to
unicode or (2) defining a string with an embedded unicode
character or (3) concatenating a unicode characher into a
string:</p>
<pre class="literal-block">
def exercise5():
    utf8_string = 'Ivan Krsti\xc4\x87'
    unicode_string = utf8_string.decode('utf-8')
    print unicode_string.encode('utf-8')
    print len(utf8_string)
    print len(unicode_string)
    unicode_string = u'aa\u0107bb'
    print unicode_string.encode('utf-8')
    unicode_string = 'aa' + unichr(263) + 'bb'
    print unicode_string.encode('utf-8')
</pre>
</li>
</ol>
<p>Guidance for use of encodings and unicode:</p>
<ol class="arabic">
<li><p class="first">Convert/decode from an external encoding to unicode early:</p>
<pre class="literal-block">
my_source_string.decode(encoding)
</pre>
</li>
<li><p class="first">Do your work (Python processing) in unicode.</p>
</li>
<li><p class="first">Convert/encode to an external encoding late (for example, just
before saving to an external file):</p>
<pre class="literal-block">
my_unicode_string.encode(encoding)
</pre>
</li>
</ol>
<p>For more information, see:</p>
<ul class="simple">
<li><a class="reference external" href="http://farmdev.com/talks/unicode/">Unicode In Python, Completely Demystified --
http://farmdev.com/talks/unicode/</a></li>
<li><a class="reference external" href="http://www.amk.ca/python/howto/unicode">Unicode How-to --
http://www.amk.ca/python/howto/unicode</a>.</li>
<li><a class="reference external" href="http://www.python.org/dev/peps/pep-0100/">PEP 100: Python Unicode Integration --
http://www.python.org/dev/peps/pep-0100/</a></li>
<li><a class="reference external" href="http://docs.python.org/lib/module-codecs.html">4.8 codecs -- Codec registry and base classes --
http://docs.python.org/lib/module-codecs.html</a></li>
<li><a class="reference external" href="http://docs.python.org/lib/encodings-overview.html">4.8.2 Encodings and Unicode --
http://docs.python.org/lib/encodings-overview.html</a></li>
<li><a class="reference external" href="http://docs.python.org/lib/standard-encodings.html">4.8.3 Standard Encodings --
http://docs.python.org/lib/standard-encodings.html</a></li>
<li><a class="reference external" href="http://effbot.org/zone/unicode-convert.htm">Converting Unicode Strings to 8-bit Strings --
http://effbot.org/zone/unicode-convert.htm</a></li>
</ul>
</div>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id192">3.4.4&nbsp;&nbsp;&nbsp;Dictionaries</a></h3>
<p>A dictionary is an un-ordered collection of key-value pairs.</p>
<p>A dictionary has a length, specifically the number of key-value
pairs.</p>
<p>A dictionary provides fast look up by key.</p>
<p>The keys must be immutable object types.</p>
<div class="section" id="literal-representation-of-dictionaries">
<h4><a class="toc-backref" href="#id193">3.4.4.1&nbsp;&nbsp;&nbsp;Literal representation of dictionaries</a></h4>
<p>Curley brackets are used to represent a dictionary.  Each pair in
the dictionary is represented by a key and value separated by a
colon. Multiple pairs are separated by comas.  For example, here is
an empty dictionary and several dictionaries containing key/value
pairs:</p>
<pre class="literal-block">
In [4]: d1 = {}
In [5]: d2 = {'width': 8.5, 'height': 11}
In [6]: d3 = {1: 'RED', 2: 'GREEN', 3: 'BLUE', }
In [7]: d1
Out[7]: {}
In [8]: d2
Out[8]: {'height': 11, 'width': 8.5}
In [9]: d3
Out[9]: {1: 'RED', 2: 'GREEN', 3: 'BLUE'}
</pre>
<p>Notes:</p>
<ul class="simple">
<li>A comma after the last pair is optional.  See the RED-GREEN-BLUE
example above.</li>
<li>Strings and integers work as keys, since they are immutable.  You
might also want to think about the use of tuples of integers as
keys in a dictionary used to represent a sparse array.</li>
</ul>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Define a dictionary that has the following key-value pairs:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Key</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Eggplant</td>
<td>Purple</td>
</tr>
<tr><td>Tomato</td>
<td>Red</td>
</tr>
<tr><td>Parsley</td>
<td>Green</td>
</tr>
<tr><td>Lemon</td>
<td>Yellow</td>
</tr>
<tr><td>Pepper</td>
<td>Green, Red, Yellow</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
<li><p class="first">Define a dictionary to represent the &quot;enum&quot; days of the week:
Sunday, Monday, Tuesday, ...</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">A dictionary whose keys and values are strings can be used to
represent this table:</p>
<pre class="literal-block">
vegetables = {
    'Eggplant': 'Purple',
    'Tomato': 'Red',
    'Parsley': 'Green',
    'Lemon': 'Yellow',
    'Pepper': 'Green',
    }
</pre>
<p>Note that the open curly bracket enables us to continue this
statement across multiple lines without using a backslash.</p>
</li>
<li><p class="first">We might use strings for the names of the days of the week as
keys:</p>
<pre class="literal-block">
DAYS = {
    'Sunday':    1,
    'Monday':    2,
    'Tuesday':   3,
    'Wednesday': 4,
    'Thrusday':  5,
    'Friday':    6,
    'Saturday':  7,
    }
</pre>
</li>
</ol>
</div>
<div class="section" id="operators-on-dictionaries">
<h4><a class="toc-backref" href="#id194">3.4.4.2&nbsp;&nbsp;&nbsp;Operators on dictionaries</a></h4>
<p>Dictionaries support the following &quot;operators&quot;:</p>
<ul>
<li><p class="first">Length -- <tt class="docutils literal">len(d)</tt> returns the number of pairs in a dictionary.</p>
</li>
<li><p class="first">Indexing -- You can both set and get the value associated with a
key by using the indexing operator <tt class="docutils literal">[ ]</tt>.  Examples:</p>
<pre class="literal-block">
In [12]: d3[2]
Out[12]: 'GREEN'
In [13]: d3[0] = 'WHITE'
In [14]: d3[0]
Out[14]: 'WHITE'
</pre>
</li>
<li><p class="first">Test for key -- The <tt class="docutils literal">in</tt> operator tests for the existence of a
key in a dictionary.  Example:</p>
<pre class="literal-block">
In [6]: trees = {'poplar': 'deciduous', 'cedar': 'evergreen'}
In [7]: if 'cedar' in trees:
   ...:     print 'The cedar is %s' % (trees['cedar'], )
   ...:
The cedar is evergreen
</pre>
</li>
</ul>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Create an empty dictionary, then use the indexing operator <tt class="docutils literal">[ ]</tt>
to in sert the following name-value pairs:</p>
<pre class="literal-block">
&quot;red&quot; --   &quot;255:0:0&quot;
&quot;green&quot; -- &quot;0:255:0&quot;
&quot;blue&quot; --  &quot;0:0:255&quot;
</pre>
</li>
<li><p class="first">Print out the number of items in your dictionary.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can use &quot;[ ]&quot; to set the value of a key in a dictionary:</p>
<pre class="literal-block">
def test():
    colors = {}
    colors[&quot;red&quot;] = &quot;255:0:0&quot;
    colors[&quot;green&quot;] = &quot;0:255:0&quot;
    colors[&quot;blue&quot;] = &quot;0:0:255&quot;
    print 'The value of red is &quot;%s&quot;' % (colors['red'], )
    print 'The colors dictionary contains %d items.' % (len(colors), )

test()
</pre>
<p>When we run this, we see:</p>
<pre class="literal-block">
The value of red is &quot;255:0:0&quot;
The colors dictionary contains 3 items.
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">len()</tt> built-in function gives us the number of items in a
dictionary.  See the previous solution for an example of this.</p>
</li>
</ol>
</div>
<div class="section" id="methods-on-dictionaries">
<h4><a class="toc-backref" href="#id195">3.4.4.3&nbsp;&nbsp;&nbsp;Methods on dictionaries</a></h4>
<p>Here is a table that describes the methods applicable to
dictionarys:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operation</th>
<th class="head">Result</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>len(a)</td>
<td>the number of items in a</td>
</tr>
<tr><td>a[k]</td>
<td>the item of a with key k</td>
</tr>
<tr><td>a[k] = v</td>
<td>set a[k] to v</td>
</tr>
<tr><td>del a[k]</td>
<td>remove a[k] from a</td>
</tr>
<tr><td>a.clear()</td>
<td>remove all items from a</td>
</tr>
<tr><td>a.copy()</td>
<td>a (shallow) copy of a</td>
</tr>
<tr><td>k in a</td>
<td>True if a has a key k, else False</td>
</tr>
<tr><td>k not in a</td>
<td>equivalent to not k in a</td>
</tr>
<tr><td>a.has_key(k)</td>
<td>equivalent to k in a, use that form in new code</td>
</tr>
<tr><td>a.items()</td>
<td>a copy of a's list of (key, value) pair</td>
</tr>
<tr><td>a.keys()</td>
<td>a copy of a's list of keys</td>
</tr>
<tr><td>a.update([b])</td>
<td>updates a with key/value pairs from b, overwriting
existing keys, returns None</td>
</tr>
<tr><td>a.fromkeys(seq[, value])</td>
<td>creates a new dictionary with keys from
seq and values set to value</td>
</tr>
<tr><td>a.values()</td>
<td>a copy of a's list of values</td>
</tr>
<tr><td>a.get(k[, x])</td>
<td>a[k] if k in a, else x)</td>
</tr>
<tr><td>a.setdefault(k[, x])</td>
<td>a[k] if k in a, else x (also setting it)</td>
</tr>
<tr><td>a.pop(k[, x])</td>
<td>a[k] if k in a, else x (and remove k) (8)</td>
</tr>
<tr><td>a.popitem()</td>
<td>remove and return an arbitrary (key, value) pair</td>
</tr>
<tr><td>a.iteritems()</td>
<td>return an iterator over (key, value) pairs</td>
</tr>
<tr><td>a.iterkeys()</td>
<td>return an iterator over the mapping's keys</td>
</tr>
<tr><td>a.itervalues()</td>
<td>return an iterator over the mapping's values</td>
</tr>
</tbody>
</table>
<p>You can also find this table at the standard documentation Web site
in the &quot;Python Library Reference&quot;:
<a class="reference external" href="http://docs.python.org/lib/typesmapping.html">Mapping Types -- dict
http://docs.python.org/lib/typesmapping.html</a></p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Print the keys and values in the above &quot;vegetable&quot; dictionary.</li>
<li>Print the keys and values in the above &quot;vegetable&quot; dictionary
with the keys in alphabetical order.</li>
<li>Test for the occurance of a key in a dictionary.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can use the <tt class="docutils literal">d.items()</tt> method to retrieve a list of tuples
containing key-value pairs, then use unpacking to capture the
key and value:</p>
<pre class="literal-block">
Vegetables = {
    'Eggplant': 'Purple',
    'Tomato': 'Red',
    'Parsley': 'Green',
    'Lemon': 'Yellow',
    'Pepper': 'Green',
    }

def test():
    for key, value in Vegetables.items():
        print 'key:', key, ' value:', value

test()
</pre>
</li>
<li><p class="first">We retrieve a list of keys with the <tt class="docutils literal">keys()</tt> method, the sort
it with the list <tt class="docutils literal">sort()</tt> method:</p>
<pre class="literal-block">
Vegetables = {
    'Eggplant': 'Purple',
    'Tomato': 'Red',
    'Parsley': 'Green',
    'Lemon': 'Yellow',
    'Pepper': 'Green',
    }

def test():
    keys = Vegetables.keys()
    keys.sort()
    for key in keys:
        print 'key:', key, ' value:', Vegetables[key]

test()
</pre>
</li>
<li><p class="first">To test for the existence of a key in a dictionary, we can use
either the <tt class="docutils literal">in</tt> operator (preferred) or the <tt class="docutils literal">d.has_key()</tt>
method (old style):</p>
<pre class="literal-block">
Vegetables = {
    'Eggplant': 'Purple',
    'Tomato': 'Red',
    'Parsley': 'Green',
    'Lemon': 'Yellow',
    'Pepper': 'Green',
    }

def test():
    if 'Eggplant' in Vegetables:
        print 'we have %s egplants' % Vegetables['Eggplant']
    if 'Banana' not in Vegetables:
        print 'yes we have no bananas'
    if Vegetables.has_key('Parsley'):
        print 'we have leafy, %s parsley' % Vegetables['Parsley']

test()
</pre>
<p>Which will print out:</p>
<pre class="literal-block">
we have Purple egplants
yes we have no bananas
we have leafy, Green parsley
</pre>
</li>
</ol>
</div>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id196">3.4.5&nbsp;&nbsp;&nbsp;Files</a></h3>
<p>A Python file object represents a file on a file system.</p>
<p>A file object open for reading a text file is iterable.  When we
iterate over it, it produces the lines in the file.</p>
<p>A file may be opened in these modes:</p>
<ul class="simple">
<li>'r' -- read mode.  The file must exist.</li>
<li>'w' -- write mode.  The file is created; an existing file is
overwritten.</li>
<li>'a' -- append mode.  An existing file is opened for writing (at
the end of the file).  A file is created if it does not exist.</li>
</ul>
<p>The <tt class="docutils literal">open()</tt> built-in function is used to create a file object.
For example, the following code (1) opens a file for writing, then
(2) for reading, then (3) for appending, and finally (4) for
reading again:</p>
<pre class="literal-block">
def test(infilename):
    # 1. Open the file in write mode, which creates the file.
    outfile = open(infilename, 'w')
    outfile.write('line 1\n')
    outfile.write('line 2\n')
    outfile.write('line 3\n')
    outfile.close()
    # 2. Open the file for reading.
    infile = open(infilename, 'r')
    for line in infile:
        print 'Line:', line.rstrip()
    infile.close()
    # 3. Open the file in append mode, and add a line to the end of
    #    the file.
    outfile = open(infilename, 'a')
    outfile.write('line 4\n')
    outfile.close()
    print '-' * 40
    # 4. Open the file in read mode once more.
    infile = open(infilename, 'r')
    for line in infile:
        print 'Line:', line.rstrip()
    infile.close()

test('tmp.txt')
</pre>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Open a text file for reading, then read the entire file as a
single string, and then split the content on newline characters.</li>
<li>Open a text file for reading, then read the entire file as a
list of strings, where each string is one line in the file.</li>
<li>Open a text file for reading, then iterate of each line in the
file and print it out.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Use the <tt class="docutils literal">open()</tt> built-in function to open the file and create
a file object.  Use the <tt class="docutils literal">read()</tt> method on the file object to
read the entire file.  Use the <tt class="docutils literal">split()</tt> or <tt class="docutils literal">splitlines()</tt>
methods to split the file into lines:</p>
<pre class="literal-block">
&gt;&gt;&gt; infile = open('tmp.txt', 'r')
&gt;&gt;&gt; content = infile.read()
&gt;&gt;&gt; infile.close()
&gt;&gt;&gt; lines = content.splitlines()
&gt;&gt;&gt; print lines
['line 1', 'line 2', 'line 3', '']
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">f.readlines()</tt> method returns a list of lines in a file:</p>
<pre class="literal-block">
&gt;&gt;&gt; infile = open('tmp.txt', 'r')
&gt;&gt;&gt; lines = infile.readlines()
&gt;&gt;&gt; infile.close()
&gt;&gt;&gt; print lines
['line 1\n', 'line 2\n', 'line 3\n']
</pre>
</li>
<li><p class="first">Since a file object (open for reading) is itself an iterator, we
can iterate over it in a <tt class="docutils literal">for</tt> statement:</p>
<pre class="literal-block">
&quot;&quot;&quot;
Test iteration over a text file.
Usage:
    python test.py in_file_name
&quot;&quot;&quot;

import sys

def test(infilename):
    infile = open(infilename, 'r')
    for line in infile:
        # Strip off the new-line character and any whitespace on
        # the right.
        line = line.rstrip()
        # Print only non-blank lines.
        if line:
            print line
    infile.close()

def main():
    args = sys.argv[1:]
    if len(args) != 1:
        print __doc__
        sys.exit(1)
    infilename = args[0]
    test(infilename)

if __name__ == '__main__':
    main()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The last two lines of this solution check the <tt class="docutils literal">__name__</tt>
attribute of the module itself so that the module will run as
a script but will <em>not</em> run when the module is imported by
another module.</li>
<li>The <tt class="docutils literal">__doc__</tt> attribute of the module gives us the module's
doc-string, which is the string defined at the top of the
module.</li>
<li><tt class="docutils literal">sys.argv</tt> gives us the command line. And, <tt class="docutils literal">sys.argv[1:]</tt>
chops off the program name, leaving us with the comman line
arguments.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="a-few-miscellaneous-data-types">
<h3><a class="toc-backref" href="#id197">3.4.6&nbsp;&nbsp;&nbsp;A few miscellaneous data types</a></h3>
<div class="section" id="none">
<h4><a class="toc-backref" href="#id198">3.4.6.1&nbsp;&nbsp;&nbsp;None</a></h4>
<p><tt class="docutils literal">None</tt> is a singleton.  There is only one instance of <tt class="docutils literal">None</tt>.
Use this value to indicate the absence of any other &quot;real&quot; value.</p>
<p>Test for <tt class="docutils literal">None</tt> with the identity operator <tt class="docutils literal">is</tt>.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Create a list, some of whose elements are <tt class="docutils literal">None</tt>.   Then write
a <tt class="docutils literal">for</tt> loop that counts the number of occurances of None in
the list.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The identity operators <tt class="docutils literal">is</tt> and <tt class="docutils literal">is not</tt> can be used to test
for <tt class="docutils literal">None</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = [11, None, 'abc', None, {}]
&gt;&gt;&gt; a
[11, None, 'abc', None, {}]
&gt;&gt;&gt; count = 0
&gt;&gt;&gt; for item in a:
...     if item is None:
...         count += 1
...
&gt;&gt;&gt;
&gt;&gt;&gt; print count
2
</pre>
</li>
</ol>
</div>
<div class="section" id="the-booleans-true-and-false">
<h4><a class="toc-backref" href="#id199">3.4.6.2&nbsp;&nbsp;&nbsp;The booleans True and False</a></h4>
<p>Python has the two boolean values <tt class="docutils literal">True</tt> and <tt class="docutils literal">False</tt>.  Many
comparison operators return <tt class="docutils literal">True</tt> and <tt class="docutils literal">False</tt>.</p>
<p>Examples:</p>
<ol class="arabic">
<li><p class="first">What value is returned by <tt class="docutils literal">3 &gt; 2</tt>?</p>
<p>Answer: The boolean value <tt class="docutils literal">True</tt>.</p>
</li>
<li><p class="first">Given these variable definitions:</p>
<pre class="literal-block">
x = 3
y = 4
z = 5
</pre>
<p>What does the following print out:</p>
<pre class="literal-block">
print y &gt; x and z &gt; y
</pre>
<p>Answer -- Prints out &quot;True&quot;</p>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="id18">
<h2><a class="toc-backref" href="#id200">3.5&nbsp;&nbsp;&nbsp;Statements</a></h2>
<div class="section" id="id19">
<h3><a class="toc-backref" href="#id201">3.5.1&nbsp;&nbsp;&nbsp;Assignment statement</a></h3>
<p>The assignment statement uses the assignment operator <tt class="docutils literal">=</tt>.</p>
<p>The assignment statement is a binding statement: it binds a value to
a name within a namespace.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Bind the value &quot;eggplant&quot; to the variable <tt class="docutils literal">vegetable</tt>.</li>
</ol>
<p>Solutions:</p>
<p>1. The <tt class="docutils literal">=</tt> operator is an assignment statement that binds a value
to a variable:</p>
<pre class="literal-block">
&gt;&gt;&gt; vegetable = &quot;eggplant&quot;
</pre>
<p>There is also augmented assignment using the operators <tt class="docutils literal">+=</tt>,
<tt class="docutils literal"><span class="pre">-=</span></tt>, <tt class="docutils literal">*=</tt>, <tt class="docutils literal">/=</tt>, etc.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Use augmented assignment to increment the value of an integer.</li>
<li>Use augmented assignment to append characters to the end of a
string.</li>
<li>Use augmented assignment to append the items in one list to
another.</li>
<li>Use augmented assignment to decrement a variable containing an
integer by 1.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">+=</tt> operator increments the value of an integer:</p>
<pre class="literal-block">
&gt;&gt;&gt; count = 0
&gt;&gt;&gt; count += 1
&gt;&gt;&gt; count
1
&gt;&gt;&gt; count += 1
&gt;&gt;&gt; count
2
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">+=</tt> operator appends characters to the end of a string:</p>
<pre class="literal-block">
&gt;&gt;&gt; buffer = 'abcde'
&gt;&gt;&gt; buffer += 'fgh'
&gt;&gt;&gt; buffer
'abcdefgh'
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">+=</tt> operator appends items in one list to another:</p>
<pre class="literal-block">
In [20]: a = [11, 22, 33]
In [21]: b = [44, 55]
In [22]: a += b
In [23]: a
Out[23]: [11, 22, 33, 44, 55]
</pre>
</li>
</ol>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal"><span class="pre">-=</span></tt> operator decrements the value of an integer:</p>
<pre class="literal-block">
&gt;&gt;&gt; count = 5
&gt;&gt;&gt; count
5
&gt;&gt;&gt; count -= 1
&gt;&gt;&gt; count
4
</pre>
</li>
</ol>
<p>You can also assign a value to (1) an element of a list, (2) an item
in a dictionary, (3) an attribute of an object, etc.</p>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Create a list of three items, then assign a new value to the 2nd
element in the list.</p>
</li>
<li><p class="first">Create a dictionary, then assign values to the keys &quot;vegetable&quot;
and &quot;fruit&quot; in that dictionary.</p>
</li>
<li><p class="first">Use the following code to create an instance of a class:</p>
<pre class="literal-block">
class A(object):
    pass
a = A()
</pre>
<p>Then assign values to an attribue named <tt class="docutils literal">category</tt> in that
instance.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Assignment with the indexing operator <tt class="docutils literal">[]</tt> assigns a value to
an element in a list:</p>
<pre class="literal-block">
&gt;&gt;&gt; trees = ['pine', 'oak', 'elm']
&gt;&gt;&gt; trees
['pine', 'oak', 'elm']
&gt;&gt;&gt; trees[1] = 'cedar'
&gt;&gt;&gt; trees
['pine', 'cedar', 'elm']
</pre>
</li>
<li><p class="first">Assignment with the indexing operator <tt class="docutils literal">[]</tt> assigns a value to
an item (a key-value pair) in a dictionary:</p>
<pre class="literal-block">
&gt;&gt;&gt; foods = {}
&gt;&gt;&gt; foods
{}
&gt;&gt;&gt; foods['vegetable'] = 'green beans'
&gt;&gt;&gt; foods['fruit'] = 'nectarine'
&gt;&gt;&gt; foods
{'vegetable': 'green beans', 'fruit': 'nectarine'}
</pre>
</li>
<li><p class="first">Assignment along with the dereferencing operator <tt class="docutils literal">.</tt> (dot)
enables us to assign a value to an attribute of an object:</p>
<pre class="literal-block">
&gt;&gt;&gt; class A(object):
...     pass
...
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.category = 25
&gt;&gt;&gt; a.__dict__
{'category': 25}
&gt;&gt;&gt; a.category
25
</pre>
</li>
</ol>
</div>
<div class="section" id="id20">
<h3><a class="toc-backref" href="#id202">3.5.2&nbsp;&nbsp;&nbsp;print statement</a></h3>
<p><strong>Warning:</strong> Be aware that the <tt class="docutils literal">print</tt> statement will go away in
Python version 3.0.  It will be replaced by the built-in <tt class="docutils literal">print()</tt>
function.</p>
<p>The <tt class="docutils literal">print</tt> statement sends output to standard output.  It
provides a somewhat more convenient way of producing output than
using <tt class="docutils literal">sys.stdout.write()</tt>.</p>
<p>The <tt class="docutils literal">print</tt> statement takes a series of zero or more objects
separated by commas.  Zero objects produces a blank line.</p>
<p>The print statement normally adds a newline at the end of its
output.  To eliminate that, add a comma at the end.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Print a single string.</li>
<li>Print three strings using a single <tt class="docutils literal">print</tt> statement.</li>
<li>Given a variable <tt class="docutils literal">name</tt> containing a string, print out the
string <tt class="docutils literal">My name is &quot;xxxx&quot;.</tt>, where xxxx is replace by the value
of <tt class="docutils literal">name</tt>.  Use the string formatting operator.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can print a literal string:</p>
<pre class="literal-block">
&gt;&gt;&gt; print 'Hello, there'
Hello, there
</pre>
</li>
<li><p class="first">We can print literals and the value of variables:</p>
<pre class="literal-block">
&gt;&gt;&gt; description = 'cute'
&gt;&gt;&gt; print 'I am a', description, 'kid.'
I am a cute kid.
</pre>
</li>
<li><p class="first">The string formatting operator gives more control over formatting
output:</p>
<pre class="literal-block">
&gt;&gt;&gt; name = 'Alice'
&gt;&gt;&gt; print 'My name is &quot;%s&quot;.' % (name, )
My name is &quot;Alice&quot;.
</pre>
</li>
</ol>
</div>
<div class="section" id="if-statement-exercises">
<h3><a class="toc-backref" href="#id203">3.5.3&nbsp;&nbsp;&nbsp;if: statement exercises</a></h3>
<p>The <tt class="docutils literal">if</tt> statement is a compound statement that enables us to
conditionally execute blocks of code.</p>
<p>The <tt class="docutils literal">if</tt> statement also has optional <tt class="docutils literal">elif:</tt> and <tt class="docutils literal">else:</tt>
clauses.</p>
<p>The condition in an <tt class="docutils literal">if:</tt> or <tt class="docutils literal">elif:</tt> clause can be any Python
expression, in other words, something that returns a value (even if
that value is <tt class="docutils literal">None</tt>).</p>
<p>In the condition in an <tt class="docutils literal">if:</tt> or <tt class="docutils literal">elif:</tt> clause, the following
values count as &quot;false&quot;:</p>
<ul class="simple">
<li><tt class="docutils literal">False</tt></li>
<li><tt class="docutils literal">None</tt></li>
<li>Numeric zero</li>
<li>An empty collection, for example an empty list or dictionary</li>
<li>An empty string (a string of length zero)</li>
</ul>
<p>All other values count as true.</p>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Given the following list:</p>
<pre class="literal-block">
&gt;&gt;&gt; bananas = ['banana1', 'banana2', 'banana3',]
</pre>
<p>Print one message if it is an empty list and another messge if it
is not.</p>
</li>
<li><p class="first">Here is one way of defining a Python equivalent of an &quot;enum&quot;:</p>
<pre class="literal-block">
NO_COLOR, RED, GREEN, BLUE = range(4)
</pre>
<p>Write an <tt class="docutils literal">if:</tt> statement which implements the effect of a
&quot;switch&quot; statement in Python.  Print out a unique message for
each color.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can test for an empty or non-empty list:</p>
<pre class="literal-block">
&gt;&gt;&gt; bananas = ['banana1', 'banana2', 'banana3',]
&gt;&gt;&gt; if not bananas:
...     print 'yes, we have no bananas'
... else:
...     print 'yes, we have bananas'
...
yes, we have bananas
</pre>
</li>
<li><p class="first">We can simulate a &quot;switch&quot; statement using <tt class="docutils literal">if:elif: ...</tt>:</p>
<pre class="literal-block">
NO_COLOR, RED, GREEN, BLUE = range(4)

def test(color):
    if color == RED:
        print &quot;It's red.&quot;
    elif color == GREEN:
        print &quot;It's green.&quot;
    elif color == BLUE:
        print &quot;It's blue.&quot;

def main():
    color = BLUE
    test(color)

if __name__ == '__main__':
    main()
</pre>
<p>Which, when run prints out the following:</p>
<pre class="literal-block">
It's blue.
</pre>
</li>
</ol>
</div>
<div class="section" id="for-statement-exercises">
<h3><a class="toc-backref" href="#id204">3.5.4&nbsp;&nbsp;&nbsp;for: statement exercises</a></h3>
<p>The <tt class="docutils literal">for:</tt> statement is the Python way to iterate over and process
the elements of a collection or other iterable.</p>
<p>The basic form of the <tt class="docutils literal">for:</tt> statement is the following:</p>
<pre class="literal-block">
for X in Y:
    statement
    o
    o
    o
</pre>
<p>where:</p>
<ul class="simple">
<li><tt class="docutils literal">X</tt> is something that can be assigned to.  It is something to
which Python can bind a value.</li>
<li><tt class="docutils literal">Y</tt> is some collection or other iterable.</li>
</ul>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Create a list of integers.  Use a <tt class="docutils literal">for:</tt> statement to print out
each integer in the list.</li>
<li>Create a string.  print out each character in the string.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">for:</tt> statement can iterate over the items in a list:</p>
<pre class="literal-block">
In [13]: a = [11, 22, 33, ]
In [14]: for value in a:
   ....:     print 'value: %d' % value
   ....:
   ....:
value: 11
value: 22
value: 33
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">for:</tt> statement can iterate over the characters in a
string:</p>
<pre class="literal-block">
In [16]: b = 'chocolate'
In [17]: for chr1 in b:
   ....:     print 'character: %s' % chr1
   ....:
   ....:
character: c
character: h
character: o
character: c
character: o
character: l
character: a
character: t
character: e
</pre>
<p>Notes:</p>
<ul class="simple">
<li>In the solution, I used the variable name <tt class="docutils literal">chr1</tt> rather than
<tt class="docutils literal">chr</tt> so as not to over-write the name of the built-in
function <tt class="docutils literal">chr()</tt>.</li>
</ul>
</li>
</ol>
<p>When we need a sequential index, we can use the <tt class="docutils literal">range()</tt> built-in
function to create a list of integers.  And, the <tt class="docutils literal">xrange()</tt>
built-in function produces an interator that produces a sequence of
integers without creating the entire list.  To iterate over a large
sequence of integers, use <tt class="docutils literal">xrange()</tt> instead of <tt class="docutils literal">range()</tt>.</p>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Print out the integers from 0 to 5 in sequence.</p>
</li>
<li><p class="first">Compute the sum of all the integers from 0 to 99999.</p>
</li>
<li><p class="first">Given the following generator function:</p>
<pre class="literal-block">
import urllib

Urls = [
    'http://yahoo.com',
    'http://python.org',
    'http://gimp.org',    # The GNU image manipulation program
    ]

def walk(url_list):
    for url in url_list:
        f = urllib.urlopen(url)
        stuff = f.read()
        f.close()
        yield stuff
</pre>
<p>Write a <tt class="docutils literal">for:</tt> statement that uses this iterator generator to
print the lengths of the content at each of the Web pages in that
list.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">range()</tt> built-in function gives us a sequence to iterate
over:</p>
<pre class="literal-block">
In [5]: for idx in range(6):
   ...:     print 'idx: %d' % idx
   ...:
   ...:
idx: 0
idx: 1
idx: 2
idx: 3
idx: 4
idx: 5
</pre>
</li>
<li><p class="first">Since that sequence is a bit large, we'll use <tt class="docutils literal">xrange()</tt>
instead of <tt class="docutils literal">range()</tt>:</p>
<pre class="literal-block">
In [8]: count = 0
In [9]: for n in xrange(100000):
   ...:     count += n
   ...:
   ...:
In [10]: count
Out[10]: 4999950000
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">for:</tt> statement enables us to iterate over iterables as
well as collections:</p>
<pre class="literal-block">
import urllib

Urls = [
    'http://yahoo.com',
    'http://python.org',
    'http://gimp.org',    # The GNU image manipulation program
    ]

def walk(url_list):
    for url in url_list:
        f = urllib.urlopen(url)
        stuff = f.read()
        f.close()
        yield stuff

def test():
    for url in walk(Urls):
        print 'length: %d' % (len(url), )

if __name__ == '__main__':
    test()
</pre>
<p>When I ran this script, it prints the following:</p>
<pre class="literal-block">
length: 9562
length: 16341
length: 12343
</pre>
</li>
</ol>
<p>If you need an index while iterating over a sequence, consider
using the <tt class="docutils literal">enumerate()</tt> built-in function.</p>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Given the following two lists of integers of the same length:</p>
<pre class="literal-block">
a = [1, 2, 3, 4, 5]
b = [100, 200, 300, 400, 500]
</pre>
<p>Add the values in the first list to the corresponding values in
the second list.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">enumerate()</tt> built-in function gives us an index and
values from a sequence.  Since <tt class="docutils literal">enumerate()</tt> gives us an
interator that produces a sequence of two-tuples, we can unpack
those tuples into index and value variables in the header line
of the <tt class="docutils literal">for</tt> statement:</p>
<pre class="literal-block">
In [13]: a = [1, 2, 3, 4, 5]
In [14]: b = [100, 200, 300, 400, 500]
In [15]:
In [16]: for idx, value in enumerate(a):
   ....:     b[idx] += value
   ....:
   ....:
In [17]: b
Out[17]: [101, 202, 303, 404, 505]
</pre>
</li>
</ol>
</div>
<div class="section" id="while-statement-exercises">
<h3><a class="toc-backref" href="#id205">3.5.5&nbsp;&nbsp;&nbsp;while: statement exercises</a></h3>
<p>A <tt class="docutils literal">while:</tt> statement executes a block of code repeatedly as long as a
condition is true.</p>
<p>Here is a template for the <tt class="docutils literal">while:</tt> statement:</p>
<pre class="literal-block">
while condition:
    statement
    o
    o
    o
</pre>
<p>Where:</p>
<ul class="simple">
<li><tt class="docutils literal">condition</tt> is an expression.  The expression is something that
returns a value which can be interpreted as true or false.</li>
</ul>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Write a <tt class="docutils literal">while:</tt> loop that doubles all the values in a list of
integers.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">A <tt class="docutils literal">while:</tt> loop with an index variable can be used to modify
each element of a list:</p>
<pre class="literal-block">
def test_while():
    numbers = [11, 22, 33, 44, ]
    print 'before: %s' % (numbers, )
    idx = 0
    while idx &lt; len(numbers):
        numbers[idx] *= 2
        idx += 1
    print 'after: %s' % (numbers, )
</pre>
<p>But, notice that this task is easier using the <tt class="docutils literal">for:</tt> statement
and the built-in <tt class="docutils literal">enumerate()</tt> function:</p>
<pre class="literal-block">
def test_for():
    numbers = [11, 22, 33, 44, ]
    print 'before: %s' % (numbers, )
    for idx, item in enumerate(numbers):
        numbers[idx] *= 2
    print 'after: %s' % (numbers, )
</pre>
</li>
</ol>
</div>
<div class="section" id="break-and-continue-statements">
<h3><a class="toc-backref" href="#id206">3.5.6&nbsp;&nbsp;&nbsp;break and continue statements</a></h3>
<p>The <tt class="docutils literal">continue</tt> statement skips the remainder of the statements in
the body of a loop and starts immediately at the top of the loop
again.</p>
<p>A <tt class="docutils literal">break</tt> statement in the body of a loop terminates the loop.
It exits from the immediately containing loop.</p>
<p><tt class="docutils literal">break</tt> and <tt class="docutils literal">continue</tt> can be used in both <tt class="docutils literal">for:</tt> and
<tt class="docutils literal">while:</tt> statements.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Write a <tt class="docutils literal">for:</tt> loop that takes a list of integers and triples
each integer that is even.  Use the <tt class="docutils literal">continue</tt> statement.</li>
<li>Write a loop that takes a list of integers and computes the sum
of all the integers up until a zero is found in the list.  Use
the <tt class="docutils literal">break</tt> statement.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">continue</tt> statement enables us to &quot;skip&quot; items that
satisfy a condition or test:</p>
<pre class="literal-block">
def test():
    numbers = [11, 22, 33, 44, 55, 66, ]
    print 'before: %s' % (numbers, )
    for idx, item in enumerate(numbers):
        if item % 2 != 0:
            continue
        numbers[idx] *= 3
    print 'after: %s' % (numbers, )

test()
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">break</tt> statement enables us to exit from a loop when we
find a zero:</p>
<pre class="literal-block">
def test():
    numbers = [11, 22, 33, 0, 44, 55, 66, ]
    print 'numbers: %s' % (numbers, )
    sum = 0
    for item in numbers:
        if item == 0:
            break
        sum += item
    print 'sum: %d' % (sum, )

test()
</pre>
</li>
</ol>
</div>
<div class="section" id="exceptions-and-the-try-except-and-raise-statements">
<h3><a class="toc-backref" href="#id207">3.5.7&nbsp;&nbsp;&nbsp;Exceptions and the try:except: and raise statements</a></h3>
<p>The <tt class="docutils literal">try:except:</tt> statement enables us to catch an exception that
is thrown from within a block of code, or from code called from any
depth withing that block.</p>
<p>The <tt class="docutils literal">raise</tt> statement enables us to throw an exception.</p>
<p>An exception is a class or an instance of an exception class.  If an
exception is not caught, it results in a traceback and termination
of the program.</p>
<p>There is a set of standard exceptions.  You can learn about them
here: <a class="reference external" href="http://docs.python.org/lib/module-exceptions.html">Built-in Exceptions --
http://docs.python.org/lib/module-exceptions.html</a>.</p>
<p>You can define your own exception classes.  To do so, create an empty
subclass of the class <tt class="docutils literal">Exception</tt>.  Defining your own exception
will enable you (or others) to throw and then catch that specific exception
type while ignore others exceptions.</p>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Write a <tt class="docutils literal">try:except:</tt> statement that attempts to open a file
for reading and catches the exception thrown when the file does
not exist.</p>
<p>Question: How do you find out the name of the exception that is
thrown for an input/output error such as the failure to open a
file?</p>
</li>
<li><p class="first">Define an exception class.  Then write a <tt class="docutils literal">try:except:</tt>
statement in which you throw and catch that specific exception.</p>
</li>
<li><p class="first">Define an exception class and use it to implement a multi-level
break from an inner loop, by-passing an outer loop.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Use the Python interactive interpreter to learn the exception
type thrown when a I/O error occurs.  Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; infile = open('xx_nothing__yy.txt', 'r')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IOError: [Errno 2] No such file or directory: 'xx_nothing__yy.txt'
&gt;&gt;&gt;
</pre>
<p>In this case, the exception type is <tt class="docutils literal">IOError</tt>.</p>
<p>Now, write a <tt class="docutils literal">try:except:</tt> block which catches that exception:</p>
<pre class="literal-block">
def test():
    infilename = 'nothing_noplace.txt'
    try:
        infile = open(infilename, 'r')
        for line in infile:
            print line
    except IOError, exp:
        print 'cannot open file &quot;%s&quot;' % infilename

test()
</pre>
</li>
<li><p class="first">We define a exception class as a sub-class of class
<tt class="docutils literal">Exception</tt>, then throw it (with the <tt class="docutils literal">raise</tt> statement) and
catch it (with a <tt class="docutils literal">try:except:</tt> statement):</p>
<pre class="literal-block">
class SizeError(Exception):
    pass

def test_exception(size):
    try:
        if size &lt;= 0:
            raise SizeError, 'size must be greater than zero'
        # Produce a different error to show that it will not be caught.
        x = y
    except SizeError, exp:
        print '%s' % (exp, )
        print 'goodbye'

def test():
    test_exception(-1)
    print '-' * 40
    test_exception(1)

test()
</pre>
<p>When we run this script, it produces the following output:</p>
<pre class="literal-block">
$ python workbook027.py
size must be greater than zero
goodbye
----------------------------------------
Traceback (most recent call last):
  File &quot;workbook027.py&quot;, line 20, in &lt;module&gt;
    test()
  File &quot;workbook027.py&quot;, line 18, in test
    test_exception(1)
  File &quot;workbook027.py&quot;, line 10, in test_exception
    x = y
NameError: global name 'y' is not defined
</pre>
<p>Notes:</p>
<ul class="simple">
<li>Our <tt class="docutils literal">except:</tt> clause caught the <tt class="docutils literal">SizeError</tt>, but allowed
the <tt class="docutils literal">NameError</tt> to be uncaught.</li>
</ul>
</li>
<li><p class="first">We define a sub-class of of class <tt class="docutils literal">Exception</tt>, then raise it in
an inner loop and catch it outside of an outer loop:</p>
<pre class="literal-block">
class BreakException1(Exception):
    pass

def test():
    a = [11, 22, 33, 44, 55, 66, ]
    b = [111, 222, 333, 444, 555, 666, ]
    try:
        for x in a:
            print 'outer -- x: %d' % x
            for y in b:
                if x &gt; 22 and y &gt; 444:
                    raise BreakException1('leaving inner loop')
                print 'inner -- y: %d' % y
            print 'outer -- after'
            print '-' * 40
    except BreakException1, exp:
        print 'out of loop -- exp: %s' % exp

test()
</pre>
<p>Here is what this prints out when run:</p>
<pre class="literal-block">
outer -- x: 11
inner -- y: 111
inner -- y: 222
inner -- y: 333
inner -- y: 444
inner -- y: 555
inner -- y: 666
outer -- after
----------------------------------------
outer -- x: 22
inner -- y: 111
inner -- y: 222
inner -- y: 333
inner -- y: 444
inner -- y: 555
inner -- y: 666
outer -- after
----------------------------------------
outer -- x: 33
inner -- y: 111
inner -- y: 222
inner -- y: 333
inner -- y: 444
out of loop -- exp: leaving inner loop
</pre>
</li>
</ol>
</div>
</div>
<div class="section" id="id21">
<h2><a class="toc-backref" href="#id208">3.6&nbsp;&nbsp;&nbsp;Functions</a></h2>
<p>A function has these characteristics:</p>
<ul class="simple">
<li>It groups a block of code together so that we can call it by name.</li>
<li>It enables us to pass values into the the function when we call
it.</li>
<li>It can returns a value (even if None).</li>
<li>When a function is called, it has its own namespace.  Variables in
the function are local to the function (and disappear when the
function exits).</li>
</ul>
<p>A function is defined with the <tt class="docutils literal">def:</tt> statement.  Here is a simple
example/template:</p>
<pre class="literal-block">
def function_name(arg1, arg2):
    local_var1 = arg1 + 1
    local_var2 = arg2 * 2
    return local_var1 + local_var2
</pre>
<p>And, here is an example of calling this function:</p>
<pre class="literal-block">
result = function_name(1, 2)
</pre>
<p>Here are a few notes of explanation:</p>
<ul class="simple">
<li>The above defines a function whose name is <tt class="docutils literal">function_name</tt>.</li>
<li>The function <tt class="docutils literal">function_name</tt> has two arguments.  That means that
we can and must pass in exactly two values when we call it.</li>
<li>This function has two local variables, <tt class="docutils literal">local_var1</tt> and
<tt class="docutils literal">local_var2</tt>.  These variables are local in the sense that after
we call this function, these two variables are <strong>not</strong> available
in the location of the caller.</li>
<li>When we call this function, it returns one value, specifically the
sum of <tt class="docutils literal">local_var1</tt> and <tt class="docutils literal">local_var2</tt>.</li>
</ul>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Write a function that takes a list of integers as an argument,
and returns the sum of the integers in that list.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">return</tt> statement enables us to return a value from a
function:</p>
<pre class="literal-block">
def list_sum(values):
    sum = 0
    for value in values:
        sum += value
    return sum

def test():
    a = [11, 22, 33, 44, ]
    print list_sum(a)

if __name__ == '__main__':
    test()
</pre>
</li>
</ol>
<div class="section" id="optional-arguments-and-default-values">
<h3><a class="toc-backref" href="#id209">3.6.1&nbsp;&nbsp;&nbsp;Optional arguments and default values</a></h3>
<p>You can provide a default value for an argument to a function.</p>
<p>If you do, that argument is optional (when the function is called).</p>
<p>Here are a few things to learn about optional arguments:</p>
<ul>
<li><p class="first">Provide a default value with an equal sign and a value.  Example:</p>
<pre class="literal-block">
def sample_func(arg1, arg2, arg3='empty', arg4=0):
</pre>
</li>
<li><p class="first">All parameters with default values must be after (to the right of)
normal parameters.</p>
</li>
<li><p class="first">Do not use a mutable object as a default value. Because the
<tt class="docutils literal">def:</tt> statement is evaluated only once and <strong>not</strong> each time
the function is called, the mutable object might be shared across
multiple calls to the function.  Do not do this:</p>
<pre class="literal-block">
def sample_func(arg1, arg2=[]):
</pre>
<p>Instead, do this:</p>
<pre class="literal-block">
def sample_func(arg1, arg2=None):
    if arg2 is None:
        arg2 = []
</pre>
<p>Here is an example that illustrates how this might go wrong:</p>
<pre class="literal-block">
def adder(a, b=[]):
    b.append(a)
    return b

def test():
    print adder('aaa')
    print adder('bbb')
    print adder('ccc')

test()
</pre>
<p>Which, when executed, displays the following:</p>
<pre class="literal-block">
['aaa']
['aaa', 'bbb']
['aaa', 'bbb', 'ccc']
</pre>
</li>
</ul>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Write a function that writes a string to a file.  The function
takes two arguments: (1) a file that is open for output and (2)
a string.  Give the second argument (the string) a default value
so that when the second argument is omitted, an empty, blank
line is written to the file.</li>
<li>Write a function that takes the following arguments: (1) a name,
(2) a value, and (3) and optional dictionary.  The function adds
the value to the dictionary using the name as a key in the
dictionary.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can pass a file as we would any other object.  And, we can use
a newline character as a default parameter value:</p>
<pre class="literal-block">
import sys

def writer(outfile, msg='\n'):
    outfile.write(msg)

def test():
    writer(sys.stdout, 'aaaaa\n')
    writer(sys.stdout)
    writer(sys.stdout, 'bbbbb\n')

test()
</pre>
<p>When run from the command line, this prints out the following:</p>
<pre class="literal-block">
aaaaa

bbbbb
</pre>
</li>
<li><p class="first">In this solution we are careful <strong>not</strong> to use a mutable object
as a default value:</p>
<pre class="literal-block">
def add_to_dict(name, value, dic=None):
    if dic is None:
        dic = {}
    dic[name] = value
    return dic

def test():
    dic1 = {'albert': 'cute', }
    print add_to_dict('barry', 'funny', dic1)
    print add_to_dict('charlene', 'smart', dic1)
    print add_to_dict('darryl', 'outrageous')
    print add_to_dict('eddie', 'friendly')

test()
</pre>
<p>If we run this script, we see:</p>
<pre class="literal-block">
{'barry': 'funny', 'albert': 'cute'}
{'barry': 'funny', 'albert': 'cute', 'charlene': 'smart'}
{'darryl': 'outrageous'}
{'eddie': 'friendly'}
</pre>
<p>Notes:</p>
<ul class="simple">
<li>It's important that the default value for the dictionary is
<tt class="docutils literal">None</tt> rather than an empty dictionary, for example
(<tt class="docutils literal">{}</tt>).  Remember that the <tt class="docutils literal">def:</tt> statement is evaluated
only once, which results in a <em>single</em> dictionary, which would
be shared by all callers that do not provide a dictionary as an
argument.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="passing-functions-as-arguments">
<h3><a class="toc-backref" href="#id210">3.6.2&nbsp;&nbsp;&nbsp;Passing functions as arguments</a></h3>
<p>A function, like any other object, can be passed as an argument to a
function.  This is due the the fact that almost all (maybe all)
objects in Python are &quot;first class objects&quot;.  A first class object
is one which we can:</p>
<ol class="arabic simple">
<li>Store in a data structure (e.g. a list, a dictionary, ...).</li>
<li>Pass to a function.</li>
<li>Return from a function.</li>
</ol>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Write a function that takes three arguments: (1) an input file,
(2) an output file, and (3) a filter function:</p>
<ul class="simple">
<li>Argument 1 is a file opened for reading.</li>
<li>Argument 2 is a file opened for writing.</li>
<li>Argument 3 is a function that takes a single argument (a
string), performs a transformation on that string, and returns
the transformed string.</li>
</ul>
<p>The above function should read each line in the input text file,
pass that line through the filter function, then write that
(possibly) transformed line to the output file.</p>
<p>Now, write one or more &quot;filter functions&quot; that can be passed to
the function described above.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">This script adds or removes comment characters to the lines of a
file:</p>
<pre class="literal-block">
import sys

def filter(infile, outfile, filterfunc):
    for line in infile:
        line = filterfunc(line)
        outfile.write(line)

def add_comment(line):
    line = '## %s' % (line, )
    return line

def remove_comment(line):
    if line.startswith('## '):
        line = line[3:]
    return line

def main():
    filter(sys.stdin, sys.stdout, add_comment)

if __name__ == '__main__':
    main()
</pre>
<p>Running this might produce something like the following (note for
MS Windows users: use <tt class="docutils literal">type</tt> instead of <tt class="docutils literal">cat</tt>):</p>
<pre class="literal-block">
$ cat tmp.txt
line 1
line 2
line 3
$ cat tmp.txt | python workbook005.py
## line 1
## line 2
## line 3
</pre>
</li>
</ol>
</div>
<div class="section" id="extra-args-and-keyword-args">
<h3><a class="toc-backref" href="#id211">3.6.3&nbsp;&nbsp;&nbsp;Extra args and keyword args</a></h3>
<p>Additional positional arguments passed to a function that are not
specified in the function definition (the <tt class="docutils literal">def:</tt> statement``), are
collected in an argument preceded by a single asterisk.  Keyword
arguments passed to a function that are not specified in the
function definition can be collected in a dictionary and passed to
an argument preceded by a double asterisk.</p>
<p>Examples:</p>
<ol class="arabic simple">
<li>Write a function that takes one positional argument, one argument
with a default value, and also extra args and keyword args.</li>
<li>Write a function that passes all its arguments, no matter how
many, to a call to another function.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We use <tt class="docutils literal">*args</tt> and <tt class="docutils literal">**kwargs</tt> to collect extra arguments and
extra keyword arguments:</p>
<pre class="literal-block">
def show_args(x, y=-1, *args, **kwargs):
    print '-' * 40
    print 'x:', x
    print 'y:', y
    print 'args:', args
    print 'kwargs:', kwargs

def test():
    show_args(1)
    show_args(x=2, y=3)
    show_args(y=5, x=4)
    show_args(4, 5, 6, 7, 8)
    show_args(11, y=44, a=55, b=66)

test()
</pre>
<p>Running this script produces the following:</p>
<pre class="literal-block">
$ python workbook006.py
----------------------------------------
x: 1
y: -1
args: ()
kwargs: {}
----------------------------------------
x: 2
y: 3
args: ()
kwargs: {}
----------------------------------------
x: 4
y: 5
args: ()
kwargs: {}
----------------------------------------
x: 4
y: 5
args: (6, 7, 8)
kwargs: {}
----------------------------------------
x: 11
y: 44
args: ()
kwargs: {'a': 55, 'b': 66}
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The spelling of <tt class="docutils literal">args</tt> and <tt class="docutils literal">kwargs</tt> is not fixed, but the</li>
</ul>
</li>
<li><p class="first">We use <tt class="docutils literal">args</tt> and <tt class="docutils literal">kwargs</tt> to catch and pass on all
arguments:</p>
<pre class="literal-block">
def func1(*args, **kwargs):
    print 'args: %s' % (args, )
    print 'kwargs: %s' % (kwargs, )

def func2(*args, **kwargs):
    print 'before'
    func1(*args, **kwargs)
    print 'after'

def test():
    func2('aaa', 'bbb', 'ccc', arg1='ddd', arg2='eee')

test()
</pre>
<p>When we run this, it prints the following:</p>
<pre class="literal-block">
before
args: ('aaa', 'bbb', 'ccc')
kwargs: {'arg1': 'ddd', 'arg2': 'eee'}
after
</pre>
<p>Notes:</p>
<ul class="simple">
<li>In a function <em>call</em>, the <tt class="docutils literal">*</tt> operator unrolls a list into
individual positional arguments, and the <tt class="docutils literal">**</tt> operator unrolls
a dictionary into individual keyword arguments.</li>
</ul>
</li>
</ol>
<div class="section" id="order-of-arguments-positional-extra-and-keyword-args">
<h4><a class="toc-backref" href="#id212">3.6.3.1&nbsp;&nbsp;&nbsp;Order of arguments (positional, extra, and keyword args)</a></h4>
<p>In a function <em>definition</em>, arguments must appear in the following
order, from left to right:</p>
<ol class="arabic simple">
<li>Positional (normal, plain) arguments</li>
<li>Arguments with default values, if any</li>
<li>Extra arguments parameter (proceded by single asterisk), if present</li>
<li>Keyword arguments parameter (proceded by double asterisk), if present</li>
</ol>
<p>In a function <em>call</em>, arguments must appear in the following
order, from left to right:</p>
<ol class="arabic simple">
<li>Positional (plain) arguments</li>
<li>Extra arguments, if present</li>
<li>Keyword arguments, if present</li>
</ol>
</div>
</div>
<div class="section" id="functions-and-duck-typing-and-polymorphism">
<h3><a class="toc-backref" href="#id213">3.6.4&nbsp;&nbsp;&nbsp;Functions and duck-typing and polymorphism</a></h3>
<p>If the arguments and return value of a function satisfy some
description, then we can say that the function is polymorphic with
respect to that description.</p>
<p>If the some of the methods of an object satisfy some description,
then we can say that the object is polymorphic with respect to
that description.</p>
<p>Basically, what this does is to enable us to use a function or an
object anywhere that function satisfies the requirements given by a
description.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Implement a function that takes two arguments: a function and an
object.  It applies the function argument to the object.</li>
<li>Implement a function that takes two arguments: a list of
functions and an object. It applies each function in the list to
the argument.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can pass a function as an argument to a function:</p>
<pre class="literal-block">
def fancy(obj):
    print 'fancy fancy -- %s -- fancy fancy' % (obj, )

def plain(obj):
    print 'plain -- %s -- plain' % (obj, )

def show(func, obj):
    func(obj)

def main():
    a = {'aa': 11, 'bb': 22, }
    show(fancy, a)
    show(plain, a)

if __name__ == '__main__':
    main()
</pre>
</li>
<li><p class="first">We can also put functions (function objects) in a data structure
(for example, a list), and then pass that data structure to a
function:</p>
<pre class="literal-block">
def fancy(obj):
    print 'fancy fancy -- %s -- fancy fancy' % (obj, )

def plain(obj):
    print 'plain -- %s -- plain' % (obj, )

Func_list = [fancy, plain, ]

def show(funcs, obj):
    for func in funcs:
        func(obj)

def main():
    a = {'aa': 11, 'bb': 22, }
    show(Func_list, a)

if __name__ == '__main__':
    main()
</pre>
</li>
</ol>
<p>Notice that Python supports polymorphism (with or) without
inheritance.  This type of polymorphism is enabled by what is called
duck-typing.  For more on this see:
<a class="reference external" href="http://en.wikipedia.org/wiki/Duck_typing">Duck typing --
http://en.wikipedia.org/wiki/Duck_typing</a>
at Wikipedia.</p>
</div>
<div class="section" id="recursive-functions">
<h3><a class="toc-backref" href="#id214">3.6.5&nbsp;&nbsp;&nbsp;Recursive functions</a></h3>
<p>A recursive function is a function that calls itself.</p>
<p>A recursive function must have a limiting condition, or else it will
loop endlessly.</p>
<p>Each recursive call consumes space on the function call stack.
Therefore, the number of recursions must have some reasonable upper
bound.</p>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Write a recursive function that prints information about each
node in the following tree-structure data structure:</p>
<pre class="literal-block">
Tree = {
    'name': 'animals',
    'left_branch': {
        'name': 'birds',
        'left_branch': {
            'name': 'seed eaters',
            'left_branch': {
                'name': 'house finch',
                'left_branch': None,
                'right_branch': None,
            },
            'right_branch': {
                'name': 'white crowned sparrow',
                'left_branch': None,
                'right_branch': None,
            },
        },
        'right_branch': {
            'name': 'insect eaters',
            'left_branch': {
                'name': 'hermit thrush',
                'left_branch': None,
                'right_branch': None,
            },
            'right_branch': {
                'name': 'black headed phoebe',
                'left_branch': None,
                'right_branch': None,
            },
        },
    },
    'right_branch': None,
}
</pre>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We write a recursive function to walk the whole tree.  The
recursive function calls itself to process each child of a node
in the tree:</p>
<pre class="literal-block">
Tree = {
    'name': 'animals',
    'left_branch': {
        'name': 'birds',
        'left_branch': {
            'name': 'seed eaters',
            'left_branch': {
                'name': 'house finch',
                'left_branch': None,
                'right_branch': None,
            },
            'right_branch': {
                'name': 'white crowned sparrow',
                'left_branch': None,
                'right_branch': None,
            },
        },
        'right_branch': {
            'name': 'insect eaters',
            'left_branch': {
                'name': 'hermit thrush',
                'left_branch': None,
                'right_branch': None,
            },
            'right_branch': {
                'name': 'black headed phoebe',
                'left_branch': None,
                'right_branch': None,
            },
        },
    },
    'right_branch': None,
}

Indents = ['    ' * idx for idx in range(10)]

def walk_and_show(node, level=0):
    if node is None:
        return
    print '%sname: %s' % (Indents[level], node['name'], )
    level += 1
    walk_and_show(node['left_branch'], level)
    walk_and_show(node['right_branch'], level)

def test():
    walk_and_show(Tree)

if __name__ == '__main__':
    test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>Later, you will learn how to create equivalent data structures
using classes and OOP (object-oriented programming).  For more
on that see <a class="reference internal" href="#recursive-calls-to-methods">Recursive calls to methods</a> in this document.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="generators-and-iterators">
<h3><a class="toc-backref" href="#id215">3.6.6&nbsp;&nbsp;&nbsp;Generators and iterators</a></h3>
<p>The &quot;iterator protocol&quot; defines what an iterator object must do in
order to be usable in an &quot;iterator context&quot; such as a <tt class="docutils literal">for</tt>
statement.  The iterator protocol is described in the standard
library reference: <a class="reference external" href="http://docs.python.org/lib/typeiter.html">Iterator Types --
http://docs.python.org/lib/typeiter.html</a></p>
<p>An easy way to define an object that obeys the iterator protocol is
to write a generator function.  A generator function is a function
that contains one or more <tt class="docutils literal">yield</tt> statements.  If a function
contains at least one <tt class="docutils literal">yield</tt> statement, then that function when
called, returns generator iterator, which is an object that obeys
the iterator protocol, i.e. it's an iterator object.</p>
<p>Note that in recent versions of Python, yield is an expression.
This enables the consumer to communicate back with the producer
(the generator iterator).  For more on this, see
<a class="reference external" href="http://www.python.org/dev/peps/pep-0342/">PEP: 342 Coroutines via Enhanced Generators -
http://www.python.org/dev/peps/pep-0342/</a>.</p>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Implement a generator function -- The generator produced
should <tt class="docutils literal">yield</tt> all values from a list/iterable that satisfy a
predicate.  It should apply the transforms before return each
value.  The function takes these arguments:</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal">values</tt> -- A list of values.  Actually, it could be any
iterable.</p>
</li>
<li><p class="first"><tt class="docutils literal">predicate</tt> -- A function that takes a single argument,
performs a test on that value, and returns True or False.</p>
</li>
<li><p class="first"><tt class="docutils literal">transforms</tt> -- (optional) A list of functions.  Apply each
function in this list and returns the resulting value.  So,
for example, if the function is called like this:</p>
<pre class="literal-block">
result = transforms([11, 22], p, [f, g])
</pre>
<p>then the resulting generator might return:</p>
<pre class="literal-block">
g(f(11))
</pre>
</li>
</ol>
</li>
<li><p class="first">Implement a generator function that takes a list of URLs as its
argument and generates the contents of each Web page, one by one
(that is, it produces a sequence of strings, the HTML page
contents).</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Here is the implementation of a function which contains
<tt class="docutils literal">yield</tt>, and, therefore, produces a generator:</p>
<pre class="literal-block">
#!/usr/bin/env python
&quot;&quot;&quot;
filter_and_transform

filter_and_transform(content, test_func, transforms=None)

Return a generator that returns items from content after applying
the functions in transforms if the item satisfies test_func .

Arguments:

   1. ``values`` -- A list of values

   2. ``predicate`` -- A function that takes a single argument,
      performs a test on that value, and returns True or False.

   3. ``transforms`` -- (optional) A list of functions.  Apply each
      function in this list and returns the resulting value.  So,
      for example, if the function is called like this::

       result = filter_and_transforms([11, 22], p, [f, g])

      then the resulting generator might return::

          g(f(11))
&quot;&quot;&quot;

def filter_and_transform(content, test_func, transforms=None):
    for x in content:
        if test_func(x):
            if transforms is None:
                yield x
            elif isiterable(transforms):
                for func in transforms:
                    x = func(x)
                yield x
            else:
                yield transforms(x)

def isiterable(x):
    flag = True
    try:
        x = iter(x)
    except TypeError, exp:
        flag = False
    return flag

def iseven(n):
    return n % 2 == 0

def f(n):
    return n * 2

def g(n):
    return n ** 2

def test():
    data1 = [11, 22, 33, 44, 55, 66, 77, ]
    for val in filter_and_transform(data1, iseven, f):
        print 'val: %d' % (val, )
    print '-' * 40
    for val in filter_and_transform(data1, iseven, [f, g]):
        print 'val: %d' % (val, )
    print '-' * 40
    for val in filter_and_transform(data1, iseven):
        print 'val: %d' % (val, )

if __name__ == '__main__':
    test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>Because function <tt class="docutils literal">filter_and_transform</tt> contains <tt class="docutils literal">yield</tt>,
when called, it returns an iterator object, which we can use
in a <tt class="docutils literal">for</tt> statement.</li>
<li>The second parameter of function
<tt class="docutils literal">filter_and_transform</tt> takes any function which takes a
single argument and returns True or False.  This is an example
of polymorphism and &quot;duck typing&quot; (see
<a class="reference external" href="http://en.wikipedia.org/wiki/Duck_typing">Duck Typing --
http://en.wikipedia.org/wiki/Duck_typing</a>).
An analogous claim can be made about the third parameter.</li>
</ul>
</li>
<li><p class="first">The following function uses the <tt class="docutils literal">urllib</tt> module and the
<tt class="docutils literal">yield</tt> function to generate the contents of a sequence of Web
pages:</p>
<pre class="literal-block">
import urllib

Urls = [
    'http://yahoo.com',
    'http://python.org',
    'http://gimp.org',    # The GNU image manipulation program
    ]

def walk(url_list):
    for url in url_list:
        f = urllib.urlopen(url)
        stuff = f.read()
        f.close()
        yield stuff

def test():
    for x in walk(Urls):
        print 'length: %d' % (len(x), )

if __name__ == '__main__':
    test()
</pre>
<p>When I run this, I see:</p>
<pre class="literal-block">
$ python generator_example.py
length: 9554
length: 16748
length: 11487
</pre>
</li>
</ol>
</div>
</div>
<div class="section" id="object-oriented-programming-and-classes">
<h2><a class="toc-backref" href="#id216">3.7&nbsp;&nbsp;&nbsp;Object-oriented programming and classes</a></h2>
<p>Classes provide Python's way to define new data types and to do OOP
(object-oriented programming).</p>
<p>If you have made it this far, you have already <em>used</em> lots of
objects.  You have been a &quot;consumer&quot; of objects and their services.
Now, you will learn how to define and implement new <em>kinds</em> of
objects.  You will become a &quot;producer&quot; of objects.  You will define
new classes and you will implement the capabilities (methods) of
each new class.</p>
<p>A class is defined with the <tt class="docutils literal">class</tt> statement.  The first line of
a <tt class="docutils literal">class</tt> statement is a header (it has a colon at the end), and
it specifies the name of the class being defined and an (optional)
superclass.  And that header introduces a compound statement:
specifically, the body of the <tt class="docutils literal">class</tt> statement which contains
indented, nested statements, importantly, <tt class="docutils literal">def</tt> statements that
define the methods that can be called on instances of the objects
implemented by this class.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Define a class with one method <tt class="docutils literal">show</tt>.  That method should
print out &quot;Hello&quot;.  Then, create an instance of your class, and
call the <tt class="docutils literal">show</tt> method.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">A simple instance method can have the <tt class="docutils literal">self</tt> parameter and no
others:</p>
<pre class="literal-block">
class Demo(object):
    def show(self):
        print 'hello'

def test():
    a = Demo()
    a.show()

test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>Notice that we use <tt class="docutils literal">object</tt> as a superclass, because we want
to define an &quot;new-style&quot; class and because there is no other
class that we want as a superclass.  See the following for more
information on new-style classes:
<a class="reference external" href="http://www.python.org/doc/newstyle/">New-style Classes --
http://www.python.org/doc/newstyle/</a>.</li>
<li>In Python, we create an instance of a class by calling the
class, that is, we apply the function call operator
(parentheses) to the class.</li>
</ul>
</li>
</ol>
<div class="section" id="id23">
<h3><a class="toc-backref" href="#id217">3.7.1&nbsp;&nbsp;&nbsp;The constructor</a></h3>
<p>A class can define methods with special names.  You have seem some
of these before.  These names begin and end with a double
underscore.</p>
<p>One important special name is <tt class="docutils literal">__init__</tt>.  It's the constructor
for a class.  It is called each time an instance of the class is
created.  Implementing this method in a class gives us a chance to
initialize each instance of our class.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Implement a class named <tt class="docutils literal">Plant</tt> that has a constructor which
initializes two instance variables: <tt class="docutils literal">name</tt> and <tt class="docutils literal">size</tt>.  Also,
in this class, implement a method named <tt class="docutils literal">show</tt> that prints out
the values of these instance variables.  Create several instances
of your class and &quot;show&quot; them.</li>
<li>Implement a class name <tt class="docutils literal">Node</tt> that has two instance variables:
<tt class="docutils literal">data</tt> and <tt class="docutils literal">children</tt>, where <tt class="docutils literal">data</tt> is any, arbitrary
object and <tt class="docutils literal">children</tt> is a list of child Nodes.  Also implement a
method named <tt class="docutils literal">show</tt> that recursively displays the nodes in a
&quot;tree&quot;.  Create an instance of your class that contains several
child instances of your class.  Call the show method on the root
(top most) object to show the tree.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">The constructor for a class is a method with the special name
<tt class="docutils literal">__init__</tt>:</p>
<pre class="literal-block">
class Plant(object):
    def __init__(self, name, size):
        self.name = name
        self.size = size
    def show(self):
        print 'name: &quot;%s&quot;  size: %d' % (self.name, self.size, )

def test():
    p1 = Plant('Eggplant', 25)
    p2 = Plant('Tomato', 36)
    plants = [p1, p2, ]
    for plant in plants:
        plant.show()

test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>Our constructor takes two arguments: <tt class="docutils literal">name</tt> and <tt class="docutils literal">size</tt>.
It saves those two values as instance variables, that is in
attributes of the instance.</li>
<li>The <tt class="docutils literal">show()</tt> method prints out the value of those two
instance variables.</li>
</ul>
</li>
<li><p class="first">It is a good idea to initialize all instance variables in the
constructor.  That enables someone reading our code to learn
about all the instance variables of a class by looking in a
single location:</p>
<pre class="literal-block">
# simple_node.py

Indents = ['    ' * n for n in range(10)]

class Node(object):
    def __init__(self, name=None, children=None):
        self.name = name
        if children is None:
            self.children = []
        else:
            self.children = children
    def show_name(self, indent):
        print '%sname: &quot;%s&quot;' % (Indents[indent], self.name, )
    def show(self, indent=0):
        self.show_name(indent)
        indent += 1
        for child in self.children:
            child.show(indent)

def test():
    n1 = Node('N1')
    n2 = Node('N2')
    n3 = Node('N3')
    n4 = Node('N4')
    n5 = Node('N5', [n1, n2,])
    n6 = Node('N6', [n3, n4,])
    n7 = Node('N7', [n5, n6,])
    n7.show()

if __name__ == '__main__':
    test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>Notice that we do <strong>not</strong> use the constructor for a list
(<tt class="docutils literal">[]</tt>) as a default value for the <tt class="docutils literal">children</tt> parameter of
the constructor.  A list is mutable and would be created only
once (when the class statement is executed) and would be
shared.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="inheritance-implementing-a-subclass">
<h3><a class="toc-backref" href="#id218">3.7.2&nbsp;&nbsp;&nbsp;Inheritance -- Implementing a subclass</a></h3>
<p>A subclass extends or specializes a superclass by adding additional
methods to the superclass and by overriding methods (with the same
name) that already exist in the superclass.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Extend your <tt class="docutils literal">Node</tt> exercise above by adding two additional
subclasses of the Node class, one named <tt class="docutils literal">Plant</tt> and the other
named <tt class="docutils literal">Animal</tt>.  The <tt class="docutils literal">Plant</tt> class also has a <tt class="docutils literal">height</tt>
instance variable and the <tt class="docutils literal">Animal</tt> class also has a <tt class="docutils literal">color</tt>
instance variable.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can <tt class="docutils literal">import</tt> our previous <tt class="docutils literal">Node</tt> script, then implement
classes that have the <tt class="docutils literal">Node</tt> class as a superclass:</p>
<pre class="literal-block">
from simple_node import Node, Indents

class Plant(Node):
    def __init__(self, name, height=-1, children=None):
        Node.__init__(self, name, children)
        self.height = height
    def show(self, indent=0):
        self.show_name(indent)
        print '%sheight: %s' % (Indents[indent], self.height, )
        indent += 1
        for child in self.children:
            child.show(indent)

class Animal(Node):
    def __init__(self, name, color='no color', children=None):
        Node.__init__(self, name, children)
        self.color = color
    def show(self, indent=0):
        self.show_name(indent)
        print '%scolor: &quot;%s&quot;' % (Indents[indent], self.color, )
        indent += 1
        for child in self.children:
            child.show(indent)

def test():
    n1 = Animal('scrubjay', 'gray blue')
    n2 = Animal('raven', 'black')
    n3 = Animal('american kestrel', 'brown')
    n4 = Animal('red-shouldered hawk', 'brown and gray')
    n5 = Animal('corvid', 'none', [n1, n2,])
    n6 = Animal('raptor', children=[n3, n4,])
    n7a = Animal('bird', children=[n5, n6,])
    n1 = Plant('valley oak', 50)
    n2 = Plant('canyon live oak', 40)
    n3 = Plant('jeffery pine', 120)
    n4 = Plant('ponderosa pine', 140)
    n5 = Plant('oak', children=[n1, n2,])
    n6 = Plant('conifer', children=[n3, n4,])
    n7b = Plant('tree', children=[n5, n6,])
    n8 = Node('birds and trees', [n7a, n7b,])
    n8.show()

if __name__ == '__main__':
    test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The <tt class="docutils literal">show</tt> method in class <tt class="docutils literal">Plant</tt> calls the <tt class="docutils literal">show_name</tt>
method in its superclass using <tt class="docutils literal"><span class="pre">self.show_name(...)</span></tt>.  Python
searches up the inheritance tree to find the <tt class="docutils literal">show_name</tt>
method in class Node.</li>
<li>The constructor (<tt class="docutils literal">__init__</tt>) in classes <tt class="docutils literal">Plant</tt> and
<tt class="docutils literal">Animal</tt> each call the constructor in the superclass by using
the <em>name</em> of the superclass.  Why the difference?  Because, if
(in the Plant class, for example) it used
<tt class="docutils literal"><span class="pre">self.__init__(...)</span></tt> it would be calling the <tt class="docutils literal">__init__</tt> in
the <tt class="docutils literal">Plant</tt> class, itself.  So, it bypasses itself by
referencing the constructor in the superclass directly.</li>
<li>This exercise also demonstrates &quot;polymorphism&quot; -- The <tt class="docutils literal">show</tt>
method is called a number of times, but which implementation
executes depends on which instance it is called on.  Calling on
the show method on an instance of class <tt class="docutils literal">Plant</tt> results in a
call to <tt class="docutils literal">Plant.show</tt>.  Calling the show method on an instance
of class <tt class="docutils literal">Animal</tt> results in a call to <tt class="docutils literal">Animal.show</tt>.  And
so on.  It is important that each show method takes the correct
number of arguments.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="classes-and-polymorphism">
<h3><a class="toc-backref" href="#id219">3.7.3&nbsp;&nbsp;&nbsp;Classes and polymorphism</a></h3>
<p>Python also supports class-based polymorphism, which was, by the
way, demonstrated in the previous example.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Write three classes, each of which implement a <tt class="docutils literal">show()</tt> method
that takes one argument, a string.  The show method should print
out the name of the class and the message.  Then create a list of
instances and call the <tt class="docutils literal">show()</tt> method on each object in the
list.</li>
</ol>
<p>Solution:</p>
<ol class="arabic">
<li><p class="first">We implement three simple classes and then create a list of
instances of these classes:</p>
<pre class="literal-block">
class A(object):
    def show(self, msg):
        print 'class A -- msg: &quot;%s&quot;' % (msg, )

class B(object):
    def show(self, msg):
        print 'class B -- msg: &quot;%s&quot;' % (msg, )

class C(object):
    def show(self, msg):
        print 'class C -- msg: &quot;%s&quot;' % (msg, )

def test():
    objs = [A(), B(), C(), A(), ]
    for idx, obj in enumerate(objs):
        msg = 'message # %d' % (idx + 1, )
        obj.show(msg)

if __name__ == '__main__':
    test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>We can call the <tt class="docutils literal">show()</tt> method in any object in the list
<tt class="docutils literal">objs</tt> as long as we pass in a single parameter, that is, as
long as we obey the requirements of duck-typing.  We can do
this because all objects in that list implement a <tt class="docutils literal">show()</tt>
method.</li>
<li>In a statically typed language, that is a language where the
type is (also) present in the variable, all the instances in
example would have to descend from a common superclass and that
superclass would have to implement a <tt class="docutils literal">show()</tt> method.  Python
does not impose this restriction.  And, because variables are not
not typed in Python, perhaps that would not even possible.</li>
<li>Notice that this example of polymorphism works even though
these three classes (<tt class="docutils literal">A</tt>, <tt class="docutils literal">B</tt>, and <tt class="docutils literal">C</tt>) are not related
(for example, in a class hierarchy).  All that is required for
polymorphism to work in Python is for the method names to be
the same and the arguments to be compatible.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="recursive-calls-to-methods">
<h3><a class="toc-backref" href="#id220">3.7.4&nbsp;&nbsp;&nbsp;Recursive calls to methods</a></h3>
<p>A method in a class can recusively call itself.  This is very
similar to the way in which we implemented recursive functions --
see: <a class="reference internal" href="#recursive-functions">Recursive functions</a>.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Re-implement the binary tree of animals and birds described in
<a class="reference internal" href="#recursive-functions">Recursive functions</a>, but this time, use a class to represent
each node in the tree.</li>
<li>Solve the same problem, but this time implement a tree in which
each node can have any number of children (rather than exactly 2
children).</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We implement a class with three instance variables: (1) name, (2)
left branch, and (3) right branch.  Then, we implement a
<tt class="docutils literal">show()</tt> method that displays the name and calls itself to show
the children in each sub-tree:</p>
<pre class="literal-block">
Indents = ['    ' * idx for idx in range(10)]

class AnimalNode(object):

    def __init__(self, name, left_branch=None, right_branch=None):
        self.name = name
        self.left_branch = left_branch
        self.right_branch = right_branch

    def show(self, level=0):
        print '%sname: %s' % (Indents[level], self.name, )
        level += 1
        if self.left_branch is not None:
            self.left_branch.show(level)
        if self.right_branch is not None:
            self.right_branch.show(level)

Tree = AnimalNode('animals',
    AnimalNode('birds',
        AnimalNode('seed eaters',
            AnimalNode('house finch'),
            AnimalNode('white crowned sparrow'),
        ),
        AnimalNode('insect eaters',
            AnimalNode('hermit thrush'),
            AnimalNode('black headed phoebe'),
        ),
    ),
    None,
)

def test():
    Tree.show()

if __name__ == '__main__':
    test()
</pre>
</li>
<li><p class="first">Instead of using a left branch and a right branch, in this
solution we use a list to represent the children of a node:</p>
<pre class="literal-block">
class AnimalNode(object):
    def __init__(self, data, children=None):
        self.data = data
        if children is None:
            self.children = []
        else:
            self.children = children

    def show(self, level=''):
        print '%sdata: %s' % (level, self.data, )
        level += '    '
        for child in self.children:
            child.show(level)

Tree = AnimalNode('animals', [
    AnimalNode('birds', [
        AnimalNode('seed eaters', [
            AnimalNode('house finch'),
            AnimalNode('white crowned sparrow'),
            AnimalNode('lesser gold finch'),
        ]),
        AnimalNode('insect eaters', [
            AnimalNode('hermit thrush'),
            AnimalNode('black headed phoebe'),
        ]),
    ])
])

def test():
    Tree.show()

if __name__ == '__main__':
    test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>We represent the children of a node as a list.  Each node
&quot;has-a&quot; list of children.</li>
<li>Notice that because a list is mutable, we do not use a list
constructor (<tt class="docutils literal">[]</tt>) in the initializer of the method header.
Instead, we use None, then construct an empty list in the body
of the method if necessary.  See section <a class="reference internal" href="#optional-arguments-and-default-values">Optional arguments
and default values</a> for more on this.</li>
<li>We (recursively) call the show method for each node in the
<tt class="docutils literal">children</tt> list.  Since a node which has no children (a leaf
node) will have an empty <tt class="docutils literal">children</tt> list, this provides a
limit condition for our recursion.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="class-variables-class-methods-and-static-methods">
<h3><a class="toc-backref" href="#id221">3.7.5&nbsp;&nbsp;&nbsp;Class variables, class methods, and static methods</a></h3>
<p>A class variable is one whose single value is shared by all
instances of the class and, in fact, is shared by all who have
access to the class (object).</p>
<p>&quot;Normal&quot; methods are instance methods.  An instance method receives
the instance as its first argument.  A instance method is defined by
using the <tt class="docutils literal">def</tt> statement in the body of a <tt class="docutils literal">class</tt> statement.</p>
<p>A class method receives the class as its first argument.  A class
method is defined by defining a normal/instance method, then using
the <tt class="docutils literal">classmethod</tt> built-in function.  For example:</p>
<pre class="literal-block">
class ASimpleClass(object):
    description = 'a simple class'
    def show_class(cls, msg):
        print '%s: %s' % (cls.description , msg, )
        show_class = classmethod(show_class)
</pre>
<p>A static method does <em>not</em> receive anything special as its first
argument.  A static method is defined by defining a normal/instance
method, then using the <tt class="docutils literal">staticmethod</tt> built-in function.  For
example:</p>
<pre class="literal-block">
class ASimpleClass(object):
    description = 'a simple class'
    def show_class(msg):
        print '%s: %s' % (ASimpleClass.description , msg, )
        show_class = staticmethod(show_class)
</pre>
<p>In effect, both class methods and static methods are defined by
creating a normal (instance) method, then creating a wrapper object
(a class method or static method) using the <tt class="docutils literal">classmethod</tt> or
<tt class="docutils literal">staticmethod</tt> built-in function.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Implement a class that keeps a running total of the number of
instances created.</li>
<li>Implement another solution to the same problem (a class that
keeps a running total of the number of instances), but this time
use a static method instead of a class method.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We use a class variable named <tt class="docutils literal">instance_count</tt>, rather than an
instance variable, to keep a running total of instances.  Then,
we increment that variable each time an instance is created:</p>
<pre class="literal-block">
class CountInstances(object):

    instance_count = 0

    def __init__(self, name='-no name-'):
        self.name = name
        CountInstances.instance_count += 1

    def show(self):
        print 'name: &quot;%s&quot;' % (self.name, )

    def show_instance_count(cls):
        print 'instance count: %d' % (cls.instance_count, )
    show_instance_count = classmethod(show_instance_count)


def test():
    instances = []
    instances.append(CountInstances('apple'))
    instances.append(CountInstances('banana'))
    instances.append(CountInstances('cherry'))
    instances.append(CountInstances())
    for instance in instances:
        instance.show()
    CountInstances.show_instance_count()


if __name__ == '__main__':
    test()
</pre>
<p>Notes:</p>
<ul>
<li><p class="first">When we run this script, it prints out the following:</p>
<pre class="literal-block">
name: &quot;apple&quot;
name: &quot;banana&quot;
name: &quot;cherry&quot;
name: &quot;-no name-&quot;
instance count: 4
</pre>
</li>
<li><p class="first">The call to the <tt class="docutils literal">classmethod</tt> built-in function effectively
wraps the <tt class="docutils literal">show_instance_count</tt> method in a class method,
that is, in a method that takes a class object as its first
argument rather than an instance object.  To read more
about <tt class="docutils literal">classmethod</tt>, go to
<a class="reference external" href="http://docs.python.org/lib/built-in-funcs.html">Built-in Functions --
http://docs.python.org/lib/built-in-funcs.html</a>
and search for &quot;classmethod&quot;.</p>
</li>
</ul>
</li>
<li><p class="first">A static method takes neither an instance (<tt class="docutils literal">self</tt>) nor a class
as its first paramenter.  And,  static method is created with the
<tt class="docutils literal">staticmethod()</tt> built-in function (rather than with the
<tt class="docutils literal">classmethod()</tt> built-in):</p>
<pre class="literal-block">
class CountInstances(object):

    instance_count = 0

    def __init__(self, name='-no name-'):
        self.name = name
        CountInstances.instance_count += 1

    def show(self):
        print 'name: &quot;%s&quot;' % (self.name, )

    def show_instance_count():
        print 'instance count: %d' % (
            CountInstances.instance_count, )
    show_instance_count = staticmethod(show_instance_count)

def test():
    instances = []
    instances.append(CountInstances('apple'))
    instances.append(CountInstances('banana'))
    instances.append(CountInstances('cherry'))
    instances.append(CountInstances())
    for instance in instances:
        instance.show()
    CountInstances.show_instance_count()

if __name__ == '__main__':
    test()
</pre>
</li>
</ol>
<div class="section" id="decorators-for-classmethod-and-staticmethod">
<h4><a class="toc-backref" href="#id222">3.7.5.1&nbsp;&nbsp;&nbsp;Decorators for classmethod and staticmethod</a></h4>
<p>A decorator enables us to do what we did in the previous example
with a somewhat simpler syntax.</p>
<p>For simple cases, the decorator syntax enables us to do this:</p>
<pre class="literal-block">
&#64;functionwrapper
def method1(self):
    o
    o
    o
</pre>
<p>instead of this:</p>
<pre class="literal-block">
def method1(self):
    o
    o
    o
method1 = functionwrapper(method1)
</pre>
<p>So, we can write this:</p>
<pre class="literal-block">
&#64;classmethod
def method1(self):
    o
    o
    o
</pre>
<p>instead of this:</p>
<pre class="literal-block">
def method1(self):
    o
    o
    o
method1 = classmethod(method1)
</pre>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Implement the <tt class="docutils literal">CountInstances</tt> example above, but use a
decorator rather than the explicit call to <tt class="docutils literal">classmethod</tt>.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">A decorator is an easier and cleaner way to define a class method
(or a static method):</p>
<pre class="literal-block">
class CountInstances(object):

    instance_count = 0

    def __init__(self, name='-no name-'):
        self.name = name
        CountInstances.instance_count += 1

    def show(self):
        print 'name: &quot;%s&quot;' % (self.name, )

    &#64;classmethod
    def show_instance_count(cls):
        print 'instance count: %d' % (cls.instance_count, )
    # Note that the following line has been replaced by
    #   the classmethod decorator, above.
    # show_instance_count = classmethod(show_instance_count)

def test():
    instances = []
    instances.append(CountInstances('apple'))
    instances.append(CountInstances('banana'))
    instances.append(CountInstances('cherry'))
    instances.append(CountInstances())
    for instance in instances:
        instance.show()
    CountInstances.show_instance_count()

if __name__ == '__main__':
    test()
</pre>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="additional-and-advanced-topics">
<h2><a class="toc-backref" href="#id223">3.8&nbsp;&nbsp;&nbsp;Additional and Advanced Topics</a></h2>
<div class="section" id="decorators-and-how-to-implement-them">
<h3><a class="toc-backref" href="#id224">3.8.1&nbsp;&nbsp;&nbsp;Decorators and how to implement them</a></h3>
<p>Decorators can be used to &quot;wrap&quot; a function with another function.</p>
<p>When implementing a decorator, it is helpful to remember that the
following decorator application:</p>
<pre class="literal-block">
&#64;dec
def func(arg1, arg2):
    pass
</pre>
<p>is equivalent to:</p>
<pre class="literal-block">
def func(arg1, arg2):
    pass
func = dec(func)
</pre>
<p>Therefore, to implement a decorator, we write a function that
returns a function object, since we replace the value originally
bound to the function with this new function object.  It may be
helpful to take the view that we are creating a function that is a
<em>wrapper</em> for the original function.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Write a decorator that writes a message before and after
executing a function.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">A function that contains and returns an inner function can be
used to wrap a function:</p>
<pre class="literal-block">
def trace(func):
    def inner(*args, **kwargs):
        print '&gt;&gt;'
        func(*args, **kwargs)
        print '&lt;&lt;'
    return inner

&#64;trace
def func1(x, y):
    print 'x:', x, 'y:', y
    func2((x, y))

&#64;trace
def func2(content):
    print 'content:', content

def test():
    func1('aa', 'bb')

test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>Your inner function can use <tt class="docutils literal">*args</tt> and <tt class="docutils literal">**kwargs</tt> to
enable it to call functions with any number of arguments.</li>
</ul>
</li>
</ol>
<div class="section" id="decorators-with-arguments">
<h4><a class="toc-backref" href="#id225">3.8.1.1&nbsp;&nbsp;&nbsp;Decorators with arguments</a></h4>
<p>Decorators can also take arguments.</p>
<p>The following decorator with arguments:</p>
<pre class="literal-block">
&#64;dec(argA, argB)
def func(arg1, arg2):
    pass
</pre>
<p>is equivalent to:</p>
<pre class="literal-block">
def func(arg1, arg2):
    pass
func = dec(argA, argB)(func)
</pre>
<p>Because the decorator's arguments are passed to the result of
calling the decorator on the decorated function, you may find it
useful to implement a decorator with arguments using a function
inside a function inside a function.</p>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Write and test a decorator that takes one argument.  The
decorator prints a message along with the value of the argument
before and after entering the decorated function.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Implement this decorator that takes arguments with a function
containing a nested function which in turn contains a nested
function:</p>
<pre class="literal-block">
def trace(msg):
    def inner1(func):
        def inner2(*args, **kwargs):
            print '&gt;&gt; [%s]' % (msg, )
            retval = func(*args, **kwargs)
            print '&lt;&lt; [%s]' % (msg, )
            return retval
        return inner2
    return inner1

&#64;trace('tracing func1')
def func1(x, y):
    print 'x:', x, 'y:', y
    result = func2((x, y))
    return result

&#64;trace('tracing func2')
def func2(content):
    print 'content:', content
    return content * 3

def test():
    result = func1('aa', 'bb')
    print 'result:', result

test()
</pre>
</li>
</ol>
</div>
<div class="section" id="stacked-decorators">
<h4><a class="toc-backref" href="#id226">3.8.1.2&nbsp;&nbsp;&nbsp;Stacked decorators</a></h4>
<p>Decorators can be &quot;stacked&quot;.</p>
<p>The following stacked decorators:</p>
<pre class="literal-block">
&#64;dec2
&#64;dec1
def func(arg1, arg2, ...):
    pass
</pre>
<p>are equivalent to:</p>
<pre class="literal-block">
def func(arg1, arg2, ...):
    pass
func = dec2(dec1(func))
</pre>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Implement a decorator (as above) that traces calls to a
decorated function.  Then &quot;stack&quot; that with another decorator
that prints a horizontal line of dashes before and after calling
the function.</li>
<li>Modify your solution to the above exercise so that the decorator
that prints the horizontal line takes one argument: a character
(or characters) that can be repeated to produce a horizontal
line/separator.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Reuse your tracing function from the previous exercise, then
write a simple decorator that prints a row of dashes:</p>
<pre class="literal-block">
def trace(msg):
    def inner1(func):
        def inner2(*args, **kwargs):
            print '&gt;&gt; [%s]' % (msg, )
            retval = func(*args, **kwargs)
            print '&lt;&lt; [%s]' % (msg, )
            return retval
        return inner2
    return inner1

def horizontal_line(func):
    def inner(*args, **kwargs):
        print '-' * 50
        retval = func(*args, **kwargs)
        print '-' * 50
        return retval
    return inner


&#64;trace('tracing func1')
def func1(x, y):
    print 'x:', x, 'y:', y
    result = func2((x, y))
    return result

&#64;horizontal_line
&#64;trace('tracing func2')
def func2(content):
    print 'content:', content
    return content * 3

def test():
    result = func1('aa', 'bb')
    print 'result:', result

test()
</pre>
</li>
<li><p class="first">Once again, a decorator with arguments can be implemented with a
function nested inside a function which is nested inside a
function.  This remains the same whether the decorator is used
as a <em>stacked</em> decorator or not.  Here is a solution:</p>
<pre class="literal-block">
def trace(msg):
    def inner1(func):
        def inner2(*args, **kwargs):
            print '&gt;&gt; [%s]' % (msg, )
            retval = func(*args, **kwargs)
            print '&lt;&lt; [%s]' % (msg, )
            return retval
        return inner2
    return inner1

def horizontal_line(line_chr):
    def inner1(func):
        def inner2(*args, **kwargs):
            print line_chr * 15
            retval = func(*args, **kwargs)
            print line_chr * 15
            return retval
        return inner2
    return inner1

&#64;trace('tracing func1')
def func1(x, y):
    print 'x:', x, 'y:', y
    result = func2((x, y))
    return result

&#64;horizontal_line('&lt;**&gt;')
&#64;trace('tracing func2')
def func2(content):
    print 'content:', content
    return content * 3

def test():
    result = func1('aa', 'bb')
    print 'result:', result

test()
</pre>
</li>
</ol>
</div>
<div class="section" id="more-help-with-decorators">
<h4><a class="toc-backref" href="#id227">3.8.1.3&nbsp;&nbsp;&nbsp;More help with decorators</a></h4>
<p>There is more about decorators here:</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators">Python syntax and semantics --
http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators</a>
at Wikipedia.</li>
<li><a class="reference external" href="http://wiki.python.org/moin/PythonDecoratorLibrary">PythonDecoratorLibrary --
http://wiki.python.org/moin/PythonDecoratorLibrary</a>
at the Python Wiki has lots of sample code.</li>
<li><a class="reference external" href="http://www.python.org/dev/peps/pep-0318/">PEP 318 -- Decorators for Functions and Methods --
http://www.python.org/dev/peps/pep-0318/</a>
is the formal proposal and specification for Python decorators.</li>
</ul>
</div>
</div>
<div class="section" id="iterables">
<h3><a class="toc-backref" href="#id228">3.8.2&nbsp;&nbsp;&nbsp;Iterables</a></h3>
<div class="section" id="a-few-preliminaries-on-iterables">
<h4><a class="toc-backref" href="#id229">3.8.2.1&nbsp;&nbsp;&nbsp;A few preliminaries on Iterables</a></h4>
<p>Definition: iterable (adjective) -- that which can be iterated
over.</p>
<p>A good test of whether something is iterable is whether it can be
used in a <tt class="docutils literal">for:</tt> statement.  For example, if we can write <tt class="docutils literal">for item in
X:</tt>, then <tt class="docutils literal">X</tt> is iterable.  Here is another simple test:</p>
<pre class="literal-block">
def isiterable(x):
    try:
        y = iter(x)
    except TypeError, exp:
        return False
    return True
</pre>
<p>Some kinds of iterables:</p>
<ul class="simple">
<li>Containers -- We can iterate over lists, tuples, dictionaries,
sets, strings, and other containers.</li>
<li>Some built-in (non-container) types -- Examples:<ul>
<li>A text file open in read mode is iterable: it iterates over the
lines in the file.</li>
<li>The xrange type -- See <a class="reference external" href="http://docs.python.org/lib/typesseq-xrange.html">XRange Type
http://docs.python.org/lib/typesseq-xrange.html</a>.
It's useful when you want a large sequence of integers to
iterate over.</li>
</ul>
</li>
<li>Instances of classes that obey the iterator protocol.  For a
description of the iterator protocol, see <a class="reference external" href="http://docs.python.org/lib/typeiter.html">Iterator Types --
http://docs.python.org/lib/typeiter.html</a>.  Hint: Type
<tt class="docutils literal">dir(obj)</tt> and look for &quot;__iter__&quot; and &quot;next&quot;.</li>
<li>Generators -- An object returned by any function or method that
contains <tt class="docutils literal">yield</tt>.</li>
</ul>
<p>Exercises:</p>
<ol class="arabic simple">
<li>Implement a class whose instances are interable.  The
constructor takes a list of URLs as its argument.  An instance of
this class, when iterated over, generates the content of the Web
page at that address.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We implement a class that has <tt class="docutils literal">__iter__()</tt> and <tt class="docutils literal">next()</tt>
methods:</p>
<pre class="literal-block">
import urllib

class WebPages(object):
    def __init__(self, urls):
        self.urls = urls
        self.current_index = 0
    def __iter__(self):
        self.current_index = 0
        return self
    def next(self):
        if self.current_index &gt;= len(self.urls):
            raise StopIteration
        url = self.urls[self.current_index]
        self.current_index += 1
        f = urllib.urlopen(url)
        content = f.read()
        f.close()
        return content

def test():
    urls = [
        'http://www.python.org',
        'http://en.wikipedia.org/',
        'http://en.wikipedia.org/wiki/Python_(programming_language)',
        ]
    pages = WebPages(urls)
    for page in pages:
        print 'length: %d' % (len(page), )
    pages = WebPages(urls)
    print '-' * 50
    page = pages.next()
    print 'length: %d' % (len(page), )
    page = pages.next()
    print 'length: %d' % (len(page), )
    page = pages.next()
    print 'length: %d' % (len(page), )
    page = pages.next()
    print 'length: %d' % (len(page), )

test()
</pre>
</li>
</ol>
</div>
<div class="section" id="more-help-with-iterables">
<h4><a class="toc-backref" href="#id230">3.8.2.2&nbsp;&nbsp;&nbsp;More help with iterables</a></h4>
<p>The <tt class="docutils literal">itertools</tt> module in the Python standard library has helpers
for iterators:
<a class="reference external" href="http://docs.python.org/library/itertools.html#module-itertools">http://docs.python.org/library/itertools.html#module-itertools</a></p>
</div>
</div>
</div>
<div class="section" id="applications-and-recipes">
<h2><a class="toc-backref" href="#id231">3.9&nbsp;&nbsp;&nbsp;Applications and Recipes</a></h2>
<div class="section" id="xml-sax-minidom-elementtree-lxml">
<h3><a class="toc-backref" href="#id232">3.9.1&nbsp;&nbsp;&nbsp;XML -- SAX, minidom, ElementTree, Lxml</a></h3>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">SAX -- Parse an XML document with SAX, then show some information (tag,
attributes, character data) for each element.</p>
</li>
<li><p class="first">Minidom -- Parse an XML document with <tt class="docutils literal">minidom</tt>, then walk the DOM tree
and show some information (tag, attributes, character data) for
each element.</p>
<p>Here is a sample XML document that you can use for input:</p>
<pre class="literal-block">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;people&gt;
    &lt;person id=&quot;1&quot; value=&quot;abcd&quot; ratio=&quot;3.2&quot;&gt;
        &lt;name&gt;Alberta&lt;/name&gt;
        &lt;interest&gt;gardening&lt;/interest&gt;
        &lt;interest&gt;reading&lt;/interest&gt;
        &lt;category&gt;5&lt;/category&gt;
    &lt;/person&gt;
    &lt;person id=&quot;2&quot;&gt;
        &lt;name&gt;Bernardo&lt;/name&gt;
        &lt;interest&gt;programming&lt;/interest&gt;
        &lt;category&gt;&lt;/category&gt;
        &lt;agent&gt;
            &lt;firstname&gt;Darren&lt;/firstname&gt;
            &lt;lastname&gt;Diddly&lt;/lastname&gt;
        &lt;/agent&gt;
    &lt;/person&gt;
    &lt;person id=&quot;3&quot; value=&quot;efgh&quot;&gt;
        &lt;name&gt;Charlie&lt;/name&gt;
        &lt;interest&gt;people&lt;/interest&gt;
        &lt;interest&gt;cats&lt;/interest&gt;
        &lt;interest&gt;dogs&lt;/interest&gt;
        &lt;category&gt;8&lt;/category&gt;
        &lt;promoter&gt;
            &lt;firstname&gt;David&lt;/firstname&gt;
            &lt;lastname&gt;Donaldson&lt;/lastname&gt;
            &lt;client&gt;
                &lt;fullname&gt;Arnold Applebee&lt;/fullname&gt;
                &lt;refid&gt;10001&lt;/refid&gt;
            &lt;/client&gt;
        &lt;/promoter&gt;
        &lt;promoter&gt;
            &lt;firstname&gt;Edward&lt;/firstname&gt;
            &lt;lastname&gt;Eddleberry&lt;/lastname&gt;
            &lt;client&gt;
                &lt;fullname&gt;Arnold Applebee&lt;/fullname&gt;
                &lt;refid&gt;10001&lt;/refid&gt;
            &lt;/client&gt;
        &lt;/promoter&gt;
    &lt;/person&gt;
&lt;/people&gt;
</pre>
</li>
<li><p class="first"><a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a> -- Parse an XML document with <a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a>, then
walk the DOM tree and show some information (tag, attributes,
character data) for each element.</p>
</li>
<li><p class="first"><a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a> -- Parse an XML document with <a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a>, then walk the DOM
tree and show some information (tag, attributes, character data)
for each element.</p>
</li>
<li><p class="first">Modify document with <a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a> -- Use <a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a> to read
a document, then modify the tree.  Show the contents of the tree,
and then write out the modified document.</p>
</li>
<li><p class="first"><a class="reference external" href="http://www.w3.org/TR/xpath">XPath</a> -- <a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a> supports XPath.  Use the XPath support in <a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a> to
address each of the following in the above XML instance document:</p>
<ul class="simple">
<li>The text in all the <tt class="docutils literal">name</tt> elements</li>
<li>The values of all the <tt class="docutils literal">id</tt> attributes</li>
</ul>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can use the SAX support in the Python standard library:</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;
Parse and XML with SAX.  Display info about each element.

Usage:
    python test_sax.py infilename
Examples:
    python test_sax.py people.xml
&quot;&quot;&quot;

import sys
from xml.sax import make_parser, handler

class TestHandler(handler.ContentHandler):
    def __init__(self):
        self.level = 0

    def show_with_level(self, value):
        print '%s%s' % ('    ' * self.level, value, )

    def startDocument(self):
        self.show_with_level('Document start')
        self.level += 1

    def endDocument(self):
        self.level -= 1
        self.show_with_level('Document end')

    def startElement(self, name, attrs):
        self.show_with_level('start element -- name: &quot;%s&quot;' % (name, ))
        self.level += 1

    def endElement(self, name):
        self.level -= 1
        self.show_with_level('end element -- name: &quot;%s&quot;' % (name, ))

    def characters(self, content):
        content = content.strip()
        if content:
            self.show_with_level('characters: &quot;%s&quot;' % (content, ))

def test(infilename):
    parser = make_parser()
    handler = TestHandler()
    parser.setContentHandler(handler)
    parser.parse(infilename)

def usage():
    print __doc__
    sys.exit(1)

def main():
    args = sys.argv[1:]
    if len(args) != 1:
        usage()
    infilename = args[0]
    test(infilename)

if __name__ == '__main__':
    main()
</pre>
</li>
<li><p class="first">The minidom module contains a <tt class="docutils literal">parse()</tt> function that enables
us to read an XML document and create a DOM tree:</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;Process an XML document with minidom.

Show the document tree.

Usage:
    python minidom_walk.py [options] infilename
&quot;&quot;&quot;

import sys
from xml.dom import minidom

def show_tree(doc):
    root = doc.documentElement
    show_node(root, 0)

def show_node(node, level):
    count = 0
    if node.nodeType == minidom.Node.ELEMENT_NODE:
        show_level(level)
        print 'tag: %s' % (node.nodeName, )
        for key in node.attributes.keys():
            attr = node.attributes.get(key)
            show_level(level + 1)
            print '- attribute name: %s  value: &quot;%s&quot;' % (attr.name,
                attr.value, )
        if (len(node.childNodes) == 1 and
            node.childNodes[0].nodeType == minidom.Node.TEXT_NODE):
            show_level(level + 1)
            print '- data: &quot;%s&quot;' % (node.childNodes[0].data, )
        for child in node.childNodes:
            count += 1
            show_node(child, level + 1)
    return count

def show_level(level):
    for x in range(level):
        print '   ',

def test():
    args = sys.argv[1:]
    if len(args) != 1:
        print __doc__
        sys.exit(1)
    docname = args[0]
    doc = minidom.parse(docname)
    show_tree(doc)

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    test()
</pre>
</li>
<li><p class="first"><a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a> enables us to parse an XML document and create a
DOM tree:</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;Process an XML document with elementtree.

Show the document tree.

Usage:
    python elementtree_walk.py [options] infilename
&quot;&quot;&quot;

import sys
from xml.etree import ElementTree as etree

def show_tree(doc):
    root = doc.getroot()
    show_node(root, 0)

def show_node(node, level):
    show_level(level)
    print 'tag: %s' % (node.tag, )
    for key, value in node.attrib.iteritems():
        show_level(level + 1)
        print '- attribute -- name: %s  value: &quot;%s&quot;' % (key, value, )
    if node.text:
        text = node.text.strip()
        show_level(level + 1)
        print '- text: &quot;%s&quot;' % (node.text, )
    if node.tail:
        tail = node.tail.strip()
        show_level(level + 1)
        print '- tail: &quot;%s&quot;' % (tail, )
    for child in node.getchildren():
        show_node(child, level + 1)

def show_level(level):
    for x in range(level):
        print '   ',

def test():
    args = sys.argv[1:]
    if len(args) != 1:
        print __doc__
        sys.exit(1)
    docname = args[0]
    doc = etree.parse(docname)
    show_tree(doc)

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    test()
</pre>
</li>
<li><p class="first"><a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a> enables us to parse an XML document and create a
DOM tree.  In fact, since <a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a> attempts to mimic the
<a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a> API, our code is very similar to that in the
solution to the <a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a> exercise:</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;Process an XML document with elementtree.

Show the document tree.

Usage:
    python lxml_walk.py [options] infilename
&quot;&quot;&quot;

#
# Imports:
import sys
from lxml import etree

def show_tree(doc):
    root = doc.getroot()
    show_node(root, 0)

def show_node(node, level):
    show_level(level)
    print 'tag: %s' % (node.tag, )
    for key, value in node.attrib.iteritems():
        show_level(level + 1)
        print '- attribute -- name: %s  value: &quot;%s&quot;' % (key, value, )
    if node.text:
        text = node.text.strip()
        show_level(level + 1)
        print '- text: &quot;%s&quot;' % (node.text, )
    if node.tail:
        tail = node.tail.strip()
        show_level(level + 1)
        print '- tail: &quot;%s&quot;' % (tail, )
    for child in node.getchildren():
        show_node(child, level + 1)

def show_level(level):
    for x in range(level):
        print '   ',

def test():
    args = sys.argv[1:]
    if len(args) != 1:
        print __doc__
        sys.exit(1)
    docname = args[0]
    doc = etree.parse(docname)
    show_tree(doc)

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    test()
</pre>
</li>
<li><p class="first">We can modify the DOM tree and write it out to a new file:</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;Process an XML document with elementtree.

Show the document tree.
Modify the document tree and then show it again.
Write the modified XML tree to a new file.

Usage:
    python elementtree_walk.py [options] infilename outfilename
Options:
    -h, --help      Display this help message.
Example:
    python elementtree_walk.py myxmldoc.xml myotherxmldoc.xml
&quot;&quot;&quot;

import sys
import os
import getopt
import time

# Use ElementTree.
from xml.etree import ElementTree as etree
# Or uncomment to use Lxml.
#from lxml import etree

def show_tree(doc):
    root = doc.getroot()
    show_node(root, 0)

def show_node(node, level):
    show_level(level)
    print 'tag: %s' % (node.tag, )
    for key, value in node.attrib.iteritems():
        show_level(level + 1)
        print '- attribute -- name: %s  value: &quot;%s&quot;' % (key, value, )
    if node.text:
        text = node.text.strip()
        show_level(level + 1)
        print '- text: &quot;%s&quot;' % (node.text, )
    if node.tail:
        tail = node.tail.strip()
        show_level(level + 1)
        print '- tail: &quot;%s&quot;' % (tail, )
    for child in node.getchildren():
        show_node(child, level + 1)

def show_level(level):
    for x in range(level):
        print '   ',

def modify_tree(doc, tag, attrname, attrvalue):
    root = doc.getroot()
    modify_node(root, tag, attrname, attrvalue)

def modify_node(node, tag, attrname, attrvalue):
    if node.tag == tag:
        node.attrib[attrname] = attrvalue
    for child in node.getchildren():
        modify_node(child, tag, attrname, attrvalue)

def test(indocname, outdocname):
    doc = etree.parse(indocname)
    show_tree(doc)
    print '-' * 50
    date = time.ctime()
    modify_tree(doc, 'person', 'date', date)
    show_tree(doc)
    write_output = False
    if os.path.exists(outdocname):
        response = raw_input('Output file (%s) exists.  Over-write? (y/n): ' %
            outdocname)
        if response == 'y':
            write_output = True
    else:
        write_output = True
    if write_output:
        doc.write(outdocname)
        print 'Wrote modified XML tree to %s' % outdocname
    else:
        print 'Did not write output file.'

def usage():
    print __doc__
    sys.exit(1)

def main():
    args = sys.argv[1:]
    try:
        opts, args = getopt.getopt(args, 'h', ['help',
            ])
    except:
        usage()
    for opt, val in opts:
        if opt in ('-h', '--help'):
            usage()
    if len(args) != 2:
        usage()
    indocname = args[0]
    outdocname = args[1]
    test(indocname, outdocname)

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The above solution contains an <tt class="docutils literal">import</tt> statement for
<a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a> and another for <a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a>.  The one for
<a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a> is commented out, but you could change that if you
wish to use <a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a> instead of <a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a>.  This
solution will work the same way with either <a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree</a> or
<a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a>.</li>
</ul>
</li>
<li><p class="first">When we parse and XML document with <a class="reference external" href="http://codespeak.net/lxml/index.html">lxml</a>, each element (node)
has an <tt class="docutils literal">xpath()</tt> method.</p>
<pre class="literal-block">
# test_xpath.py

from lxml import etree

def test():
    doc = etree.parse('people.xml')
    root = doc.getroot()
    print root.xpath(&quot;//name/text()&quot;)
    print root.xpath(&quot;//&#64;id&quot;)

test()
</pre>
<p>And, when we run the above code, here is what we see:</p>
<pre class="literal-block">
$ python test_xpath.py
['Alberta', 'Bernardo', 'Charlie']
['1', '2', '3']
</pre>
<p>For more on <a class="reference external" href="http://www.w3.org/TR/xpath">XPath</a> see:
<a class="reference external" href="http://www.w3.org/TR/xpath">XML Path Language (XPath) --
http://www.w3.org/TR/xpath</a></p>
</li>
</ol>
</div>
<div class="section" id="relational-database-access">
<h3><a class="toc-backref" href="#id233">3.9.2&nbsp;&nbsp;&nbsp;Relational database access</a></h3>
<p>You can find information about database programming in Python here:
<a class="reference external" href="http://wiki.python.org/moin/DatabaseProgramming/">Database Programming --
http://wiki.python.org/moin/DatabaseProgramming/</a>.</p>
<p>For database access we use the Python Database API.  You can find
information about it here:
<a class="reference external" href="http://www.python.org/dev/peps/pep-0249/">Python Database API Specification v2.0 --
http://www.python.org/dev/peps/pep-0249/</a>.</p>
<p>To use the database API we do the following:</p>
<ol class="arabic simple">
<li>Use the database interface module to create a connection object.</li>
<li>Use the connection object to create a cursor object.</li>
<li>Use the cursor object to execute an SQL query.</li>
<li>Retrieve rows from the cursor object, if needed.</li>
<li>Optionally, commit results to the database.</li>
<li>Close the connection object.</li>
</ol>
<p>Our examples use the <tt class="docutils literal">gadfly</tt> database, which is written in
Python.  If you want to use <tt class="docutils literal">gadfly</tt>, you can find it here:
<a class="reference external" href="http://gadfly.sourceforge.net/">http://gadfly.sourceforge.net/</a>.  <tt class="docutils literal">gadfly</tt> is a reasonable choice
if you want an easy to use database on your local machine.</p>
<p>Another reasonable choice for a local database is <tt class="docutils literal">sqlite3</tt>,
which is in the Python standard library.  Here is a descriptive
quote from the <tt class="docutils literal">SQLite</tt> Web site:</p>
<blockquote>
&quot;SQLite is a software library that implements a self-contained,
serverless, zero-configuration, transactional SQL database
engine.  SQLite is the most widely deployed SQL database engine
in the world.  The source code for SQLite is in the public
domain.&quot;</blockquote>
<p>You can learn about it here:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.python.org/library/sqlite3.html">sqlite3 - DB-API 2.0 interface for
SQLite databases --
http://docs.python.org/library/sqlite3.html</a></li>
<li><a class="reference external" href="http://www.sqlite.org/">SQLite home page --
http://www.sqlite.org/</a></li>
<li><a class="reference external" href="http://oss.itsystementwicklung.de/trac/pysqlite/">The pysqlite web page --
http://oss.itsystementwicklung.de/trac/pysqlite/</a></li>
</ul>
<p>If you want or need to use another, enterprise class database, for
example PostgreSQL, MySQL, Oracle, etc., you will need an interface
module for your specific database.  You can find information about
database interface modules here:
<a class="reference external" href="http://wiki.python.org/moin/DatabaseInterfaces">Database interfaces --
http://wiki.python.org/moin/DatabaseInterfaces</a></p>
<p>Excercises:</p>
<ol class="arabic simple">
<li>Write a script that retrieves all the rows in a table and prints
each row.</li>
<li>Write a script that retrieves all the rows in a table, then uses
the cursor as an iterator to print each row.</li>
<li>Write a script that uses the cursor's <tt class="docutils literal">description</tt> attribute
to print out the name and value of each field in each row.</li>
<li>Write a script that performs several of the above tasks, but
uses <tt class="docutils literal">sqlite3</tt> instead of <tt class="docutils literal">gadfly</tt>.</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">We can <tt class="docutils literal">execute</tt> a SQL query and then retrieve all the rows
with <tt class="docutils literal">fetchall()</tt>:</p>
<pre class="literal-block">
import gadfly

def test():
    connection = gadfly.connect(&quot;dbtest1&quot;, &quot;plantsdbdir&quot;)
    cur = connection.cursor()
    cur.execute('select * from plantsdb order by p_name')
    rows = cur.fetchall()
    for row in rows:
        print '2. row:', row
    connection.close()

test()
</pre>
</li>
<li><p class="first">The cursor itself is an iterator.  It iterates over the rows
returned by a query.  So, we execute a SQL query and then we use
the cursor in a <tt class="docutils literal">for:</tt> statement:</p>
<pre class="literal-block">
import gadfly

def test():
    connection = gadfly.connect(&quot;dbtest1&quot;, &quot;plantsdbdir&quot;)
    cur = connection.cursor()
    cur.execute('select * from plantsdb order by p_name')
    for row in cur:
        print row
    connection.close()

test()
</pre>
</li>
<li><p class="first">The description attribute in the cursor is a container that has
an item describing each field:</p>
<pre class="literal-block">
import gadfly

def test():
    cur.execute('select * from plantsdb order by p_name')
    for field in cur.description:
        print 'field:', field
    rows = cur.fetchall()
    for row in rows:
        for idx, field in enumerate(row):
            content = '%s: &quot;%s&quot;' % (cur.description[idx][0], field, )
            print content,
        print
    connection.close()

test()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The comma at the end of the <tt class="docutils literal">print</tt> statement tells Python
not to print a new-line.</li>
<li>The <tt class="docutils literal">cur.description</tt> is a sequence containing an item for
each field.  After the query, we can extract a description of
each field.</li>
</ul>
</li>
<li><p class="first">The solutions using <tt class="docutils literal">sqlite3</tt> are very similar to those using
<tt class="docutils literal">gadfly</tt>.  For information on <tt class="docutils literal">sqlite3</tt>, see:
<a class="reference external" href="http://docs.python.org/library/sqlite3.html#module-sqlite3">sqlite3  DB-API 2.0 interface for SQLite databases
http://docs.python.org/library/sqlite3.html#module-sqlite3</a>.</p>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;
Perform operations on sqlite3 (plants) database.

Usage:
    python py_db_api.py command [arg1, ... ]
Commands:
    create -- create new database.
    show -- show contents of database.
    add -- add row to database.  Requires 3 args (name, descrip, rating).
    delete - remove row from database.  Requires 1 arg (name).
Examples:
    python test1.py create
    python test1.py show
    python test1.py add crenshaw &quot;The most succulent melon&quot; 10
    python test1.py delete lemon
&quot;&quot;&quot;


import sys
import sqlite3

Values = [
    ('lemon', 'bright and yellow', '7'),
    ('peach', 'succulent', '9'),
    ('banana', 'smooth and creamy', '8'),
    ('nectarine', 'tangy and tasty', '9'),
    ('orange', 'sweet and tangy', '8'),
    ]

Field_defs = [
    'p_name varchar',
    'p_descrip varchar',
    #'p_rating integer',
    'p_rating varchar',
    ]


def createdb():
    connection = sqlite3.connect('sqlite3plantsdb')
    cursor = connection.cursor()
    q1 = &quot;create table plantsdb (%s)&quot; % (', '.join(Field_defs))
    print 'create q1: %s' % q1
    cursor.execute(q1)
    q1 = &quot;create index index1 on plantsdb(p_name)&quot;
    cursor.execute(q1)
    q1 = &quot;insert into plantsdb (p_name, p_descrip, p_rating) values ('%s', '%s', %s)&quot;
    for spec in Values:
        q2 = q1 % spec
        print 'q2: &quot;%s&quot;' % q2
        cursor.execute(q2)
    connection.commit()
    showdb1(cursor)
    connection.close()


def showdb():
    connection, cursor = opendb()
    showdb1(cursor)
    connection.close()


def showdb1(cursor):
    cursor.execute(&quot;select * from plantsdb order by p_name&quot;)
    hr()
    description = cursor.description
    print description
    print 'description:'
    for rowdescription in description:
        print '    %s' % (rowdescription, )
    hr()
    rows = cursor.fetchall()
    print rows
    print 'rows:'
    for row in rows:
        print '    %s' % (row, )
    hr()
    print 'content:'
    for row in rows:
        descrip = row[1]
        name = row[0]
        rating = '%s' % row[2]
        print '    %s%s%s' % (
            name.ljust(12), descrip.ljust(30), rating.rjust(4), )


def addtodb(name, descrip, rating):
    try:
        rating = int(rating)
    except ValueError, exp:
        print 'Error: rating must be integer.'
        return
    connection, cursor = opendb()
    cursor.execute(&quot;select * from plantsdb where p_name = '%s'&quot; % name)
    rows = cursor.fetchall()
    if len(rows) &gt; 0:
        ql = &quot;update plantsdb set p_descrip='%s', p_rating='%s' where p_name='%s'&quot; % (
            descrip, rating, name, )
        print 'ql:', ql
        cursor.execute(ql)
        connection.commit()
        print 'Updated'
    else:
        cursor.execute(&quot;insert into plantsdb values ('%s', '%s', '%s')&quot; % (
            name, descrip, rating))
        connection.commit()
        print 'Added'
    showdb1(cursor)
    connection.close()


def deletefromdb(name):
    connection, cursor = opendb()
    cursor.execute(&quot;select * from plantsdb where p_name = '%s'&quot; % name)
    rows = cursor.fetchall()
    if len(rows) &gt; 0:
        cursor.execute(&quot;delete from plantsdb where p_name='%s'&quot; % name)
        connection.commit()
        print 'Plant (%s) deleted.' % name
    else:
        print 'Plant (%s) does not exist.' % name
    showdb1(cursor)
    connection.close()


def opendb():
    connection = sqlite3.connect(&quot;sqlite3plantsdb&quot;)
    cursor = connection.cursor()
    return connection, cursor


def hr():
    print '-' * 60


def usage():
    print __doc__
    sys.exit(1)


def main():
    args = sys.argv[1:]
    if len(args) &lt; 1:
        usage()
    cmd = args[0]
    if cmd == 'create':
        if len(args) != 1:
            usage()
        createdb()
    elif cmd == 'show':
        if len(args) != 1:
            usage()
        showdb()
    elif cmd == 'add':
        if len(args) &lt; 4:
            usage()
        name = args[1]
        descrip = args[2]
        rating = args[3]
        addtodb(name, descrip, rating)
    elif cmd == 'delete':
        if len(args) &lt; 2:
            usage()
        name = args[1]
        deletefromdb(name)
    else:
        usage()

if __name__ == '__main__':
    main()
</pre>
</li>
</ol>
</div>
<div class="section" id="csv-comma-separated-value-files">
<h3><a class="toc-backref" href="#id234">3.9.3&nbsp;&nbsp;&nbsp;CSV -- comma separated value files</a></h3>
<p>There is support for parsing and generating CSV files in the Python
standard library.  See:
<a class="reference external" href="http://docs.python.org/library/csv.html#module-csv">csv  CSV File Reading and Writing
http://docs.python.org/library/csv.html#module-csv</a>.</p>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Read a CSV file and print the fields in columns.  Here is a
sample file to use as input:</p>
<pre class="literal-block">
# name  description  rating
Lemon,Bright yellow and tart,5
Eggplant,Purple and shiny,6
Tangerine,Succulent,8
</pre>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Use the CSV module in the Python standard library to read a CSV
file:</p>
<pre class="literal-block">
&quot;&quot;&quot;
Read a CSV file and print the contents in columns.
&quot;&quot;&quot;

import csv

def test(infilename):
    infile = open(infilename)
    reader = csv.reader(infile)
    print '====                 ===========                              ======'
    print 'Name                 Description                              Rating'
    print '====                 ===========                              ======'
    for fields in reader:
        if len(fields) == 3:
            line = '%s %s %s' % (fields[0].ljust(20),
                fields[1].ljust(40), fields[2].ljust(4))
            print line
    infile.close()

def main():
    infilename = 'csv_report.csv'
    test(infilename)

if __name__ == '__main__':
    main()
</pre>
<p>And, when run, here is what it displays:</p>
<pre class="literal-block">
====                 ===========                              ======
Name                 Description                              Rating
====                 ===========                              ======
Lemon                Bright yellow and tart                   5
Eggplant             Purple and shiny                         6
Tangerine            Succulent                                8
</pre>
</li>
</ol>
</div>
<div class="section" id="yaml-and-pyyaml">
<h3><a class="toc-backref" href="#id235">3.9.4&nbsp;&nbsp;&nbsp;YAML and PyYAML</a></h3>
<p>YAML is a structured text data representation format.  It uses
indentation to indicate nesting.  Here is a description from the
YAML Web site:</p>
<blockquote>
<p>&quot;YAML: YAML Ain't Markup Language</p>
<p>&quot;What It Is: YAML is a human friendly data serialization
standard for all programming languages.&quot;</p>
</blockquote>
<p>You can learn more about YAML and PyYAML here:</p>
<ul class="simple">
<li><a class="reference external" href="http://yaml.org/">The Official YAML Web Site --
http://yaml.org/</a></li>
<li><a class="reference external" href="http://pyyaml.org/">PyYAML.org - the home of various YAML implementations for Python --
http://pyyaml.org/</a></li>
<li><a class="reference external" href="http://yaml.org/spec/1.2/">The YAML 1.2 specification --
http://yaml.org/spec/1.2/</a></li>
</ul>
<p>Exercises:</p>
<ol class="arabic">
<li><p class="first">Read the following sample YAML document.  Print out the
information in it:</p>
<pre class="literal-block">
american:
  - Boston Red Sox
  - Detroit Tigers
  - New York Yankees
national:
  - New York Mets
  - Chicago Cubs
  - Atlanta Braves
</pre>
</li>
<li><p class="first">Load the YAML data used in the previous exercise, then make a
modification (for example, add &quot;San Francisco Giants&quot; to the
National League), then dump the modified data to a new file.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">Printing out information from YAML is as &quot;simple&quot; as printing
out a Python data structure.  In this solution, we use the
pretty printer from the Python standard library:</p>
<pre class="literal-block">
import yaml
import pprint

def test():
    infile = open('test1.yaml')
    data = yaml.load(infile)
    infile.close()
    pprint.pprint(data)

test()
</pre>
<p>We could, alternatively, read in and then &quot;load&quot; from a string:</p>
<pre class="literal-block">
import yaml
import pprint

def test():
    infile = open('test1.yaml')
    data_str = infile.read()
    infile.close()
    data = yaml.load(data_str)
    pprint.pprint(data)

test()
</pre>
</li>
<li><p class="first">The YAML <tt class="docutils literal">dump()</tt> function enables us to dump data to a file:</p>
<pre class="literal-block">
import yaml
import pprint

def test():
    infile = open('test1.yaml', 'r')
    data = yaml.load(infile)
    infile.close()
    data['national'].append('San Francisco Giants')
    outfile = open('test1_new.yaml', 'w')
    yaml.dump(data, outfile)
    outfile.close()

test()
</pre>
<p>Notes:</p>
<ul>
<li><p class="first">If we want to produce the standard YAML &quot;block&quot; style rather
than the &quot;flow&quot; format, then we could use:</p>
<pre class="literal-block">
yaml.dump(data, outfile, default_flow_style=False)
</pre>
</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="json">
<h3><a class="toc-backref" href="#id236">3.9.5&nbsp;&nbsp;&nbsp;Json</a></h3>
<p>Here is a quote from Wikipedia entry for Json:</p>
<blockquote>
&quot;JSON (pronounced 'Jason'), short for JavaScript Object
Notation, is a lightweight computer data interchange format. It
is a text-based, human-readable format for representing simple
data structures and associative arrays (called objects).&quot;</blockquote>
<p>The Json text representation looks very similar to Python literal
representation of Python builtin data types (for example, lists,
dictionaries, numbers, and strings).</p>
<p>Learn more about Json and Python support for Json here:</p>
<ul class="simple">
<li><a class="reference external" href="http://json.org/">Introducing JSON --
http://json.org/</a></li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Json">Json at Wikipedia --
http://en.wikipedia.org/wiki/Json</a></li>
<li><a class="reference external" href="http://pypi.python.org/pypi/python-json">python-json --
http://pypi.python.org/pypi/python-json</a></li>
<li><a class="reference external" href="http://pypi.python.org/pypi/simplejson">simplejson --
http://pypi.python.org/pypi/simplejson</a></li>
</ul>
<p>Excercises:</p>
<ol class="arabic">
<li><p class="first">Write a Python script, using your favorite Python Json
implementation (for example <tt class="docutils literal"><span class="pre">python-json</span></tt> or <tt class="docutils literal">simplejson</tt>),
that dumps the following data structure to a file:</p>
<pre class="literal-block">
Data = {
    'rock and roll':
        ['Elis', 'The Beatles', 'The Rolling Stones',],
    'country':
        ['Willie Nelson', 'Hank Williams', ]
    }
</pre>
</li>
<li><p class="first">Write a Python script that reads Json data from a file and loads
it into Python data structures.</p>
</li>
</ol>
<p>Solutions:</p>
<ol class="arabic">
<li><p class="first">This solution uses <tt class="docutils literal">simplejson</tt> to store a Python data
structure encoded as Json in a file:</p>
<pre class="literal-block">
import simplejson as json

Data = {
    'rock and roll':
        ['Elis', 'The Beatles', 'The Rolling Stones',],
    'country':
        ['Willie Nelson', 'Hank Williams', ]
    }

def test():
    fout = open('tmpdata.json', 'w')
    content = json.dumps(Data)
    fout.write(content)
    fout.write('\n')
    fout.close()

test()
</pre>
</li>
<li><p class="first">We can read the file into a string, then decode it from Json:</p>
<pre class="literal-block">
import simplejson as json

def test():
    fin = open('tmpdata.json', 'r')
    content = fin.read()
    fin.close()
    data = json.loads(content)
    print data

test()
</pre>
</li>
</ol>
<p>Note that you may want some control over indentation, character
encoding, etc.  For <tt class="docutils literal">simplejson</tt>, you can learn about that here:
<a class="reference external" href="http://simplejson.googlecode.com/svn/tags/simplejson-2.0.1/docs/index.html">simplejson - JSON encoder and decoder --
http://simplejson.googlecode.com/svn/tags/simplejson-2.0.1/docs/index.html</a>.</p>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="part-4-generating-python-bindings-for-xml">
<h1><a class="toc-backref" href="#id237">4&nbsp;&nbsp;&nbsp;Part 4 -- Generating Python Bindings for XML</a></h1>
<p>This section discusses a specific Python tool, specifically a
Python code generator that generates Python bindings for XML files.</p>
<p>Thus, this section will help you in the following ways:</p>
<ol class="arabic simple">
<li>It will help you learn to use a specific tool, namely
<tt class="docutils literal">generateDS.py</tt>, that generates Python code to be used to
process XML instance documents of a particular document type.</li>
<li>It will help you gain more experience with reading, modifying
and using Python code.</li>
</ol>
<div class="section" id="id26">
<h2><a class="toc-backref" href="#id238">4.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p><strong>Additional information:</strong></p>
<ul>
<li><p class="first">If you plan to work through this tutorial, you may find it helpful
to look at the sample code that accompanies this tutorial.  You
can find it in the distribution under:</p>
<pre class="literal-block">
tutorial/
tutorial/Code/
</pre>
</li>
<li><p class="first">You can find additional information about <tt class="docutils literal">generateDS.py</tt> here:</p>
<blockquote>
<p><a class="reference external" href="http://www.davekuhlman.org/generateDS.html">http://www.davekuhlman.org/generateDS.html</a></p>
</blockquote>
<p>That documentation is also included in the distribution.</p>
</li>
</ul>
<p><tt class="docutils literal">generateDS.py</tt> generates Python data structures (for example,
class definitions) from an XML schema document. These data
structures represent the elements in an XML document described by
the XML schema.  <tt class="docutils literal">generateDS.py</tt> also generates parsers that load
an XML document into those data structures. In addition, a separate
file containing subclasses (stubs) is optionally generated. The user
can add methods to the subclasses in order to process the contents
of an XML document.</p>
<p>The generated Python code contains:</p>
<ul class="simple">
<li>A class definition for each element defined in the XML schema
document.</li>
<li>A main and driver function that can be used to test the
generated code.</li>
<li>A parser that will read an XML document which satisfies the XML
schema from which the parser was generated. The parser creates
and populates a tree structure of instances of the generated
Python classes.</li>
<li>Methods in each class to export the instance back out to XML
(method <tt class="docutils literal">export</tt>) and to export the instance to a literal
representing the Python data structure (method
<tt class="docutils literal">exportLiteral</tt>).</li>
</ul>
<p>Each generated class contains the following:</p>
<ul class="simple">
<li>A constructor method (__init__), with member variable
initializers.</li>
<li>Methods with names <tt class="docutils literal">get_xyz</tt> and <tt class="docutils literal">set_xyz</tt> for each member
variable &quot;xyz&quot; or, if the member variable is defined with
<tt class="docutils literal"><span class="pre">maxOccurs=&quot;unbounded&quot;</span></tt>, methods with names <tt class="docutils literal">get_xyz</tt>,
<tt class="docutils literal">set_xyz</tt>, <tt class="docutils literal">add_xyz</tt>, and <tt class="docutils literal">insert_xyz</tt>.  (Note: If you use
the <tt class="docutils literal"><span class="pre">--use-old-getter-setter</span></tt>, then you will get methods with
names like <tt class="docutils literal">getXyz</tt> and <tt class="docutils literal">setXyz</tt>.)</li>
<li>A <tt class="docutils literal">build</tt> method that can be used to populate an instance of the
class from a node in an ElementTree or Lxml tree.</li>
<li>An <tt class="docutils literal">export</tt> method that will write the instance (and any nested
sub-instances) to a file object as XML text.</li>
<li>An <tt class="docutils literal">exportLiteral</tt> method that will write the instance (and any
nested sub-instances) to a file object as Python literals (text).</li>
</ul>
<p>The generated subclass file contains one (sub-)class definition
for each data representation class. If the subclass file is used,
then the parser creates instances of the subclasses (instead of
creating instances of the superclasses). This enables the user to
extend the subclasses with &quot;tree walk&quot; methods, for example, that
process the contents of the XML file. The user can also generate
and extend multiple subclass files which use a single, common
superclass file, thus implementing a number of different processes
on the same XML document type.</p>
<p>This document introduces the user to <tt class="docutils literal">generateDS.py</tt> and walks the
user through several examples that show how to generate Python code
and how to use that generated code.</p>
</div>
<div class="section" id="generating-the-code">
<h2><a class="toc-backref" href="#id239">4.2&nbsp;&nbsp;&nbsp;Generating the code</a></h2>
<p><strong>Note:</strong> The sample files used below are under the
<tt class="docutils literal">tutorial/Code/</tt> directory.</p>
<p>Use the following to get help:</p>
<pre class="literal-block">
$ generateDS.py --help
</pre>
<p>I'll assume that <tt class="docutils literal">generateDS.py</tt> is in a directory on your path.
If not, you should do whatever is necessary to make it accessible
and executable.</p>
<p>Here is a simple XML schema document:</p>
<p>And, here is how you might generate classes and subclasses that
provide data bindings (a Python API) for the definitions in that
schema:</p>
<pre class="literal-block">
$ generateDS.py -o people_api.py -s people_sub.py people.xsd
</pre>
<p>And, if you want to automatically over-write the generated Python
files, use the <tt class="docutils literal"><span class="pre">-f</span></tt> command line flag to force over-write without
asking:</p>
<pre class="literal-block">
$ generateDS.py -f -o people_api.py -s people_sub.py people.xsd
</pre>
<p>And, to hard-wire the subclass file so that it imports the API
module, use the <tt class="docutils literal"><span class="pre">--super</span></tt> command line file.  Example:</p>
<pre class="literal-block">
$ generateDS.py -o people_api.py people.xsd
$ generateDS.py -s people_appl1.py --super=people_api people.xsd
</pre>
<p>Or, do both at the same time with the following:</p>
<pre class="literal-block">
$ generateDS.py -o people_api.py -s people_appl1.py --super=people_api people.xsd
</pre>
<p>And, for your second application:</p>
<pre class="literal-block">
$ generateDS.py -s people_appl2.py --super=people_api people.xsd
</pre>
<p>If you take a look inside these two &quot;application&quot; files, you will
see and import statement like the following:</p>
<pre class="literal-block">
import ??? as supermod
</pre>
<p>If you had not used the <tt class="docutils literal"><span class="pre">--super</span></tt> command line option when
generating the &quot;application&quot; files, then you could modify that
statement yourself.  The <tt class="docutils literal"><span class="pre">--super</span></tt> command line option does this
for you.</p>
<p>You can also use the <a class="reference internal" href="#the-graphical-front-end">The graphical front-end</a> to configure options
and save them in a session file, then use that session file with
<tt class="docutils literal">generateDS.py</tt> to specify your command line options.  For
example:</p>
<pre class="literal-block">
$ generateDS.py --session=test01.session
</pre>
<p>You can test the generated code by running it.  Try something like
the following:</p>
<pre class="literal-block">
$ python people_api.py people.xml
</pre>
<p>or:</p>
<pre class="literal-block">
$ python people_appl1.py people.xml
</pre>
<p>Why does this work?  Why can we run the generated code as a Python
script? -- If you look at the generated code, down near the end of
the file you'll find a <tt class="docutils literal">main()</tt> function that calls a function
named <tt class="docutils literal">parse()</tt>.  The <tt class="docutils literal">parse</tt> function does the following:</p>
<ol class="arabic simple">
<li>Parses your XML instance document.</li>
<li>Uses your generated API to build a tree of instances of the
generated classes.</li>
<li>Uses the <tt class="docutils literal">export()</tt> methods in that tree of instances to print
out (export) XML that represents your generated tree of
instances.</li>
</ol>
<p>Except for some indentation (ignorable whitespace), this exported
XML should be the same as the original XML document.  So, that
gives you a reasonably thorough test of your generated code.</p>
<p>And, the code in that <tt class="docutils literal">parse()</tt> function gives you a hint of how
you might build your own application-specific code that uses the
generated API (those generated Python classes).</p>
</div>
<div class="section" id="using-the-generated-code-to-parse-and-export-an-xml-document">
<h2><a class="toc-backref" href="#id240">4.3&nbsp;&nbsp;&nbsp;Using the generated code to parse and export an XML document</a></h2>
<p>Now that you have generated code for your data model, you can test
it by running it as an application.  Suppose that you have an
XML instance document <tt class="docutils literal">people1.xml</tt> that satisfies your schema.
Then you can parse that instance document and export it (print it
out) with something like the following:</p>
<pre class="literal-block">
$ python people_api.py people1.xml
</pre>
<p>And, if you have used the <tt class="docutils literal"><span class="pre">--super</span></tt> command line option, as I
have above, to connect your subclass file with the superclass
(API) file, then you could use the following to do the same thing:</p>
<pre class="literal-block">
$ python people_appl1.py people1.xml
</pre>
</div>
<div class="section" id="some-command-line-options-you-might-want-to-know">
<h2><a class="toc-backref" href="#id241">4.4&nbsp;&nbsp;&nbsp;Some command line options you might want to know</a></h2>
<p>You may want to merely skim this section for now, then later refer
back to it when some of these options are are used later in
this tutorial.  Also, remember that you can get information about
more command line options used by <tt class="docutils literal">generateDS.py</tt> by typing:</p>
<pre class="literal-block">
$ python generateDS.py --help
</pre>
<p>and by reading the document
<a class="reference external" href="http://www.davekuhlman.org/generateDS.html">http://www.davekuhlman.org/generateDS.html</a></p>
<dl class="docutils">
<dt>o</dt>
<dd>Generate the superclass module.  This is the module that
contains the implementation of each class for each element
type.  So, you can think of this as the implementation of the
&quot;data bindings&quot; or the API for XML documents of the type
defined by your XML schema.</dd>
<dt>s</dt>
<dd>Generate the subclass module.  You might or might not need
these.  If you intend to write some application-specific code,
you might want to consider starting with these skeleton classes
and add your application code there.</dd>
<dt>super</dt>
<dd>This option inserts the name of the superclass module into an
<tt class="docutils literal">import</tt> statement in the subclass file (generated with
&quot;-s&quot;).  If you know the name of the superclass file in
advance, you can use this option to enable the subclass file
to import the superclass module automatically.  If you do not
use this option, you will need to edit the
subclass module with your text editor and modify the import
statement near the top.</dd>
<dt>root-element=&quot;element-name&quot;</dt>
<dd><p class="first">Use this option to tell generateDS.py which of the elements
defined in your XM schema is the &quot;root&quot; element.  The root
element is the outer-most (top-level) element in XML instance
documents defined by this schema.  In effect, this tells your
generated modules which element to use as the root element when
parsing and exporting documents.</p>
<p class="last"><tt class="docutils literal">generateDS.py</tt> attempts to guess the root element, usually
the first element defined in your XML schema.  Use this option
when that default is not what you want.</p>
</dd>
<dt>member-specs=list|dict</dt>
<dd>Suppose you want to write some code that can be generically
applied to elements of different kinds (element types implemented
by several <em>different</em> generated classes.  If so, it might be
helpful to have a list or dictionary specifying information
about each member data item in each class.  This option does
that by generating a list or a dictionary (with the member data
item name as key) in each generated class.  Take a look at the
generated code to learn about it.  In particular, look at the
generated list or dictionary in a class for any element type
and also at the definition of the class <tt class="docutils literal">_MemberSpec</tt>
generated near the top of the API module.</dd>
<dt>version</dt>
<dd>Ask <tt class="docutils literal">generateDS.py</tt> to tell you what version it is.  This is
helpful when you want to ask about a problem, for example at
the generateds-users email list
(<a class="reference external" href="https://lists.sourceforge.net/lists/listinfo/generateds-users">https://lists.sourceforge.net/lists/listinfo/generateds-users</a>),
and want to specify which version you are using.</dd>
</dl>
</div>
<div class="section" id="the-graphical-front-end">
<h2><a class="toc-backref" href="#id242">4.5&nbsp;&nbsp;&nbsp;The graphical front-end</a></h2>
<p>There is also a point-and-click way to run <tt class="docutils literal">generateDS</tt>.  It
enables you to specify the options needed by <tt class="docutils literal">generateDS.py</tt>
through a graphical interface, then to run <tt class="docutils literal">generateDS.py</tt> with
those options.  It also</p>
<p>You can run it, if you have installed <tt class="docutils literal">generateDS</tt>, by typing the
following at a command line:</p>
<pre class="literal-block">
$ generateds_gui.py
</pre>
<p>After configuring options, you can save those options in a
&quot;session&quot; file, which can be loaded later.  Look under the <tt class="docutils literal">File</tt>
menu for save and load commands and also consider using the
&quot;--session&quot; command line option.</p>
<p>Also note that <tt class="docutils literal">generateDS.py</tt> itself supports a &quot;--session&quot;
command line option that enables you to run <tt class="docutils literal">generateDS.py</tt> with
the options that you specified and saved with the graphical
front-end.</p>
</div>
<div class="section" id="adding-application-specific-behavior">
<h2><a class="toc-backref" href="#id243">4.6&nbsp;&nbsp;&nbsp;Adding application-specific behavior</a></h2>
<p><tt class="docutils literal">generateDS.py</tt> generates Python code which, with no modification, will
parse and then export an XML document defined by your schema.  However, you
are likely to want to go beyond that.  In many situations you will want to
construct a custom application that processes your XML documents using the
generated code.</p>
<div class="section" id="implementing-custom-subclasses">
<h3><a class="toc-backref" href="#id244">4.6.1&nbsp;&nbsp;&nbsp;Implementing custom subclasses</a></h3>
<p>One strategy is to generate a subclass file and to add your
application-specific code to that.  Generate the subclass file
with the &quot;-s&quot; command line flag:</p>
<pre class="literal-block">
$ generateDS.py -s myapp.py people.xsd
</pre>
<p>Now add some application-specific code to <tt class="docutils literal">myapp.py</tt>, for
example, if you are using the included &quot;people&quot; sample files:</p>
<pre class="literal-block">
class peopleTypeSub(supermod.people):
    def __init__(self, comments=None, person=None, programmer=None,
        python_programmer=None, java_programmer=None):
        supermod.people.__init__(self, comments, person, programmer, python_programmer,
            java_programmer)
    def fancyexport(self, outfile):
        outfile.write('Starting fancy export')
        for person in self.get_person():
            person.fancyexport(outfile)
supermod.people.subclass = peopleTypeSub
# end class peopleTypeSub

class personTypeSub(supermod.person):
    def __init__(self, vegetable=None, fruit=None, ratio=None, id=None, value=None,
        name=None, interest=None, category=None, agent=None, promoter=None,
        description=None):
        supermod.person.__init__(self, vegetable, fruit, ratio, id, value,
            name, interest, category, agent, promoter, description)
    def fancyexport(self, outfile):
        outfile.write('Fancy person export -- name: %s' %
            self.get_name(), )
supermod.person.subclass = personTypeSub
# end class personTypeSub
</pre>
</div>
<div class="section" id="using-the-generated-api-from-your-application">
<h3><a class="toc-backref" href="#id245">4.6.2&nbsp;&nbsp;&nbsp;Using the generated &quot;API&quot; from your application</a></h3>
<p>In this approach you might do things like the following:</p>
<ul class="simple">
<li><tt class="docutils literal">import</tt> your generated classes.</li>
<li>Create instances of those classes.</li>
<li>Link those instances, for example put &quot;children&quot; inside of a
parent, or add one or more instances to a parent that can contain
a list of objects (think &quot;maxOccurs&quot; greater than 1 in your
schema)</li>
</ul>
<p>Get to know the generated export API by inspecting the generated
code in the superclass file.  That's the file generated with the
&quot;-o&quot; command line flag.</p>
<p>What to look for:</p>
<ul class="simple">
<li>Look at the arguments to the constructor (<tt class="docutils literal">__init__</tt>) to learn
how to initialize an instance.</li>
<li>Look at the &quot;getters&quot; and &quot;setters&quot; (methods name <tt class="docutils literal">getxxx</tt>
and <tt class="docutils literal">setxxx</tt>, to learn how to modify member variables.</li>
<li>Look for a method named <tt class="docutils literal">addxxx</tt> for members that are lists.
These correspond to members defined with <tt class="docutils literal"><span class="pre">maxOccurs=&quot;n&quot;</span></tt>, where
n &gt; 1.</li>
<li>Look at the build methods: <tt class="docutils literal">build</tt>, <tt class="docutils literal">buildChildren</tt>, and
<tt class="docutils literal">buildAttributes</tt>.  These will give you information about how
to construct each of the members of a given element/class.</li>
</ul>
<p>Now, you can import your generated API module, and use it to
construct and manipulate objects.  Here is an example using code
generated with the &quot;people&quot; schema:</p>
<pre class="literal-block">
import sys
import people_api as api

def test(names):
    people = api.peopleType()
    for count, name in enumerate(names):
        id = '%d' % (count + 1, )
        person = api.personType(name=name, id=id)
        people.add_person(person)
    people.export(sys.stdout, 0)

test(['albert', 'betsy', 'charlie'])
</pre>
<p>Run this and you might see something like the following:</p>
<pre class="literal-block">
$ python tmp.py
&lt;people &gt;
    &lt;person  id=&quot;1&quot;&gt;
        &lt;name&gt;albert&lt;/name&gt;
    &lt;/person&gt;
    &lt;person  id=&quot;2&quot;&gt;
        &lt;name&gt;betsy&lt;/name&gt;
    &lt;/person&gt;
    &lt;person  id=&quot;3&quot;&gt;
        &lt;name&gt;charlie&lt;/name&gt;
    &lt;/person&gt;
&lt;/people&gt;
</pre>
</div>
<div class="section" id="a-combined-approach">
<h3><a class="toc-backref" href="#id246">4.6.3&nbsp;&nbsp;&nbsp;A combined approach</a></h3>
<p><strong>Note:</strong> You can find examples of the code in this section in these
files:</p>
<pre class="literal-block">
tutorial/Code/upcase_names.py
tutorial/Code/upcase_names_appl.py
</pre>
<p>Here are the relevant, modified subclasses (<tt class="docutils literal">upcase_names_appl.py</tt>):</p>
<pre class="literal-block">
import people_api as supermod

class peopleTypeSub(supermod.peopleType):
    def __init__(self, comments=None, person=None, specialperson=None, programmer=None, python_programmer=None, java_programmer=None):
        super(peopleTypeSub, self).__init__(comments, person, specialperson, programmer, python_programmer, java_programmer, )
    def upcase_names(self):
        for person in self.get_person():
            person.upcase_names()
supermod.peopleType.subclass = peopleTypeSub
# end class peopleTypeSub

class personTypeSub(supermod.personType):
    def __init__(self, vegetable=None, fruit=None, ratio=None, id=None, value=None, name=None, interest=None, category=None, agent=None, promoter=None, description=None, range_=None, extensiontype_=None):
        super(personTypeSub, self).__init__(vegetable, fruit, ratio, id, value, name, interest, category, agent, promoter, description, range_, extensiontype_, )
    def upcase_names(self):
        self.set_name(self.get_name().upper())
supermod.personType.subclass = personTypeSub
# end class personTypeSub
</pre>
<p>Notes:</p>
<ul class="simple">
<li>These classes were generated with the &quot;-s&quot; command line option.
They are subclasses of classes in the module <tt class="docutils literal">people_api</tt>,
which was generated with the &quot;-o&quot; command line option.</li>
<li>The only modification to the skeleton subclasses is the addition
of the two methods named <tt class="docutils literal">upcase_names()</tt>.</li>
<li>In the subclass <tt class="docutils literal">peopleTypeSub</tt>, the method <tt class="docutils literal">upcase_names()</tt>
merely walk over its immediate children.</li>
<li>In the subclass <tt class="docutils literal">personTypeSub</tt>, the method <tt class="docutils literal">upcase_names()</tt>
just converts the value of its &quot;name&quot; member to upper case.</li>
</ul>
<p>Here is the application itself (<tt class="docutils literal">upcase_names.py</tt>):</p>
<pre class="literal-block">
import sys
import upcase_names_appl as appl

def create_people(names):
    people = appl.peopleTypeSub()
    for count, name in enumerate(names):
        id = '%d' % (count + 1, )
        person = appl.personTypeSub(name=name, id=id)
        people.add_person(person)
    return people

def main():
    names = ['albert', 'betsy', 'charlie']
    people = create_people(names)
    print 'Before:'
    people.export(sys.stdout, 1)
    people.upcase_names()
    print '-' * 50
    print 'After:'
    people.export(sys.stdout, 1)

main()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The <tt class="docutils literal">create_people()</tt> function creates a <tt class="docutils literal">peopleTypeSub</tt> instance
with several <tt class="docutils literal">personTypeSub</tt> instances inside it.</li>
</ul>
<p>And, when you run this mini-application, here is what you might
see:</p>
<pre class="literal-block">
$ python upcase_names.py
Before:
    &lt;people &gt;
        &lt;person  id=&quot;1&quot;&gt;
            &lt;name&gt;albert&lt;/name&gt;
        &lt;/person&gt;
        &lt;person  id=&quot;2&quot;&gt;
            &lt;name&gt;betsy&lt;/name&gt;
        &lt;/person&gt;
        &lt;person  id=&quot;3&quot;&gt;
            &lt;name&gt;charlie&lt;/name&gt;
        &lt;/person&gt;
    &lt;/people&gt;
--------------------------------------------------
After:
    &lt;people &gt;
        &lt;person  id=&quot;1&quot;&gt;
            &lt;name&gt;ALBERT&lt;/name&gt;
        &lt;/person&gt;
        &lt;person  id=&quot;2&quot;&gt;
            &lt;name&gt;BETSY&lt;/name&gt;
        &lt;/person&gt;
        &lt;person  id=&quot;3&quot;&gt;
            &lt;name&gt;CHARLIE&lt;/name&gt;
        &lt;/person&gt;
    &lt;/people&gt;
</pre>
</div>
</div>
<div class="section" id="special-situations-and-uses">
<h2><a class="toc-backref" href="#id247">4.7&nbsp;&nbsp;&nbsp;Special situations and uses</a></h2>
<div class="section" id="generic-type-independent-processing">
<h3><a class="toc-backref" href="#id248">4.7.1&nbsp;&nbsp;&nbsp;Generic, type-independent processing</a></h3>
<p>There are times when you would like to implement a function or
method that can perform operations on a variety of members <em>and</em>
that needs type information about each member.</p>
<p>You can get help with this by generating your code with the
&quot;--member-specs&quot; command line option.  When you use this option,
<tt class="docutils literal">generateDS.py</tt> add a list or a dictionary containing an item for
each member.  If you want a list, then use &quot;--member-specs=list&quot;,
and if you want a dictionary, with member names as keys, then use
&quot;--member-specs=dict&quot;.</p>
<p>Here is an example -- In this example, we walk the
document/instance tree and convert all string simple types to upper
case.</p>
<p>Here is a schema (<tt class="docutils literal">Code/member_specs.xsd</tt>):</p>
<pre class="literal-block">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;

  &lt;xs:element name=&quot;contact-list&quot; type=&quot;contactlistType&quot; /&gt;

  &lt;xs:complexType name=&quot;contactlistType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;description&quot; type=&quot;xs:string&quot; /&gt;
        &lt;xs:element name=&quot;contact&quot; type=&quot;contactType&quot; maxOccurs=&quot;unbounded&quot; /&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;locator&quot; type=&quot;xs:string&quot; /&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;contactType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;first-name&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;last-name&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;interest&quot; type=&quot;xs:string&quot; maxOccurs=&quot;unbounded&quot; /&gt;
      &lt;xs:element name=&quot;category&quot; type=&quot;xs:integer&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:integer&quot; /&gt;
    &lt;xs:attribute name=&quot;priority&quot; type=&quot;xs:float&quot; /&gt;
    &lt;xs:attribute name=&quot;color-code&quot; type=&quot;xs:string&quot; /&gt;
  &lt;/xs:complexType&gt;

&lt;/xs:schema&gt;
</pre>
<div class="section" id="step-1-generate-the-bindings">
<h4><a class="toc-backref" href="#id249">4.7.1.1&nbsp;&nbsp;&nbsp;Step 1 -- generate the bindings</a></h4>
<p>We generate code with the following command line:</p>
<pre class="literal-block">
$ generateDS.py -f \
  -o member_specs_api.py \
  -s member_specs_upper.py \
  --super=member_specs_api \
  --member-specs=list \
  member_specs.xsd
</pre>
<p>Notes:</p>
<ul class="simple">
<li>We generate the member specifications as a list with the command
line option <tt class="docutils literal"><span class="pre">--member-specs=list</span></tt>.</li>
<li>We generate an &quot;application&quot; module with the <tt class="docutils literal"><span class="pre">-s</span></tt> command line
option.  We'll put our application specific code in
<tt class="docutils literal">member_specs_upper.py</tt>.</li>
</ul>
</div>
<div class="section" id="step-2-add-application-specific-code">
<h4><a class="toc-backref" href="#id250">4.7.1.2&nbsp;&nbsp;&nbsp;Step 2 -- add application-specific code</a></h4>
<p>And, here is the subclass file (<tt class="docutils literal">member_specs_upper.py</tt>, generated
with the &quot;-s&quot; command line option), to which we have added a bit of
code that converts any string-type members to upper case.  You can
think of this module as a special &quot;application&quot; of the generated
classes.</p>
<pre class="literal-block">
#!/usr/bin/env python

#
# member_specs_upper.py
#

#
# Generated Tue Nov  9 15:54:47 2010 by generateDS.py version 2.2a.
#

import sys

import member_specs_api as supermod

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print(&quot;running with lxml.etree&quot;)
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print(&quot;running with cElementTree on Python 2.5+&quot;)
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print(&quot;running with ElementTree on Python 2.5+&quot;)
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print(&quot;running with cElementTree&quot;)
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print(&quot;running with ElementTree&quot;)
                except ImportError:
                    raise ImportError(&quot;Failed to import ElementTree from any known place&quot;)

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Utility funtions needed in each generated class.
#

def upper_elements(obj):
    for item in obj.member_data_items_:
        if item.get_data_type() == 'xs:string':
            name = remap(item.get_name())
            val1 = getattr(obj, name)
            if isinstance(val1, list):
                for idx, val2 in enumerate(val1):
                    val1[idx] = val2.upper()
            else:
                setattr(obj, name, val1.upper())

def remap(name):
    newname = name.replace('-', '_')
    return newname


#
# Data representation classes
#

class contactlistTypeSub(supermod.contactlistType):
    def __init__(self, locator=None, description=None, contact=None):
        super(contactlistTypeSub, self).__init__(locator, description, contact, )
    def upper(self):
        upper_elements(self)
        for child in self.get_contact():
            child.upper()
supermod.contactlistType.subclass = contactlistTypeSub
# end class contactlistTypeSub


class contactTypeSub(supermod.contactType):
    def __init__(self, priority=None, color_code=None, id=None, first_name=None, last_name=None, interest=None, category=None):
        super(contactTypeSub, self).__init__(priority, color_code, id, first_name, last_name, interest, category, )
    def upper(self):
        upper_elements(self)
supermod.contactType.subclass = contactTypeSub
# end class contactTypeSub


def get_root_tag(node):
    tag = supermod.Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = None
    if hasattr(supermod, tag):
        rootClass = getattr(supermod, tag)
    return tag, rootClass


def parse(inFilename):
    doc = parsexml_(inFilename)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'contact-list'
        rootClass = supermod.contactlistType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('&lt;?xml version=&quot;1.0&quot; ?&gt;\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='')
    doc = None
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'contact-list'
        rootClass = supermod.contactlistType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('&lt;?xml version=&quot;1.0&quot; ?&gt;\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='')
    return rootObj


def parseLiteral(inFilename):
    doc = parsexml_(inFilename)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'contact-list'
        rootClass = supermod.contactlistType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from member_specs_api import *\n\n')
    sys.stdout.write('import member_specs_api as model_\n\n')
    sys.stdout.write('rootObj = model_.contact_list(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=&quot;contact_list&quot;)
    sys.stdout.write(')\n')
    return rootObj


USAGE_TEXT = &quot;&quot;&quot;
Usage: python ???.py &lt;infilename&gt;
&quot;&quot;&quot;

def usage():
    print USAGE_TEXT
    sys.exit(1)


def main():
    args = sys.argv[1:]
    if len(args) != 1:
        usage()
    infilename = args[0]
    root = parse(infilename)


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>We add the functions <tt class="docutils literal">upper_elements</tt> and <tt class="docutils literal">remap</tt> that we use
in each generated class.</li>
<li>Notice how the function <tt class="docutils literal">upper_elements</tt> calls the function
<tt class="docutils literal">remap</tt> <em>only</em> on those members whose type is <tt class="docutils literal">xs:string</tt>.</li>
<li>In each generated (sub-)class, we add the methods that walk the
DOM tree and apply the method (<tt class="docutils literal">upper</tt>) that transforms each
<tt class="docutils literal">xs:string</tt> value.</li>
</ul>
</div>
<div class="section" id="step-3-write-a-test-driver-harness">
<h4><a class="toc-backref" href="#id251">4.7.1.3&nbsp;&nbsp;&nbsp;Step 3 -- write a test/driver harness</a></h4>
<p>Here is a test driver (<tt class="docutils literal">member_specs_test.py</tt>) for our (mini-)
application:</p>
<pre class="literal-block">
#!/usr/bin/env python

#
# member_specs_test.py
#

import sys
import member_specs_api as supermod
import member_specs_upper


def process(inFilename):
    doc = supermod.parsexml_(inFilename)
    rootNode = doc.getroot()
    rootClass = member_specs_upper.contactlistTypeSub
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('&lt;?xml version=&quot;1.0&quot; ?&gt;\n')
    rootObj.export(sys.stdout, 0, name_=&quot;contact-list&quot;,
        namespacedef_='')
    rootObj.upper()
    sys.stdout.write('-' * 60)
    sys.stdout.write('\n')
    rootObj.export(sys.stdout, 0, name_=&quot;contact-list&quot;,
        namespacedef_='')
    return rootObj


USAGE_MSG = &quot;&quot;&quot;\
Synopsis:
    Sample application using classes and subclasses generated by generateDS.py
Usage:
    python member_specs_test.py infilename
&quot;&quot;&quot;

def usage():
    print USAGE_MSG
    sys.exit(1)

def main():
    args = sys.argv[1:]
    if len(args) != 1:
        usage()
    infilename = args[0]
    process(infilename)

if __name__ == '__main__':
    main()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>We copy the function <tt class="docutils literal">parse()</tt> from our generated code to serve
as a model for our function <tt class="docutils literal">process()</tt>.</li>
<li>After parsing and displaying the XML instance document, we call
method <tt class="docutils literal">upper()</tt> in the generated class <tt class="docutils literal">contactlistTypeSub</tt>
in order to walk the DOM tree and transform each <tt class="docutils literal">xs:string</tt> to
uppercase.</li>
</ul>
</div>
<div class="section" id="step-4-run-the-test-application">
<h4><a class="toc-backref" href="#id252">4.7.1.4&nbsp;&nbsp;&nbsp;Step 4 -- run the test application</a></h4>
<p>We can use the following command line to run our application:</p>
<pre class="literal-block">
$ python member_specs_test.py member_specs_data.xml
</pre>
<p>When we run our application, here is the output:</p>
<pre class="literal-block">
$ python member_specs_test.py member_specs_data.xml
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;contact-list locator=&quot;http://www.rexx.com/~dkuhlman&quot;&gt;
    &lt;description&gt;My list of contacts&lt;/description&gt;
    &lt;contact priority=&quot;0.050000&quot; color-code=&quot;red&quot; id=&quot;1&quot;&gt;
        &lt;first-name&gt;arlene&lt;/first-name&gt;
        &lt;last-name&gt;Allen&lt;/last-name&gt;
        &lt;interest&gt;traveling&lt;/interest&gt;
        &lt;category&gt;2&lt;/category&gt;
    &lt;/contact&gt;
&lt;/contact-list&gt;
------------------------------------------------------------
&lt;contact-list locator=&quot;HTTP://WWW.REXX.COM/~DKUHLMAN&quot;&gt;
    &lt;description&gt;MY LIST OF CONTACTS&lt;/description&gt;
    &lt;contact priority=&quot;0.050000&quot; color-code=&quot;RED&quot; id=&quot;1&quot;&gt;
        &lt;first-name&gt;ARLENE&lt;/first-name&gt;
        &lt;last-name&gt;ALLEN&lt;/last-name&gt;
        &lt;interest&gt;TRAVELING&lt;/interest&gt;
        &lt;category&gt;2&lt;/category&gt;
    &lt;/contact&gt;
&lt;/contact-list&gt;
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The output above shows both before- and after-version of
exporting the parsed XML instance document.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="some-hints">
<h2><a class="toc-backref" href="#id253">4.8&nbsp;&nbsp;&nbsp;Some hints</a></h2>
<p>The following hints are offered for convenience.  You can discover
them for yourself rather easily by inspecting the generated code.</p>
<div class="section" id="children-defined-with-maxoccurs-greater-than-1">
<h3><a class="toc-backref" href="#id254">4.8.1&nbsp;&nbsp;&nbsp;Children defined with maxOccurs greater than 1</a></h3>
<p>If a child element is defined in the XML schema with
<tt class="docutils literal"><span class="pre">maxOccurs=&quot;unbounded&quot;</span></tt> or a value of <tt class="docutils literal">maxOccurs</tt> greater than
1, then access to the child is through a list.</p>
</div>
<div class="section" id="children-defined-with-simple-numeric-types">
<h3><a class="toc-backref" href="#id255">4.8.2&nbsp;&nbsp;&nbsp;Children defined with simple numeric types</a></h3>
<p>If a child element is defined as a numeric type such as
<tt class="docutils literal">xs:integer</tt>, <tt class="docutils literal">xs:float</tt>, or <tt class="docutils literal">xs:double</tt> or as a simple type
that is (ultimately) based on a numeric type, then the value is
stored (in the Python object) as a Python data type (<tt class="docutils literal">int</tt>,
<tt class="docutils literal">float</tt>, etc).</p>
</div>
<div class="section" id="the-type-of-an-element-s-character-content">
<h3><a class="toc-backref" href="#id256">4.8.3&nbsp;&nbsp;&nbsp;The type of an element's character content</a></h3>
<p>But, when the element itself is defined as <tt class="docutils literal"><span class="pre">mixed=&quot;true&quot;</span></tt> or the
element a restriction of and has a simple (numeric) as a base, then
the <tt class="docutils literal">valueOf_</tt> instance variable holds the character content and
it is always a string, that is it is not converted.</p>
</div>
<div class="section" id="constructors-and-their-default-values">
<h3><a class="toc-backref" href="#id257">4.8.4&nbsp;&nbsp;&nbsp;Constructors and their default values</a></h3>
<p>All parameters to the constructors of generated classes have
default parameters.  Therefore, you can create an &quot;empty&quot; instance
of any element by calling the constructor with no parameters.</p>
<p>For example, suppose we have the following XML schema:</p>
<pre class="literal-block">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;

  &lt;xs:element name=&quot;plant-list&quot; type=&quot;PlantList&quot; /&gt;

  &lt;xs:complexType name=&quot;PlantType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;description&quot; type=&quot;xs:string&quot; /&gt;
        &lt;xs:element name=&quot;catagory&quot; type=&quot;xs:integer&quot; /&gt;
        &lt;xs:element name=&quot;fertilizer&quot; type=&quot;FertilizerType&quot; maxOccurs=&quot;unbounded&quot; /&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;identifier&quot; type=&quot;xs:string&quot; /&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;FertilizerType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;description&quot; type=&quot;xs:string&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:integer&quot; /&gt;
  &lt;/xs:complexType&gt;

&lt;/xs:schema&gt;
</pre>
<p>And, suppose we generate a module with the following command line:</p>
<pre class="literal-block">
$ ./generateDS.py -o garden_api.py garden.xsd
</pre>
<p>Then, for the element named <tt class="docutils literal">PlantType</tt> in the generated module
named <tt class="docutils literal">garden_api.py</tt>, you can create an instance as follows:</p>
<pre class="literal-block">
&gt;&gt;&gt; import garden_api
&gt;&gt;&gt; plant = garden_api.PlantType()
&gt;&gt;&gt; import sys
&gt;&gt;&gt; plant.export(sys.stdout, 0)
&lt;PlantType/&gt;
</pre>
</div>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="python_book_01.txt">View document source</a>.
Generated on: 2014-10-05 23:01 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
